<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LeakCanary为什么这么神奇？ | RayQuester</title><meta name="author" content="RQ527"><meta name="copyright" content="RQ527"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之前简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。 源码分析上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。 在理解LeakCanary源码之">
<meta property="og:type" content="article">
<meta property="og:title" content="LeakCanary为什么这么神奇？">
<meta property="og:url" content="http://rq527.github.io/rq/e54d6d21.html">
<meta property="og:site_name" content="RayQuester">
<meta property="og:description" content="之前简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。 源码分析上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。 在理解LeakCanary源码之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rq527.github.io/img/header.jpg">
<meta property="article:published_time" content="2022-07-15T15:13:22.000Z">
<meta property="article:modified_time" content="2023-05-14T06:09:38.693Z">
<meta property="article:author" content="RQ527">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="内存泄漏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rq527.github.io/img/header.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://rq527.github.io/rq/e54d6d21.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeakCanary为什么这么神奇？',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-14 14:09:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 菜单</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RayQuester"><span class="site-name">RayQuester</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 菜单</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeakCanary为什么这么神奇？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-15T15:13:22.000Z" title="发表于 2022-07-15 23:13:22">2022-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-14T06:09:38.693Z" title="更新于 2023-05-14 14:09:38">2023-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeakCanary为什么这么神奇？"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>之前简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p>
<p>在理解LeakCanary源码之前我们先来了解一下java虚拟机里的强引用，软引用，弱引用和虚引用。</p>
<ul>
<li>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</li>
<li>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</li>
<li>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</li>
<li>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</li>
</ul>
<p>而LeakCanary核心原理就是利用弱引用和引用队列ReferenceQueue来检测Activity&#x2F;Fragment被销毁后是否被回收。如果弱引用的引用对象被垃圾回收器回收，虚拟机就会把这个弱引用加入到与之关联的引用队列中，我们就可以此特性来检查一个对象是否被垃圾回收器回收成功。我们将上述用代码简单实现就是下面这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> obj: Any? = Object()</span><br><span class="line">    <span class="keyword">val</span> referenceQueue = ReferenceQueue&lt;Any?&gt;()</span><br><span class="line">    <span class="keyword">val</span> weakReference = WeakReference&lt;Any?&gt;(obj, referenceQueue)<span class="comment">//将对象obj与软引用关联，再将软引用与引用队列关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ref = referenceQueue.poll()<span class="comment">//从引用队列取出软引用，此时obj未被回收，取出的是null</span></span><br><span class="line">    println(<span class="string">&quot;gcBefore:<span class="subst">$&#123;ref&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    obj = <span class="literal">null</span><span class="comment">//将obj与Object()的引用断开，此时obj将被GC回收</span></span><br><span class="line">    </span><br><span class="line">    System.gc()</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    </span><br><span class="line">    ref = referenceQueue.poll()<span class="comment">//obj被回收，软引用入列，取出不为null</span></span><br><span class="line">    println(<span class="string">&quot;gcAfter:<span class="subst">$&#123;ref&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcBefore:null</span><br><span class="line">gcAfter:java.lang.ref.WeakReference@60f82f98</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>恰好印证。那么我们知道了核心原理，是否可以实现一个简单版的LeakCanary捏？说干就干！</p>
<p>首先，我们需要封装一下我们的弱引用，因为往往我们观测的是多个对象，那么就有多个弱引用，所以我们需要给每个弱引用设置一个Key方便查找。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyWeakCanary</span>&lt;<span class="type">T</span>&gt; : <span class="type">WeakReference</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> key: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(referent: T, key: String) : <span class="keyword">super</span>(referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(referent: T, queue: ReferenceQueue&lt;<span class="keyword">in</span> T?&gt;, key: String) : <span class="keyword">super</span>(referent, queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写toString，方便观察值</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;KeyWeakReference(key=<span class="variable">$key</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弱引用简单封装了一下，那么还差个观察者，你要监测肯定需要一个观察者嘛。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监测列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> watchedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保留列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retainedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(obj: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//生成UUID Key，便于从列表取出相应的引用</span></span><br><span class="line">        <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> reference = KeyWeakReference(obj, queue, key)<span class="comment">//弱引用引用对象，引用对象与弱引用关联</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//登记</span></span><br><span class="line">        watchedReferences[key] = reference</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启子线程监测对象是否泄漏</span></span><br><span class="line">        <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line">        executor.execute &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            moveToRetain(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将符合泄漏的对象转移到留存区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetain</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ref: KeyWeakReference&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            queue.poll()?.also &#123; ref = it <span class="keyword">as</span> KeyWeakReference&lt;Any?&gt; &#125;</span><br><span class="line">            <span class="comment">//回收成功，没有发生内存泄漏的情况</span></span><br><span class="line">            ref?.key.let &#123;</span><br><span class="line">                watchedReferences.remove(it)</span><br><span class="line">                retainedReferences.remove(it)</span><br><span class="line">            &#125;</span><br><span class="line">            ref = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有回收成功，那这个对象那这个对象肯定还在观察区，将其转移到留存区</span></span><br><span class="line">        watchedReferences.remove(key)?.also &#123;</span><br><span class="line">            retainedReferences[key] = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//供外部取出内存泄漏对象的值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getReferences</span><span class="params">()</span></span>:MutableMap&lt;String,KeyWeakReference&lt;Any?&gt;&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> retainedReferences</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们创建了观察列表和留存列表，这就好比现在的疫情，从外省回来会被隔离（观察列表），如果观察你有新冠就将你运往隔离医院治疗（留存列表）。然后就是观察方法，传入观察对象，之后用java自带的UUID工具生成唯一的UUID给弱引用方便根据key查询弱引用，之后是弱引用引用对象，引用队列与弱引用关联，再把该弱引用记录进观察区，之后用线程池开启子线程进行内存监测。在内存检测方法里先从引用队列拿出一个引用对象，若为空，则表明它没有被回收，观察区也就不会将它移除，之后下面remove它的时候就不为null，它就会被转移进留存区。之后外界通过这个留存区取出内存泄漏的对象进行分析通知一系列操作。</p>
<p>然后在主线程测试一下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> obj:Any? = Object()</span><br><span class="line">    <span class="keyword">val</span> watcher = Watcher()</span><br><span class="line">    watcher.watch(obj)</span><br><span class="line"></span><br><span class="line">    obj = <span class="literal">null</span><span class="comment">//改变obj为null的状态来模拟内存泄漏与否</span></span><br><span class="line">    System.gc()</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    watcher.getReferences().forEach &#123; (key, reference) -&gt;</span><br><span class="line">        println(<span class="string">&quot;key:<span class="variable">$key</span>,<span class="variable">$reference</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将obj置为null此时调用GC obj将被回收，无输出。再将这行注释，模拟obj被引用的情况，此时GC无法将其回收，留存区有值，打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key:ca1485f4-929a-45f2-8977-483f05245f0d,KeyWeakReference(key=ca1485f4-929a-45f2-8977-483f05245f0d)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>证明我们这个简易版的（可以说很丑陋）内存泄漏检测工具是成功的。但实际上，LeakCanary的做法比我们这个更加细节，我们这个只能检测单个对象，而LeakCanary对Activity、Fragment、Service、RootView、Viewmodel都进行了生命周期监听，并且对泄漏对象的通报和分析都是在内部进行的。</p>
<p>我们现在来看看它的源码，在看他的源码之前我们先问几个问题</p>
<ol>
<li>在LeakCanary1.0版本之前是需要在Application里面初始化的，2.0版本之后直接添加依赖就可以用了，那之后的版本它在哪初始化的捏？</li>
<li>LeakCanary是怎么对Activity、fragment（view和fragment本身）、Service、RootView、Viewmodel进行生命周期的监听的捏？</li>
<li>检测到泄漏之后是怎么处理的呢？</li>
</ol>
<p>相信带着这几个问题去看他的源码会更好理解。</p>
<p>首先看LeakCanary是在哪里初始化的？其实，在1.0版本之前，LeakCanary都是在自定义的Application里面初始化的，在2.0之后只需添加一行依赖即可。之前也提到过ContentProvider得onCreate()是在Application.onCreate前面执行的，不难想到LeakCanary就是这么许哦的。</p>
<h5 id="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"><a href="#为什么ContentProvider的onCreate方法是在Application前面执行的呢？" class="headerlink" title="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"></a>为什么ContentProvider的onCreate方法是在Application前面执行的呢？</h5><p>这就要看看ActivityThread的源码了，要知道他们两个的onCreate先后顺序肯定要先理清Application的创建流程，因为Application是伴随整个app的生命周期的。看到ActivityThread的main函数，我们看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">		...</span><br><span class="line">        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">        thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">    	...</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Application和整个app的生命周期那肯定也伴随着主线程的启动与消亡，那肯定跟thread.attach有关，跟进看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">	sCurrentActivityThread = <span class="built_in">this</span>;</span><br><span class="line">	mSystemThread = system;</span><br><span class="line">	<span class="keyword">if</span> (!system) &#123;</span><br><span class="line">	    android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">	                                            UserHandle.myUserId());</span><br><span class="line">	    RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">	    <span class="comment">// mgr为ActivityManagerService实例</span></span><br><span class="line">	    <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	    	<span class="comment">// mAppThread为ApplicationThread实例,ApplicationThread是ActivityThread与AMS交互的桥梁</span></span><br><span class="line">	        mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">	        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">	    &#125;</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里获取AMS之后调用了attachApplication(mAppThread, startSeq)，跟进看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread thread, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Invalid application interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">callingPid</span> <span class="operator">=</span> Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingUid</span> <span class="operator">=</span> Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);<span class="comment">//这里又调用了AMS的内部方法，跟踪下去</span></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread, <span class="type">int</span> pid, <span class="type">int</span> callingUid, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">	   	<span class="comment">//判断是否是isolato进程，这个可通过设置service的android:isolatedProcess开启，设置该服务是否</span></span><br><span class="line">       	<span class="comment">//作为一个单独的进程运行，如果设置为true，此服务将在与系统其余部分隔离的特殊进程下运行，并且没有自己的权限，与它唯一		//的通信是通过服务API（绑定和启动),这个我们一般不会去这么做，直接略过</span></span><br><span class="line">	   thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">	   thread.bindApplication(processName, appInfo, providerList,<span class="comment">//跟踪到者发现调用了bindApplication</span></span><br><span class="line">	           instr2.mClass,</span><br><span class="line">	           profilerInfo, instr2.mArguments,</span><br><span class="line">	           instr2.mWatcher,</span><br><span class="line">	           instr2.mUiAutomationConnection, testMode,</span><br><span class="line">	           mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">	           isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">	           <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">	           app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">	           mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">	           buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">	           app.mDisabledCompatChanges);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   thread.bindApplication(processName, appInfo, providerList, <span class="literal">null</span>, profilerInfo,<span class="comment">//同样是这个方法的重载</span></span><br><span class="line">	           <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, testMode,</span><br><span class="line">	           mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">	           isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">	           <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">	           app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">	           mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">	           buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">	           app.mDisabledCompatChanges);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们继续点进thread.bindApplication看看它做了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span><br><span class="line"><span class="params">                ProviderInfoList providerList, ComponentName instrumentationName,</span></span><br><span class="line"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span><br><span class="line"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span><br><span class="line"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="type">int</span> debugMode,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> enableBinderTracking, <span class="type">boolean</span> trackAllocation,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> isRestrictedBackupMode, <span class="type">boolean</span> persistent, Configuration config,</span></span><br><span class="line"><span class="params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span><br><span class="line"><span class="params">                String buildSerial, AutofillOptions autofillOptions,</span></span><br><span class="line"><span class="params">                ContentCaptureOptions contentCaptureOptions, <span class="type">long</span>[] disabledCompatChanges,</span></span><br><span class="line"><span class="params">                SharedMemory serializedSystemFontMap)</span> &#123;</span><br><span class="line">			...</span><br><span class="line">           </span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);<span class="comment">//看这里</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>找来找去发现没有关于application的函数了，但是我们可以看到最后一行调用了sendMessage函数，并传了H.BIND_APPLICATION这个参数，那么我们点进去看看它是否跟bindApplication有关捏？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what, Object obj)</span> &#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what, Object obj, <span class="type">int</span> arg1, <span class="type">int</span> arg2, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">            Slog.v(TAG,</span><br><span class="line">                    <span class="string">&quot;SCHEDULE &quot;</span> + what + <span class="string">&quot; &quot;</span> + mH.codeToString(what) + <span class="string">&quot;: &quot;</span> + arg1 + <span class="string">&quot; / &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        msg.obj = obj;</span><br><span class="line">        msg.arg1 = arg1;</span><br><span class="line">        msg.arg2 = arg2;</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);<span class="comment">//发现这里发送了一个消息，传入的message携带的信息就是上面传入的H.BIND_APPLICATION</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这里调用了mH的sendMessage方法，mH会不会就是Handler?跟进mH看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br></pre></td></tr></table></figure>

<p>是H的对象，那H是否继承了Handler方法呢？点进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//通过Handler进入</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:<span class="comment">//根据我们传入的值进入这个分支</span></span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);<span class="comment">//在这里处理了Application的绑定</span></span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                ...</span><br><span class="line">                &#125;</span><br><span class="line">          ...</span><br><span class="line">         &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现果然是这样。并且实现了handle Message方法，那上面我们sendMessage最终通过Handler肯定执行handle Message方法，并且根据我们传入的H.BIND_APPLICATION进入了第一个分支，继续跟进handleBindApplication(data);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">          <span class="comment">//创建appContext</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, data.info);<span class="comment">//6660</span></span><br><span class="line">	    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在这创建了application</span></span><br><span class="line">            app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);<span class="comment">//6723</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<span class="comment">//6747</span></span><br><span class="line">                    installContentProviders(app, data.providers);<span class="comment">//可以看到这里应该就是启动ContentProvider的地方</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//看函数名不难发现这儿就是回调Applicatio.onCreate的地方  6762</span></span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                      <span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class="line">                      + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，先创建appContext和application，具体创建过程这里就不细细分析了，这里我们只是简单看看ContentProvier和Application的onCreate执行顺序。然后是installContentProviders，那这里肯定就和ContentProvider有关了，等会再分析，先看下面的mInstrumentation.callApplicationOnCreate(app)，我们跟进发现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callApplicationOnCreate</span><span class="params">(Application app)</span> &#123;</span><br><span class="line">        app.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用了application的onCreate方法，那我们再跟进前面的installContentProviders看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installContentProviders</span><span class="params">(</span></span><br><span class="line"><span class="params">            Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line">                buf.append(<span class="string">&quot;Pub &quot;</span>);</span><br><span class="line">                buf.append(cpi.authority);</span><br><span class="line">                buf.append(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">                buf.append(cpi.name);</span><br><span class="line">                Log.i(TAG, buf.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ContentProviderHolder</span> <span class="variable">cph</span> <span class="operator">=</span> installProvider(context, <span class="literal">null</span>, cpi,<span class="comment">//在这里进行了ContentProvider的一些创建</span></span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*noisy*/</span>, <span class="literal">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="literal">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (cph != <span class="literal">null</span>) &#123;</span><br><span class="line">                cph.noReleaseNeeded = <span class="literal">true</span>;</span><br><span class="line">                results.add(cph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进installProvider</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ContentProviderHolder <span class="title function_">installProvider</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">            ContentProviderHolder holder, ProviderInfo info,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> noisy, <span class="type">boolean</span> noReleaseNeeded, <span class="type">boolean</span> stable)</span> &#123;</span><br><span class="line">        <span class="type">ContentProvider</span> <span class="variable">localProvider</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        IContentProvider provider;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span> || holder.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> c.getClassLoader();</span><br><span class="line">                <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> peekPackageInfo(ai.packageName, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// System startup case.</span></span><br><span class="line">                    packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">                &#125;</span><br><span class="line">                localProvider = packageInfo.getAppFactory()</span><br><span class="line">                        .instantiateProvider(cl, info.name);</span><br><span class="line">                provider = localProvider.getIContentProvider();</span><br><span class="line">                <span class="keyword">if</span> (provider == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">&quot;Failed to instantiate class &quot;</span> +</span><br><span class="line">                          info.name + <span class="string">&quot; from sourceDir &quot;</span> +</span><br><span class="line">                          info.applicationInfo.sourceDir);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                    TAG, <span class="string">&quot;Instantiating local provider &quot;</span> + info.name);</span><br><span class="line">                <span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">                localProvider.attachInfo(c, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(<span class="literal">null</span>, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                            <span class="string">&quot;Unable to get provider &quot;</span> + info.name</span><br><span class="line">                            + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            provider = holder.provider;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">&quot;Installing external provider &quot;</span> + info.authority + <span class="string">&quot;: &quot;</span></span><br><span class="line">                    + info.name);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">return</span> retHolder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看到这句英文注释Need to create the correct context for this provider.需要为此提供者创建正确的上下文，那肯定就是他了，跟进localProvider.attachInfo(c, info)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="type">boolean</span> testing)</span> &#123;</span><br><span class="line">        mNoPerms = testing;</span><br><span class="line">        mCallingAttributionSource = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Only allow it to be set once, so after the content service gives</span></span><br><span class="line"><span class="comment">         * this to us clients can&#x27;t change it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            mContext = context;</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; mTransport != <span class="literal">null</span>) &#123;</span><br><span class="line">                mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                        Context.APP_OPS_SERVICE);</span><br><span class="line">            &#125;</span><br><span class="line">            mMyUid = Process.myUid();</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                setReadPermission(info.readPermission);</span><br><span class="line">                setWritePermission(info.writePermission);</span><br><span class="line">                setPathPermissions(info.pathPermissions);</span><br><span class="line">                mExported = info.exported;</span><br><span class="line">                mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="number">0</span>;</span><br><span class="line">                setAuthorities(info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">                setTransportLoggingEnabled(Log.isLoggable(getClass().getSimpleName(),</span><br><span class="line">                        Log.VERBOSE));</span><br><span class="line">            &#125;</span><br><span class="line">            ContentProvider.<span class="built_in">this</span>.onCreate();<span class="comment">//在这里回调了contentProvider的onCreate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终我们在这发现回调了onCreate。这里我们只是根据函数名+源码注释+猜测去验证了他们两个的执行顺序，更多细枝末节就没看（其实是看不懂），如果大家想真正搞明白ContentProvider和Application完整的创建流程，大家可以去研究一下Android的源码。</p>
<p>知道了这个之后我们就能理解LeakCanary的做法了，翻其源码也确实是这样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.squareup.leakcanary.objectwatcher&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那可能有人会疑问，为啥它那定义的清单文件我这也能用捏？其实这是Gradle的功劳，一个app是只能有一个清单文件的，在构建应用的时候，Gradle会合并所有的清单文件，所有文件优先级如下</p>
<ol>
<li>Product flavors 和构建类型所指定的清单文件。</li>
<li>应用程序的主清单文件。</li>
<li>类库的清单文件。</li>
</ol>
<p>具体的合并逻辑就涉及Gradle的东西了，这里就不说了。那好，那我们的第一个问题就解决了。</p>
<h5 id="LeakCanary是如何监听的"><a href="#LeakCanary是如何监听的" class="headerlink" title="LeakCanary是如何监听的"></a>LeakCanary是如何监听的</h5><p>现在我们看MainProcessAppWatcherInstaller</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcessAppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化了AppWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,<span class="comment">//对检测对象延迟5秒检测</span></span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="comment">//默认的一些观察器</span></span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()<span class="comment">//日志的初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对每一个检测器进行初始化</span></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Only install after we&#x27;re fully done with init.</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不看核心组件，它比较复杂，我们先看看默认的检测器是如何对Activity、Fragment、Viewmodel等的监听的，先看appDefaultWatchers(application)这个生成默认检测器的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher),<span class="comment">//对Activity的检测器</span></span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),<span class="comment">//对Fragment和Viewmodel的检测器</span></span><br><span class="line">    RootViewWatcher(reachabilityWatcher),<span class="comment">//对RootView的检测器</span></span><br><span class="line">    ServiceWatcher(reachabilityWatcher)<span class="comment">//对Service的检测器</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建各个检测器，传入objectWatcher和application，这四个监听器我们一个一个来看</p>
<h6 id="ActivityWatcher"><a href="#ActivityWatcher" class="headerlink" title="ActivityWatcher"></a><strong>ActivityWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<span class="comment">//注册Activity的生命周期监听</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过Activity生命周期对的Application.ActivityLifecycleCallbacks回调来达到监听Activity的结束。其实就是在Activity快onDestroy的时候调用了Application.ActivityLifecycleCallbacks的onActivityDestroyed。然后在onActivityDestroyed里面调用了reachabilityWatcher的expectWeaklyReachable，reachabilityWatcher就是刚刚创建的时候传进来的，我们返回去看看reachabilityWatcher对expectWeaklyReachable的实现。跟踪发现，传进来的是objectWatcher，点击跟踪</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The [ObjectWatcher] used by AppWatcher to detect retained objects.</span></span><br><span class="line"><span class="comment"> * Only set when [isInstalled] is true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">  clock = &#123; SystemClock.uptimeMillis() &#125;,</span><br><span class="line">  checkRetainedExecutor = &#123;</span><br><span class="line">    check(isInstalled) &#123;</span><br><span class="line">      <span class="string">&quot;AppWatcher not installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mainHandler.postDelayed(it, retainedDelayMillis)</span><br><span class="line">  &#125;,</span><br><span class="line">  isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们这里看到传入时间、一个Executor任务执行器，该任务执行器将传入的任务交给主线程的Handler延时处理，延时retainedDelayMillis就是刚刚初始化AppWatcher默认设置的5秒，看看ObjectWatcher对expectWeaklyReachable的实现，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()<span class="comment">//先清空观察区里已经被回收的对象</span></span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">    .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">      (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">      (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">      <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实之前仿写的LeakCanary有点故意模仿LeakCanary的意思，这不LeakCanary里面也有观察区和留存区，只不过我们为了好获取泄漏对象而用了一个列表存储，这里没有列表存储，而是直接回调出去通知。每次观测之前先清除观察区已经被回收的对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;<span class="comment">//不为空说明已经被回收</span></span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就和我们刚仿写的差不多，生成一个唯一的UUID，将弱引用引用对象，再登记，只不过这里它记录了时间。最后执行moveToRetained(key)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">      <span class="comment">//责任链模式</span></span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候如果还有对象存在观察区，说明已经是可能内存泄漏的对象，然后记录此时的时间，再回调监听，onObjectRetainedListeners在哪设置的呢，在刚刚的核心组件里面，等会分析。</p>
<p>至此我们分析完LeakCanary是如何监听Activity生命周期和检测是否泄露的。接下来看Fragment和Viewmodel</p>
<h6 id="FragmentAndViewModelWatcher"><a href="#FragmentAndViewModelWatcher" class="headerlink" title="FragmentAndViewModelWatcher"></a><strong>FragmentAndViewModelWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentAndViewModelWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentDestroyWatchers: List&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt; = run &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">      <span class="comment">//版本的适配</span></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">        AndroidOFragmentDestroyWatcher(reachabilityWatcher)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="comment">//对应androidx版本</span></span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="comment">//对应之前的老版本</span></span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line">    fragmentDestroyWatchers</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        activity: <span class="type">Activity</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span> &#123;</span><br><span class="line">          <span class="comment">//不同版本的fragmentDestroyWatcher进行监听注册</span></span><br><span class="line">        <span class="keyword">for</span> (watcher <span class="keyword">in</span> fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里给activity注册一个监听，然后遍历里面的fragmentwatcher调用incoke设置fragment的监听，其他版本的fragmentDestroyWatcher就不看了和ActivityWatcher差不多，我们看看AndroidXFragmentDestroyWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AndroidXFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">//监听viewmodel相关</span></span><br><span class="line">      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//对view泄漏的回调</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          view, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">          <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//和activitywatcher一样，不多说</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        fragment, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">val</span> supportFragmentManager = activity.supportFragmentManager</span><br><span class="line">        <span class="comment">//通过fragmentmanager监听fragment生命周期</span></span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">//初始化viewmodel</span></span><br><span class="line">      ViewModelClearedWatcher.install(activity, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实跟activity的差不多，不过是通过activity设置fragment的监听，这里可能有个高阶函数大家没见过，也是invoke的一种用法吧，可以了解一下。好，我们现在来看看对viewmodel的监听过程：</p>
<h6 id="ViewModelClearedWatcher"><a href="#ViewModelClearedWatcher" class="headerlink" title="ViewModelClearedWatcher"></a><strong>ViewModelClearedWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ViewModelClearedWatcher</span>(</span><br><span class="line">  storeOwner: ViewModelStoreOwner,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span></span><br><span class="line">  <span class="comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span></span><br><span class="line">  <span class="comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//通过反射获取viewmodelstore</span></span><br><span class="line">    <span class="keyword">val</span> mMapField = ViewModelStore::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">    mMapField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    mMapField[storeOwner.viewModelStore] <span class="keyword">as</span> Map&lt;String, ViewModel&gt;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Exception) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//当此viewmodel销毁时，意味着viewmodelstore里其他的viewmodel也将被销毁</span></span><br><span class="line">    viewModelMap?.values?.forEach &#123; viewModel -&gt;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        viewModel, <span class="string">&quot;<span class="subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      storeOwner: <span class="type">ViewModelStoreOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      reachabilityWatcher: <span class="type">ReachabilityWatcher</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">//这就很巧妙，通过将自己插入viewmodelstore来监控通一宿主的viewmodel</span></span><br><span class="line">      <span class="keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="keyword">object</span> : Factory &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T =</span><br><span class="line">          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="keyword">as</span> T</span><br><span class="line">      &#125;)</span><br><span class="line">      provider.<span class="keyword">get</span>(ViewModelClearedWatcher::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现它居然是个viewmodel，而且它还把它自己插入了宿主的viewmodelstore。把自己当作间谍插入敌军来达到监听的目的。具体viewmodestore是如何管理同一宿主的多个viewmodel的这里就不解释了，大家可以看看viewmodel的源码（其实是我不会）。</p>
<p>好，再来看看rootView</p>
<h6 id="RootViewWatcher"><a href="#RootViewWatcher" class="headerlink" title="RootViewWatcher"></a><strong>RootViewWatcher</strong></h6><p>有人可能会问rootview也会发生内存泄露吗？会的，只是不常见，比如，此时我自定义了一个Toast弹窗，弹的是xml的布局，然后Toast被我声明成了静态方法，这时候如果我一弹窗，消失，之后LeakCanary就提醒你了，内存泄漏。自定义的toast代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ToastUtil &#123;</span><br><span class="line">    <span class="keyword">var</span> mToast: Toast? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inflater = LayoutInflater.from(App.appContext)</span><br><span class="line">        <span class="keyword">val</span> toastView: View = inflater.inflate(R.layout.toast, <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (mToast == <span class="literal">null</span>) &#123;</span><br><span class="line">            mToast = Toast(App.appContext)</span><br><span class="line">        &#125;</span><br><span class="line">        mToast!!.setGravity(Gravity.TOP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        mToast!!.duration = Toast.LENGTH_SHORT</span><br><span class="line">        mToast!!.view = toastView</span><br><span class="line">        mToast!!.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的自定义Toast工具是内存泄漏的，为什么捏，因为object单例内部的变量是静态的，所以mToast是静态的，而它又引用了toastView，而toastView是rootView绘制的xml布局（原理见view的绘制），因此一系列下来导致弹完吐司之后，rootView绘制完了而还在被mToastView引用导致内存泄漏。事实上，你会发现，mToast.view已经被废弃，谷歌官方也不建议我们自定义toast，因为这样确实容易造成内存泄漏，更推荐我们自定义snackBar。</p>
<p>我们再看RootViewWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RootViewWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (trackDetached) &#123;</span><br><span class="line">      rootView.addOnAttachStateChangeListener(<span class="keyword">object</span> : OnAttachStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> watchDetachedView = Runnable &#123;</span><br><span class="line">          reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">            rootView, <span class="string">&quot;<span class="subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.removeCallbacks(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.post(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Curtains.onRootViewsChangedListeners += listener</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Curtains.onRootViewsChangedListeners -= listener</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也不过是对rootview注册监听，具体的原理不说了，跟Activity的方式差不多。</p>
<h6 id="ServiceWatcher"><a href="#ServiceWatcher" class="headerlink" title="ServiceWatcher"></a><strong>ServiceWatcher</strong></h6><p>我们再看看ServiceWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceWatcher</span>(<span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    checkMainThread()</span><br><span class="line">    check(uninstallActivityThreadHandlerCallback == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(uninstallActivityManager == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// hook ActivityThread 里面的 mH 的 mCallback</span></span><br><span class="line">      swapActivityThreadHandlerCallback &#123; mCallback -&gt;</span><br><span class="line">        uninstallActivityThreadHandlerCallback = &#123;</span><br><span class="line">          swapActivityThreadHandlerCallback &#123;</span><br><span class="line">            mCallback</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代理对象，替换原来的Callback</span></span><br><span class="line">        Handler.Callback &#123; msg -&gt;</span><br><span class="line">          <span class="comment">// https://github.com/square/leakcanary/issues/2114</span></span><br><span class="line">          <span class="comment">// On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord</span></span><br><span class="line">          <span class="comment">// instead of an IBinder. This crashes on a ClassCastException. Adding a type check</span></span><br><span class="line">          <span class="comment">// here to prevent the crash.</span></span><br><span class="line">          <span class="keyword">if</span> (msg.obj !<span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 拦截 STOP_SERVICE 消息，这里主要是预处理获取到即将要被 destroy 的 service 对象</span></span><br><span class="line">          <span class="keyword">if</span> (msg.what == STOP_SERVICE) &#123;</span><br><span class="line">            <span class="keyword">val</span> key = msg.obj <span class="keyword">as</span> IBinder</span><br><span class="line">            activityThreadServices[key]?.let &#123;</span><br><span class="line">              onServicePreDestroy(key, it)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行原有逻辑</span></span><br><span class="line">          mCallback?.handleMessage(msg) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// hook 替换原来的ActivityManageService 对象</span></span><br><span class="line">      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;</span><br><span class="line">        uninstallActivityManager = &#123;</span><br><span class="line">          swapActivityManager &#123; _, _ -&gt;</span><br><span class="line">            activityManagerInstance</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态代理对象</span></span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)</span><br><span class="line">        ) &#123; _, method, args -&gt;</span><br><span class="line">          <span class="comment">// hook 到 service 真正 destroy 的时机，这里没法获取到servcie对象，所以要前面的预操作：onServicePreDestroy</span></span><br><span class="line">          <span class="keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;</span><br><span class="line">            <span class="keyword">val</span> token = args!![<span class="number">0</span>] <span class="keyword">as</span> IBinder</span><br><span class="line">            <span class="keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">              <span class="comment">// 回调监测</span></span><br><span class="line">              onServiceDestroyed(token)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行原有逻辑</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">              method.invoke(activityManagerInstance)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              method.invoke(activityManagerInstance, *args)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (invocationException: InvocationTargetException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> invocationException.targetException</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      SharkLog.d(ignored) &#123; <span class="string">&quot;Could not watch destroyed services&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDestroyed</span><span class="params">(token: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 token 匹配到预处理时获取到的 service 对象</span></span><br><span class="line">    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;</span><br><span class="line">      serviceWeakReference.<span class="keyword">get</span>()?.let &#123; service -&gt;</span><br><span class="line">      <span class="comment">// 将 service 对象加入到 watchedObjects 里面，之后就和activity一样了</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          service, <span class="string">&quot;<span class="subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对Service的监控可能就比较奇怪了，因为Service没有对外公开Service生命周期的监听方式，所以只能hook ，所以这里面就涉及了Service的底层原理和hook技术，要真正理解的话得知道Service的底层原理的hook，这里简单说一下：启动Service的时候，在ActivityThread里面都会有记录，启动的Service都会存进mServices里面，onDestory的时候，AMS会用Handler发给ActivityThread告诉某某Service要销毁了，此时ActivityThread就会通过IActivityManger回调Service的onDestory方法，IActivityManger存储了四大组件的周期函数，所以通过它来调用Service的周期函数。因此原理也是这样，通过hook AMS发过来Service onDestory的信息记录Service，进而在IActivityManger回调Service onDestory的时候找到这个Service并监测。</p>
<h5 id="监听之后是怎么处理的呢？"><a href="#监听之后是怎么处理的呢？" class="headerlink" title="监听之后是怎么处理的呢？"></a>监听之后是怎么处理的呢？</h5><p>现在几个监测的类讲完了，那么第二个问题也解决了，接下来我们看看刚刚还没呢分析的核心组件</p>
<h6 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a><strong>InternalLeakCanary</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,<span class="comment">//对检测对象延迟5秒检测</span></span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="comment">//默认的一些观察器</span></span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()<span class="comment">//日志的初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对每一个检测器进行初始化</span></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Only install after we&#x27;re fully done with init.</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看LeakCanaryDelegate.loadLeakCanary(application)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> LeakCanaryDelegate &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> loadLeakCanary <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过反射实例化InternalLeakCanary，并调用了invoke方法</span></span><br><span class="line">      <span class="keyword">val</span> leakCanaryListener = Class.forName(<span class="string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)</span><br><span class="line">      leakCanaryListener.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>)</span><br><span class="line">        .<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span> (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      NoLeakCanary</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">object</span> NoLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要通过反射实例化咧？因为InternalLeakCanary在另一个模块，而他又是internal，所以只能通过反射了。那我们看看InternalLeakCanary复写的invoke方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">  _application = application<span class="comment">//传入application</span></span><br><span class="line"></span><br><span class="line">  checkRunningInDebuggableBuild()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哦~原来是在这设置的OnObjectRetainedListener</span></span><br><span class="line">  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建gc触发器，这样的GC更容易触发垃圾回收</span></span><br><span class="line">  <span class="keyword">val</span> gcTrigger = GcTrigger.Default</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> configProvider = &#123; LeakCanary.config &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">  handlerThread.start()</span><br><span class="line">  <span class="keyword">val</span> backgroundHandler = Handler(handlerThread.looper)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分析heap dump的启动器,heap dump堆转储，上面提过</span></span><br><span class="line">  heapDumpTrigger = HeapDumpTrigger(</span><br><span class="line">    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,</span><br><span class="line">    configProvider</span><br><span class="line">  )</span><br><span class="line">    <span class="comment">// 应用前后台监听，前后台监听逻辑差异化处理</span></span><br><span class="line">  application.registerVisibilityListener &#123; applicationVisible -&gt;</span><br><span class="line">    <span class="keyword">this</span>.applicationVisible = applicationVisible</span><br><span class="line">    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)</span><br><span class="line">  &#125;</span><br><span class="line">  registerResumedActivityListener(application)</span><br><span class="line">    <span class="comment">//桌面添加图标</span></span><br><span class="line">  addDynamicShortcut(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We post so that the log happens after Application.onCreate()</span></span><br><span class="line">  mainHandler.post &#123;</span><br><span class="line">    <span class="comment">// https://github.com/square/leakcanary/issues/1981</span></span><br><span class="line">    <span class="comment">// We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref</span></span><br><span class="line">    <span class="comment">// which blocks until loaded and that creates a StrictMode violation.</span></span><br><span class="line">    backgroundHandler.post &#123;</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;</span><br><span class="line">          <span class="keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)</span><br><span class="line">          <span class="keyword">is</span> Nope -&gt; application.getString(</span><br><span class="line">            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来我们之前在moveToRetain里回调的方法在这注册的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">      <span class="comment">//责任链模式</span></span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们看看InternalLeakCanary对onObjectRetained()的实现，发现其调用的是scheduleRetainedObjectCheck()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">    heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是scheduleRetainedObjectCheck()</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">  <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;<span class="comment">//通过记录时间戳来避免重复检测</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<span class="comment">//记录时间</span></span><br><span class="line">  backgroundHandler.postDelayed(&#123;</span><br><span class="line">    checkScheduledAt = <span class="number">0</span></span><br><span class="line">    checkRetainedObjects()<span class="comment">//检测留存的对象</span></span><br><span class="line">  &#125;, delayMillis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过记录时间避免重复检测，然后向子线程post了一Runnable，瞅瞅checkRetainedObjects</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//是否能够heap dump</span></span><br><span class="line">  <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> Nope) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> NotifyingNope) &#123;<span class="comment">//发送一个通知，用户点击后通过</span></span><br><span class="line">      <span class="comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span></span><br><span class="line">        <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          gcTrigger.runGc()<span class="comment">//分析前再确保一次是否真的泄漏，调用一次GC</span></span><br><span class="line">          retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nopeReason = iCanHasHeap.reason()</span><br><span class="line">        <span class="comment">//主要是判断是否达到阈值，前台的时候是&gt;=5个会触发，后台是&gt;=1个就会触发</span></span><br><span class="line">        <span class="keyword">val</span> wouldDump = !checkRetainedCount(</span><br><span class="line">          retainedReferenceCount, config.retainedVisibleThreshold, nopeReason</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wouldDump) &#123;</span><br><span class="line">          <span class="keyword">val</span> uppercaseReason = nopeReason[<span class="number">0</span>].toUpperCase() + nopeReason.substring(<span class="number">1</span>)</span><br><span class="line">          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))</span><br><span class="line">          showRetainedCountNotification(<span class="comment">//通知</span></span><br><span class="line">            objectCount = retainedReferenceCount,</span><br><span class="line">            contentText = uppercaseReason</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">        application.getString(</span><br><span class="line">          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果不能堆转储，进行了一些列操作，然后再尝试分析</span></span><br><span class="line">  <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    gcTrigger.runGc()</span><br><span class="line">    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">  <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">    onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">    )</span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dismissRetainedCountNotification()</span><br><span class="line">  <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">&quot;visible&quot;</span> <span class="keyword">else</span> <span class="string">&quot;not visible&quot;</span></span><br><span class="line">    <span class="comment">//分析hprof文件</span></span><br><span class="line">  dumpHeap(</span><br><span class="line">    retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">    retry = <span class="literal">true</span>,</span><br><span class="line">    reason = <span class="string">&quot;<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>&quot;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看能不能堆转储，如果可以，就发送通知，如果不能，做了一系列操作，再尝试分析，其实这跟MAT有点类似，MAT也是不能直接就解析hprof文件，最后你会发现，最终调用的都是dumpHeap()方法，我们看dumpHeap方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">HeapDumpTrigger.kt</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retry: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reason: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> directoryProvider =</span><br><span class="line">    InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)</span><br><span class="line">  <span class="keyword">val</span> heapDumpFile = directoryProvider.newHeapDumpFile()<span class="comment">//创建导出的文件夹</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> durationMillis: <span class="built_in">Long</span></span><br><span class="line">  <span class="keyword">if</span> (currentEventUniqueId == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentEventUniqueId = UUID.randomUUID().toString()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(DumpingHeap(currentEventUniqueId!!))</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Could not create heap dump file&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    saveResourceIdNamesToMemory()</span><br><span class="line">    <span class="keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis</span><br><span class="line">    durationMillis = measureDurationMillis &#123;</span><br><span class="line">      configProvider().heapDumper.dumpHeap(heapDumpFile)<span class="comment">//主要方法，用系统导出堆转储文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile.length() == <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Dumped heap file is 0 byte length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">    lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">    currentEventUniqueId = UUID.randomUUID().toString()</span><br><span class="line">      <span class="comment">//将导出情况回调出去，根据失败和成功给用户弹通知（一般是成功）</span></span><br><span class="line">    InternalLeakCanary.sendEvent(HeapDump(currentEventUniqueId!!, heapDumpFile, durationMillis, reason))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(HeapDumpFailed(currentEventUniqueId!!, throwable, retry))</span><br><span class="line">    <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">        delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(</span><br><span class="line">        R.string.leak_canary_notification_retained_dump_failed</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建了文件夹然后是保存时间，ID啊一些的操作，最主要的是configProvider().heapDumper.dumpHeap(heapDumpFile)，查找它的实现其实就是</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDebugHeapDumper : HeapDumper &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(heapDumpFile: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">    Debug.dumpHprofData(heapDumpFile.absolutePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用系统的Debug工具调出hprof文件。之后我们看导出成功回调做了什么事情</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> RemoteWorkManagerHeapAnalyzer : EventListener &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REMOTE_SERVICE_CLASS_NAME = <span class="string">&quot;leakcanary.internal.RemoteLeakCanaryWorkerService&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> remoteLeakCanaryServiceInClasspath <span class="keyword">by</span> lazy &#123;<span class="comment">//返回true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(REMOTE_SERVICE_CLASS_NAME)</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onEvent</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> HeapDump) &#123;</span><br><span class="line">      <span class="keyword">val</span> application = InternalLeakCanary.application</span><br><span class="line">      <span class="keyword">val</span> heapAnalysisRequest =<span class="comment">//构建一个workmanagerRequest，执行一次</span></span><br><span class="line">        OneTimeWorkRequest.Builder(RemoteHeapAnalyzerWorker::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">          <span class="keyword">val</span> dataBuilder = Data.Builder()</span><br><span class="line">            .putString(ARGUMENT_PACKAGE_NAME, application.packageName)</span><br><span class="line">            .putString(ARGUMENT_CLASS_NAME, REMOTE_SERVICE_CLASS_NAME)</span><br><span class="line">          setInputData(event.asWorkerInputData(dataBuilder))</span><br><span class="line">          with(WorkManagerHeapAnalyzer) &#123;<span class="comment">//任务内容在WorkManagerHeapAnalyzer里面</span></span><br><span class="line">            addExpeditedFlag()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;.build()</span><br><span class="line">      SharkLog.d &#123; <span class="string">&quot;Enqueuing heap analysis for <span class="subst">$&#123;event.file&#125;</span> on WorkManager remote worker&quot;</span> &#125;</span><br><span class="line">      <span class="keyword">val</span> workManager = WorkManager.getInstance(application)</span><br><span class="line">      workManager.enqueue(heapAnalysisRequest)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现根据回调的Event类型，回调到了这里，传进来的Event就是HeapDump，可以看到用WorkManager创建了一个异步任务WorkManagerHeapAnalyzer，然后执行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">RemoteHeapAnalyzerWorker</span>(appContext: Context, workerParams: WorkerParameters) :</span><br><span class="line">  RemoteListenableWorker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startRemoteWork</span><span class="params">()</span></span>: ListenableFuture&lt;Result&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> heapDump = inputData.asEvent&lt;HeapDump&gt;()</span><br><span class="line">    <span class="keyword">val</span> result = SettableFuture.create&lt;Result&gt;()</span><br><span class="line">    heapAnalyzerThreadHandler.post &#123;<span class="comment">//开启子线程执行分析任务</span></span><br><span class="line">      <span class="keyword">val</span> doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(heapDump, isCanceled = &#123;</span><br><span class="line">        result.isCancelled</span><br><span class="line">      &#125;) &#123; progressEvent -&gt;</span><br><span class="line">        <span class="keyword">if</span> (!result.isCancelled) &#123;<span class="comment">//将分析进度发送出去</span></span><br><span class="line">          InternalLeakCanary.sendEvent(progressEvent)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result.isCancelled) &#123;</span><br><span class="line">        SharkLog.d &#123; <span class="string">&quot;Remote heap analysis for <span class="subst">$&#123;heapDump.file&#125;</span> was canceled&quot;</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InternalLeakCanary.sendEvent(doneEvent)<span class="comment">//结束</span></span><br><span class="line">        result.<span class="keyword">set</span>(Result.success())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getForegroundInfoAsync</span><span class="params">()</span></span>: ListenableFuture&lt;ForegroundInfo&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext.heapAnalysisForegroundInfoAsync()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>heapAnalyzerThreadHandler实际上就是开启一个子线程然后执行runAnalysisBlocking，runAnalysisBlocking里面就是把文件交给了HeapAnalyzer去分析，HeapAnalyzer然后用Shark 分析hprof文件，具体Shark分析的原理就不说了，我也没怎么研究过，我觉得也没有用，会用就行了。Shark是LeakCanary的一个分析hprof文件的模块，因此我们也可以用shark开发一个用于线上的SDK，LeakCanary现在是不支持线上检测的。</p>
<p>用一张图总结一下它的原理其实就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppWatcher -&gt; objectWatcher:检测到泄漏</span><br><span class="line">objectWatcher -&gt; InternalLeakCanary:5秒后gc还是没回收</span><br><span class="line">InternalLeakCanary-&gt;HeapDumpTrigger:scheduleRetainedObjectCheck()</span><br><span class="line">HeapDumpTrigger-&gt;HeapAnalyzerThreadHandler:再强制GC一次，还是泄漏</span><br><span class="line">HeapAnalyzerThreadHandler-&gt;HeapAnalyzer:dumpHeap()</span><br><span class="line">HeapAnalyzer-&gt;Shark分析:</span><br><span class="line">Shark分析 -&gt; dataBase:发出通知，数据存进数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能还有人会疑另一个叫Leaks的app图标怎么生成的，其实它也不算是个app，它是你app的一部分，不信你把Leaks卸载了，你的app也会跟着卸载。实现这个很简单，用<activity-alias>标签就能实现。示例如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">.</span> <span class="attr">.</span> <span class="attr">.</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    . . .</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activity-alias</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.jason.demo.dynamicshortcut.ShortcutLauncherActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher_alias&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;ActivityAlias&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:targetActivity</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>android:targetActivity</code> 指定所必须的打开的目标 Activity，对应着一个在 <code>AndroidManifest.xml</code> 中申明的 <code>&lt;activity&gt;</code>。<code>android:name</code> 是别名的唯一名称，<strong>不引用实际类</strong>。<code>android:icon</code> 以及 <code>android:label</code> 指定一个新的图标和标签给用户。之后就能看见你的app生成了两个图标。</p>
<p>你如果不想LeakCanary自动初始化也是可以的。设置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">&quot;leak_canary_watcher_auto_install&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在你想要初始化的地方AppWatcher.manualInstall即可</p>
<p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。下面是一些常见的内存泄漏</p>
<ol>
<li><p>单例模式引发的内存泄漏</p>
<p>原因：单例模式里的静态实例持有对象的引用，导致对象无法被回收，常见为持有Activity的引用</p>
<p>优化：改为持有Application的引用，或者不持有使用的时候传递。</p>
</li>
<li><p>集合操作不当引发的内存泄漏</p>
<p>原因：集合只增不减</p>
<p>优化：有对应的删除或卸载操作</p>
</li>
<li><p>线程的操作不当引发的内存泄漏</p>
<p>原因：线程持有对象的引用在后台执行，与对象的生命周期不一致</p>
<p>优化：静态实例+弱引用(WeakReference)方式，使其生命周期一致</p>
</li>
<li><p>匿名内部类&#x2F;非静态内部类操作不当引发的内存泄漏</p>
<p>原因：内部类持有对象引用，导致无法释放，比如各种回调</p>
<p>优化：保持生命周期一致，改为静态实例+对象的弱引用方式（WeakReference）</p>
</li>
<li><p>常用的资源未关闭回收引发的内存泄漏</p>
<p>原因：BroadcastReceiver，File，Cursor，IO流，Bitmap等资源使用未关闭</p>
<p>优化：使用后有对应的关闭和卸载机制</p>
</li>
<li><p>Handler使用不当造成的内存泄漏</p>
<p>原因：Handler持有Activity的引用，其发送的Message中持有Handler的引用，当队列处理Message的时间过长会导致Handler无法被回收</p>
<p>优化：静态实例+弱引用(WeakReference)方式</p>
</li>
</ol>
<p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rq527.github.io">RQ527</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rq527.github.io/rq/e54d6d21.html">http://rq527.github.io/rq/e54d6d21.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rq527.github.io" target="_blank">RayQuester</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存泄漏</a></div><div class="post_share"><div class="social-share" data-image="/img/header.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/rq/9df138cf.html" title="Jetpack之一：Lifecycle"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Jetpack之一：Lifecycle</div></div></a></div><div class="next-post pull-right"><a href="/rq/784dd132.html" title="浅学Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浅学Android性能优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/rq/784dd132.html" title="浅学Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">浅学Android性能优化</div></div></a></div><div><a href="/rq/9df138cf.html" title="Jetpack之一：Lifecycle"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">Jetpack之一：Lifecycle</div></div></a></div><div><a href="/rq/e6b8b5a8.html" title="Jetpack之三：LiveData"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-27</div><div class="title">Jetpack之三：LiveData</div></div></a></div><div><a href="/rq/a365d41.html" title="Jetpack之二：Databinding和Navigation的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">Jetpack之二：Databinding和Navigation的使用</div></div></a></div><div><a href="/rq/260b5af1.html" title="Jetpack之四：ViewModel"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">Jetpack之四：ViewModel</div></div></a></div><div><a href="/rq/22f4c025.html" title="一名（深陷Android无法自拔的）大二狗的年中总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-18</div><div class="title">一名（深陷Android无法自拔的）大二狗的年中总结</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODQ1Mi8zNDkxNQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQ527</div><div class="author-info__description">=与其诅咒黑暗，不如点亮蜡烛=</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQ527"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQ527" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://juejin.cn/user/3228640351367704" target="_blank" title="稀土掘金"><i class="fas fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎您的到来，希望我的文章能对您有所帮助，若有疑问和文章建议欢迎评论~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ContentProvider%E7%9A%84onCreate%E6%96%B9%E6%B3%95%E6%98%AF%E5%9C%A8Application%E5%89%8D%E9%9D%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">为什么ContentProvider的onCreate方法是在Application前面执行的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LeakCanary%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E7%9A%84"><span class="toc-number">1.0.2.</span> <span class="toc-text">LeakCanary是如何监听的</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ActivityWatcher"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">ActivityWatcher</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FragmentAndViewModelWatcher"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">FragmentAndViewModelWatcher</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ViewModelClearedWatcher"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">ViewModelClearedWatcher</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RootViewWatcher"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">RootViewWatcher</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ServiceWatcher"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">ServiceWatcher</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E4%B9%8B%E5%90%8E%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">监听之后是怎么处理的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#InternalLeakCanary"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">InternalLeakCanary</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/22f4c025.html" title="一名（深陷Android无法自拔的）大二狗的年中总结">一名（深陷Android无法自拔的）大二狗的年中总结</a><time datetime="2023-07-18T12:52:31.632Z" title="发表于 2023-07-18 20:52:31">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/cf6c3d31.html" title="设计模式学习笔记">设计模式学习笔记</a><time datetime="2023-05-29T08:10:26.110Z" title="发表于 2023-05-29 16:10:26">2023-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/9f08fd9f.html" title="一文搞清楚Handler，再也不怕面试官">一文搞清楚Handler，再也不怕面试官</a><time datetime="2023-04-25T04:36:29.000Z" title="发表于 2023-04-25 12:36:29">2023-04-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/260b5af1.html" title="Jetpack之四：ViewModel">Jetpack之四：ViewModel</a><time datetime="2023-04-04T10:35:59.000Z" title="发表于 2023-04-04 18:35:59">2023-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/e6b8b5a8.html" title="Jetpack之三：LiveData">Jetpack之三：LiveData</a><time datetime="2023-03-27T07:56:39.000Z" title="发表于 2023-03-27 15:56:39">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By RQ527</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>