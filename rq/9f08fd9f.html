<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>一文搞清楚Handler，再也不怕面试官 | RayQuester</title><meta name="author" content="RQ527"><meta name="copyright" content="RQ527"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] Handler可以说是Android框架里面很精髓的一部分了，面试必问，用的也最多，这篇文章带你彻底搞清楚Handler。 Handler是什么？提到Handler大家一定不陌生，我们经常用它来切换线程，或者是说做一些延时任务等等。最常用的地方可能就是在网络请求中去切换到主线程中去操作UI。为什么要切换到主线程去操作UI呢？在这之前我们知道在Android里面所有的View都是线程不安">
<meta property="og:type" content="article">
<meta property="og:title" content="一文搞清楚Handler，再也不怕面试官">
<meta property="og:url" content="http://rq527.github.io/rq/9f08fd9f.html">
<meta property="og:site_name" content="RayQuester">
<meta property="og:description" content="[TOC] Handler可以说是Android框架里面很精髓的一部分了，面试必问，用的也最多，这篇文章带你彻底搞清楚Handler。 Handler是什么？提到Handler大家一定不陌生，我们经常用它来切换线程，或者是说做一些延时任务等等。最常用的地方可能就是在网络请求中去切换到主线程中去操作UI。为什么要切换到主线程去操作UI呢？在这之前我们知道在Android里面所有的View都是线程不安">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rq527.github.io/img/header.jpg">
<meta property="article:published_time" content="2023-04-25T04:36:29.000Z">
<meta property="article:modified_time" content="2023-05-14T06:00:16.183Z">
<meta property="article:author" content="RQ527">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Handler">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rq527.github.io/img/header.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://rq527.github.io/rq/9f08fd9f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '一文搞清楚Handler，再也不怕面试官',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-14 14:00:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 菜单</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RayQuester"><span class="site-name">RayQuester</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 菜单</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">一文搞清楚Handler，再也不怕面试官</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-25T04:36:29.000Z" title="发表于 2023-04-25 12:36:29">2023-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-14T06:00:16.183Z" title="更新于 2023-05-14 14:00:16">2023-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="一文搞清楚Handler，再也不怕面试官"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<p>Handler可以说是Android框架里面很精髓的一部分了，面试必问，用的也最多，这篇文章带你彻底搞清楚Handler。</p>
<h2 id="Handler是什么？"><a href="#Handler是什么？" class="headerlink" title="Handler是什么？"></a>Handler是什么？</h2><p>提到Handler大家一定不陌生，我们经常用它来切换线程，或者是说做一些延时任务等等。最常用的地方可能就是在网络请求中去切换到主线程中去操作UI。为什么要切换到主线程去操作UI呢？在这之前我们知道在Android里面所有的View都是线程不安全的，意思就是你不能多线程去操作UI，这是Android不允许的，它规定了你只能在主线程去操作UI。</p>
<p>总结一句话就是：<strong>Handler就是用于线程间通信，解决子线程无法访问UI的问题</strong></p>
<h2 id="Handler的几种常见使用方法"><a href="#Handler的几种常见使用方法" class="headerlink" title="Handler的几种常见使用方法"></a>Handler的几种常见使用方法</h2><p>注意：Handler的无参构造已经弃用</p>
<h3 id="1-作为内部类"><a href="#1-作为内部类" class="headerlink" title="1.作为内部类"></a>1.作为内部类</h3><p>作为内部类的使用方法相信大家在熟悉不过了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span>() : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-作为匿名内部类"><a href="#2-作为匿名内部类" class="headerlink" title="2.作为匿名内部类"></a>2.作为匿名内部类</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = <span class="keyword">object</span> :Handler(Looper.myLooper()!!)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为匿名内部类和作为内部类的方法差不多，不过是把内部类的名字去掉了。</p>
<h3 id="3-作为静态内部类"><a href="#3-作为静态内部类" class="headerlink" title="3.作为静态内部类"></a>3.作为静态内部类</h3><p>作为静态类的使用方法就是把内部类变为静态类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyHandler</span>(context: Context) : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> weakContext = WeakReference(context)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(weakContext.<span class="keyword">get</span>(), <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在kotlin中不加inner关键字的内部类默认就是静态的。这里为什么用WeakReference去引用context？这是防止内存泄漏，等会说。</p>
<h2 id="Handler的内存泄漏问题"><a href="#Handler的内存泄漏问题" class="headerlink" title="Handler的内存泄漏问题"></a>Handler的内存泄漏问题</h2><blockquote>
<p>内存泄漏可以说是面试必问的，也是我们开发者所必须熟知的。</p>
</blockquote>
<h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><blockquote>
<p>那么什么是内存泄漏呢？就是程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。</p>
<p>简单来说就是一个对象该被回收却没有被回收，造成了内存浪费。最常见的就是长生命周期引用短生命周期。</p>
<p>比如你的activity实例被一个静态变量引用，当你的activity销毁的时候，activity对象应该被回收，而静态变量会一直存在程序中，所以JVM会认为你的activity被一个静态变量引用，认为它还有用，它就不会回收activity实例，从而造成内存泄漏。</p>
</blockquote>
<p>Handler虽然好用，但是也容易用错，最容易犯的错误就是内存泄漏。</p>
<p>在上述的1和2的使用方法都是会出现内存泄漏的情况的。为什么呢？因为内部类和匿名内部类（lamda表达式，回调也是一样的）会持有外部内的引用。正是因为有外部类的引用，所以你的Hander作为内部类才能拿到外部类的变量，比如context，view等等。但是也正是因为有这个引用，比如内部类Handler持有外部类Activity的引用，会导致你的内存泄漏。举个例子，我们知道Hander发送消息到处理消息都可能会有延迟，这就有可能Handler的存在时间比Activity的时间还长，假如此时你发送了一个延时消息，但是消息还没处理你就推出界面，这时候就会内存泄漏。因为Handler的生命周期比Acivity的生命周期长嘛。</p>
<h3 id="如何检测内存泄漏"><a href="#如何检测内存泄漏" class="headerlink" title="如何检测内存泄漏"></a>如何检测内存泄漏</h3><p>检测内存泄漏有一个很方便的开源库——-LeakCanary：</p>
<p>使用：</p>
<p>在build.gradle引入依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.10&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在重新运行你的APP，这时候你的桌面就会出现金丝雀的图标：</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212001.png" style="zoom:200%;" />

<p>然后对着你的APP一顿测试，假如有内存泄漏就会弹出一个小黄鸟提示，然后你会看到这样的通知：</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212205.png" style="zoom:50%;" />

<p>点击这个通知它会进行分析，分析完成之后再点进去就会进去小黄鸟应用，里面是你的APP所有的内存泄漏的记录：</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212359.png" style="zoom:50%;" />

<p>点进去你就会看到泄漏对象的引用链：</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212510.png" style="zoom:50%;" />

<p>接下来就靠你自己分析引用链来判断是哪里内存泄漏了。</p>
<h3 id="解决Handler的内存泄漏："><a href="#解决Handler的内存泄漏：" class="headerlink" title="解决Handler的内存泄漏："></a>解决Handler的内存泄漏：</h3><p>上述说了，1和2会发生内存泄漏，是因为内部Handler引用了外部activity，那怎么解决呢？既然是Handler存在时间比Activity长那就缩短Handler的存在时间嘛，所以在onDestory中去移除所有发送的消息：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    myHandler.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在Activity被销毁的时候Handler所有的消息都被移除了，也就不存在对Activity的引用了，内存泄漏也就解决了。</p>
<p>而在3中Handler是用做静态内部类的，作为静态类的话就没有与外部类连接的通道了，这时候就只能传参，但为了防止使用强引用造成内存泄漏这里改为弱引用。Java里的四种引用这里做一个简单的介绍：</p>
<blockquote>
<p>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</p>
<p>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</p>
<p>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</p>
<p>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</p>
</blockquote>
<p>​	正式因为使用activity的context容易泄漏，我们toast一般使用application的context。因为application的生命周期一般都比较长，它是伴随你的app整个应用的。那么怎么使用呢？要使用，要知道application在哪里。在我们的注册文件，也就是声明activity的地方：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Teach&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个application就是系统默认的application，要使用我们自定义的application肯定的继承系统的application然后把context暴露出来：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> mContext: App</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        mContext = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application本身就是context。但是同时也要注意不要让application去引用任何短生命周期对象。然后在注册文件中去替换掉系统的application：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  通过替换掉application的name为我们自定义的App 去指定application为自定义的application  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.App&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Teach&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在toast里面去用context：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivitySecondBinding.inflate(layoutInflater) &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button2.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyHandler</span>() : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="comment">//这里context换成App的Context</span></span><br><span class="line">            Toast.makeText(App.mContext, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你的静态Handler就不需要和外部的Activity去通信。</p>
<h2 id="浅析Handler"><a href="#浅析Handler" class="headerlink" title="浅析Handler"></a>浅析Handler</h2><p>上面我们说到，Handler的无参构造已经废弃，取而代之的是有参构造，传入的参数是Looper.myLooper()。为什么要传这个参数呢？因为Handler的创建是根据Looper来获取的，而Looper是和Thread对应的。Google认为原来的无参构造你没有指定Looper，这容易导致Looper的获取为空从而导致崩溃。所以原来的无参被废弃，让你自己传Looper等于是应用崩溃了是你的原因而不是官方代码出问题了。</p>
<p>那么Handler是怎么保证在主线程运行的，Looper、Thread、Handler又是怎么样的一个关系呢？听我慢慢讲来。</p>
<h3 id="在子线程中创建Handler"><a href="#在子线程中创建Handler" class="headerlink" title="在子线程中创建Handler"></a>在子线程中创建Handler</h3><p>在构建Handler的时候，我们会获取Looper并且传进去，那么Looper肯定会初始化。</p>
<p>我们创建的Handler一般都是主线程的Handler，那在子线程怎么创建Handler呢？</p>
<p>有人说直接new啊：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            Thread&#123;</span><br><span class="line">                <span class="keyword">val</span> handler = Handler(Looper.myLooper()!!)</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那当你点击按钮的时候你的app就崩了，并且给你报Looper为空的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">        at com.wssg.teach.MainActivity.onCreate$lambda$1$lambda$0(MainActivity.kt:20)</span><br><span class="line">        at com.wssg.teach.MainActivity.$r8$lambda$nMCVh1lEoyHQZBD9S2vny8Epw_k(MainActivity.kt)</span><br><span class="line">        at com.wssg.teach.MainActivity$$ExternalSyntheticLambda0.run(D8$$SyntheticClass)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:761)</span><br></pre></td></tr></table></figure>

<p>说明咱们的Looper还没初始化，子线程创建不了Handler，正确的Handler的创建方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        <span class="keyword">var</span> handler: Handler? = <span class="literal">null</span></span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            Thread &#123;</span><br><span class="line">                Looper.prepare()</span><br><span class="line">                handler = <span class="keyword">object</span> : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                        Log.d(<span class="string">&quot;RQRQRQ&quot;</span>, <span class="string">&quot;handleMessage: 收到消息！！！！&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Looper.loop()</span><br><span class="line">            &#125;.start()</span><br><span class="line">            Thread &#123;</span><br><span class="line">                handler?.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是举个例子怎么在子线程创建Handler并且发送消息给它。首先开启了一个线程，Looper.prepare()就是初始化Looper，这样在下面创建Handler的时候Looper.myLooper才不会为null，然后Looper.loop()是开始接收Handler收到消息，没这行代码是收不到消息的，然后又开启了子线程给Handler发送一个消息，之后你就能在子线程看到消息收到了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-04-06 22:23:38.673  5646-5706  RQRQRQ                  com.wssg.teach                       D  handleMessage: 收到消息！！！！</span><br></pre></td></tr></table></figure>

<p>日志也确实如此。</p>
<p>总结Handler的创建：</p>
<p>1.Looper.prepare()       初始化Looper</p>
<p>2.new Handler(Looper.myLooper)       创建Handler</p>
<p>3.Looper.loop()    开始接收消息</p>
<p>4.在其他地方发送消息</p>
<h3 id="分析消息的插入流程"><a href="#分析消息的插入流程" class="headerlink" title="分析消息的插入流程"></a>分析消息的插入流程</h3><p>但是我们平常使用的时候并没有去初始化Looper.prepare()，而且也没有报错，那Android底层肯定初始化了Looper。那么在哪里呢？</p>
<p>我们在学java的时候总是会有一个main函数作为程序运行的入口对不对。而我们之前写Android也是用java写的，并且源码很多也是java，那源码里面肯定有一个main函数。在哪里呢？在ActivityThread里面。ActivityThrea也就是Android的Ui线程。我们在Android Studio里面全局搜索进去ActivityThread的源码，然后在代码里面搜索main函数：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230406223748.png"></p>
<p>一眼看去就看到了Looper.prepareMainLooper()和Looper.loop();两行代码，果然是在这初始化了Looper。而Looper.prepareMainLooper();本身也是调用Looper.prepare()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);<span class="comment">//本身就是调用了Looper.prepare()</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper初始化流程我们弄清楚了，我们看看具体的流程。我们先看我们常用的Handler的发送消息的方法，Handler有多个发送消息的方法：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230406235200.png"></p>
<p>sendMessage，sendEmptyMessage，post…….等等等等都是调用的sendMessageDelayed，sendMessageDelayed调用的是sendMessageAtTime()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的就是enqueueMessage：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，this也就是Handler存到了message的target，给了个唯一的Id，mAsynchronous是用于判断是否是加急消息，加急消息之后说。然后就是调用queue.enqueueMessage(msg, uptimeMillis);，queue是什么呢？是MessageQueue，就是MessageQueue的enqueueMessage：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;<span class="comment">//Handler不能为空</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//判断message是否在使用中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//判断是否停止</span></span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();<span class="comment">//回收message</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();<span class="comment">//标记当前的message在使用</span></span><br><span class="line">        msg.when = when;<span class="comment">//把message发生的时间存到message</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;<span class="comment">//message的表头</span></span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler为null就抛出异常，然后有个关键字synchronized，synchronized是什么呢？它就是一把锁。我们用handler经常跨线程操作嘛，而synchronized就是保证线程安全的一个关键字，你可以理解为当一个线程在操作synchronized括号里的东西的时候，其他线程也执行到这里了就会进行等待，等到前一个把synchronized括号里的操作执行完了其他线程才会被唤醒执行这里面得代码。以此来保证一个数据同一时间只能被一个线程操作。</p>
<p>然后是判断message是否在使用，在使用就会抛出异常。如果正在停止，而这里又是异步操作，这里就会产出一个异常，再回收Message，当我们调用Looper.quit()去结束Looper的时候就会走到这里。而回收Message其实就是清除Message携带的所有信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    replyTo = <span class="literal">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="literal">null</span>;</span><br><span class="line">    callback = <span class="literal">null</span>;</span><br><span class="line">    data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="built_in">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清除所有的信息之后就把Message加入到sPool中。为什么要这么做呢？为了Message的复用。要知道Handler是Android框架经常用的东西，每次都new一个message多麻烦，也耗性能。Message是一个链表结构，把当前message回收后把当前的message插入表头。那我们怎么拿回收的Message呢？用Message.obtain()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从回收池里面拿，拿不到再new。事实上也推荐这种获取message的方式，在源码里也能经常看到，比如sendEmptyMessageDelayed：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendEmptyMessageDelayed</span><span class="params">(<span class="type">int</span> what, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单了解了message，我们再看看enqueueMessage关键的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//消息队列为空，需要立即发生，发生时间早于表头</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前message是否锁住，p的Handler是否为null，msg是否为异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//下面这一段就是链表的插入操作，如果到末尾了或者当前的Message发生时间小于要插入的Message发生时间就break</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面循环break，代表找到了要插入的位置</span></span><br><span class="line">            <span class="comment">//将当前结点插入</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;<span class="comment">//当前需要唤醒就调用native层的方法去唤醒当前线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记message在使用，把时间存到Message。mMessages是一个要处理的消息链表。</p>
<p>首先是第一个分支，p引用mMessages的表头。如果表头为空，发生时间为0（也就是需要立即执行）或者发生时间比mMessages表头早的话就把当前的Message作为表头插入消息链表。这里的needWake是用于唤醒线程的，这里把mBlocked是否需要锁住当前Message操作赋值给了needWake。被锁住了那肯定就需要唤醒嘛。</p>
<p>一般走的都是第二个分支，needWake需要唤醒的条件为当前Message是否被锁住，Handler是否为null，Message是否为异步消息。之后就是一个死循环去遍历链表的所有结点，插入结点的位置为，发生时间早于后一个结点或者是末尾。最后就是唤醒线程。</p>
<p>这里有两个疑问点：1.什么是异步消息，有什么用？    2.为什么要唤醒线程    我们先看什么是异步消息   </p>
<h3 id="什么是异步消息，同步屏障？"><a href="#什么是异步消息，同步屏障？" class="headerlink" title="什么是异步消息，同步屏障？"></a>什么是异步消息，同步屏障？</h3><p>Handler一般有三种消息：同步消息，异步消息，同步屏障</p>
<p>我们平常所发送的消息都是同步消息。</p>
<p>同步屏障用于处理异步消息。什么意思呢？</p>
<p>我们知道屏幕是有刷新率的，60hz，120hz，144hz等等。以60hz来说，它的所有界面都需要在16ms内画完，假如此时需要处理的消息太多了，16ms处理不完，此时界面就会发送卡顿现象。这时候就需要异步消息了。在发送异步消息后，如果在取消息过程中遇到了同步屏障就会去寻找异步消息，找到异步消息就返回，没有异步消息才会去找同步消息。简而言之，同步屏障就是一个标记，遇到这个标记就忽略同步消息去找异步消息。</p>
<p>怎么创建异步消息？</p>
<p>1.创建Handler的时候声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的async参数就代表此Handler发送的消息是否是异步消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在插入消息的时候会去调用msg.setAsynchronous(true);将异步Handler发送的消息设置成异步消息</p>
<p>2.当然我们传Message的时候也可以直接将它设置成异步消息：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> msg = Message.obtain()</span><br><span class="line">msg.isAsynchronous = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>怎么发送同步屏障？通过postSyncBarrier()方法，但是postSyncBarrier()方法是隐藏的只能通过反射调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> token: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;DiscouragedPrivateApi&quot;</span>)</span></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postSyncBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> method = MessageQueue::<span class="keyword">class</span>.java.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">    token = method.invoke(Looper.getMainLooper().queue) <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeSyncBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> method =</span><br><span class="line">        MessageQueue::<span class="keyword">class</span>.java.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="built_in">Int</span>::<span class="keyword">class</span>.java);</span><br><span class="line">    method.invoke(Looper.getMainLooper().queue, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而postSyncBarrier()就是target也就是handler为null的message：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        <span class="comment">//这里没有对target赋值，就是为null</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">		<span class="comment">//下面就是插入message</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们简单分析了一下Message的插入流程，那么我们现在来看看Looper.prepare()和Looper.loop干了什么事情。</p>
<h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收一个boolean值，quitAllowed是否允许这个Looper停止嘛。判断ThreadLocal是否为null，不为null抛出异常，为null就new 一个Looper设置到ThreadLocal里面。</p>
<p>ThreadLocal是什么呢？<strong>是一个以线程为作用域存储数据的一个类</strong>，什么叫以线程为作用域？就是说对于同一个ThreadLocal变量，不同的线程从里面去取数据能取到不同的值，就比如A线程在这个sThreadLocal里面存了A线程的Looper，B线程在这个sThreadLocal里面也存了B线程的Looper，然后A线程去和这个sThreadLocal说，我要取Looper出来，sThreadLocal会把A线程的Looper取出来，而不会取到B线程的Looper，B线程同理.构造这个ThreadLocal里面的泛型的实际类型就表明了这个ThreadLocal希望为线程存储什么类型的数据。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//通过线程去获取map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">//map存在就直接拿里面的值返回</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map为nul就初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();<span class="comment">//初始化value，默认为null</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//map存在就设置值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);<span class="comment">//不存在就创建map，并且把初始值传进去</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);<span class="comment">//第一次设置值map不存在就创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">//就是创建了一个ThreadLocalMap，并且设置了值</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal创建Map获取Map都是通过Thread去操作的，创建获取的都是Thread的ThreadLocalMap，map的key是ThreadLocal，value是泛型也就是Looper。也就是说一个ThreadLocal变量通过不同的线程获取不同的ThreadLocalMap，从而获取到自己的Looper</p>
<p>而ThreadLocalMap是ThreadLocal的静态内部类，是一个对键值对的弱引用包装：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230407171128.png"></p>
<p>为什么不直接用map而是要用个Entry去维护呢？这主要是一个不破坏原则，为了扩展WeakReference去弱化引用。他的设计很完美，感兴趣可以研究一下。</p>
<p>那我们现在知道了Looper.prepare就是用ThreadLocal去用线程获取map把Looper存进去key是ThreadLocal，那我们看看new Looper干了啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new 了一个MessageQueue，并记录quitAllowed的值。</p>
<p>好了，prepare我们分析清清楚了。总结一下：</p>
<p>ThreadLocal通过Thread去获取对应的ThreadLocalMap，通过Map去存Looper实例，key是ThreadLocal，new Looper的时候初始化了MessageQueue消息队列把是否允许停止的值记录在了这里。也难怪没初始化Looper的时候我们调用Looper.myLoop()会报空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没初始化之前sThreadLocal.get()获取的肯定为空。</p>
<p>接下来分析Looper.loop()</p>
<h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;AndroidFrameworkBinderIdentity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛弃对代码健壮性的处理，关键的代码只有这么几行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;AndroidFrameworkBinderIdentity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper(); </span><br><span class="line">	......</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是开启了一个死循环，一直调用loopOnce()，如果返回flase就结束死循环。那我们看看loopOnce：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">//拿消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//这里调用的就是创建Handler重写的handlerMessage</span></span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.messageDispatched(token, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里除去了无关的代码，关键的就两行Message msg &#x3D; me.mQueue.next();和msg.target.dispatchMessage(msg)，先拿消息，然后处理消息。</p>
<p>看看Message msg &#x3D; me.mQueue.next();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次进入一次循环都会睡眠线程</span></span><br><span class="line">        <span class="comment">//调用native层对当前线程进行睡眠，睡眠时间是nextPollTimeoutMillis一开始是0就是不睡眠</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//加锁</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;<span class="comment">//拿到消息队列的头</span></span><br><span class="line">            <span class="comment">//下面这条分支是当target为null的时候，也就是遇到了同步屏障</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//直到找到异步消息或者到结尾的时候才会退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拿到消息就会到这个分支</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//要执行的时间比当前时间晚的话就会计算要睡眠的时间进行睡眠</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//这里就是找到当前要执行的消息</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;<span class="comment">//把当前消息从链表中删除</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;<span class="comment">//返回拿到的message</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//这条分支表示messages为空也就是没有任何消息要处理</span></span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;<span class="comment">//睡眠时间为-1表示当前线程会一直睡眠</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是调用Looper.quit()的情况，销毁MessageQueue</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//这里返回null，loopOnce就返回false，loop就退出了死循环，程序运行结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ........</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是处理IdleHandler，这是在没有任何消息的情况下才会走到这里，说明idleHandler的消息级别最低</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();<span class="comment">//调用重写的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;<span class="comment">//如果不需要保存就移除</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是一个死循环，每次进入循环都会调用native层的方法睡眠当前线程，而睡眠时间是在for循环中去计算的。首先是判断是不是遇到了同步屏障，是就去找异步消息而忽略同步消息。之后拿到了消息会判断跟当前的时间大小，比当前时间晚，就会睡眠直到消息的执行时间。否则把当前的message从消息队列中删除并返回。如果没拿到消息说明没有消息要处理了，就一直睡眠，直到有消息进来。如果中途调用Looper.quit就直接退出程序。</p>
<p>最后是没有任何消息需要处理才会去处理IdleHandler，那么它是什么呢？它就是一个优先级最低的Handler，当你有一个不那么重要的任务需要处理的时候你就可以用它。怎么使用呢？使用MessageQueue添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="literal">false</span><span class="comment">//返回false表示执行任务后移除自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后再看看</p>
<h3 id="Looper-quit"><a href="#Looper-quit" class="headerlink" title="Looper.quit()"></a>Looper.quit()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">    mQueue.quit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quit</span><span class="params">(<span class="type">boolean</span> safe)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是把mQuitting的值设为true，然后移除所有的Message，唤醒线程结束程序。</p>
<p>好了整体的流程我们大概讲完了，我们再来捋一捋，ThreadLocal对应线程的ThreadLcoalMap，ThreadLocalMap对应保存了ThreadLocal和Looper，Looper对应一个MessageQueue。Looper.loop里面有个死循环一直取消息，取不到消息就睡眠当前线程，取到就回调dispatchMessage方法。sendMessage就是在MessageQueue里面插入消息。</p>
<p>我们再看看HandlerThread和IntentService</p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> mPriority;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mTid</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getThreadHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quitSafely</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getThreadId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler就是一个内部封装了Looper的Thread，方便我们创建handler，使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> handlerThread = HandlerThread(<span class="string">&quot;测试线程&quot;</span>)</span><br><span class="line">handlerThread.start()</span><br><span class="line"><span class="keyword">val</span> mHandler = <span class="keyword">object</span> :Handler(handlerThread.looper)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个使用HandlerThread的IntentService，不过在API26也就是Android 8以后被废弃了，官方推荐使用WorkManager。这里还是贴一下源码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IntentService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntentService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntentRedelivery</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> <span class="title class_">ServiceHandler</span>(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是一个HandlerThread的Service，现在也很少用它来做后台任务了。</p>
<p>Handler的讲解差不多是这些了，接下来我们来看几个常见面试题吧：</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>MessageQueue是干嘛呢？用的什么数据结构来存储数据？</p>
<blockquote>
<p>MessageQueue就是一个用于存储消息、用链表实现的特殊队列结构。</p>
</blockquote>
<p>Handler中延时消息是怎么实现的？</p>
<blockquote>
<p>MessageQueue是一个按照消息时间排列的一个链表结构，根据消息的when字段插入即可。</p>
</blockquote>
<p>MessageQueue的消息怎么被取出来的？</p>
<blockquote>
<p>通过Looper的next方法取消息，里面是一个死循环，保证一定可以取到一条消息,如果没有可用消息，那么就阻塞在这里，一直到有新消息的到来。</p>
<p>阻塞的情况有俩种 没有消息 和当前消息还没有到要发送的时间</p>
</blockquote>
<p>ThreadLocal运行机制？这种机制设计的好处？</p>
<blockquote>
<p>ThreadLocal中有一个ThreadLocalMap变量，这个变量存储着键值对形式的数据。</p>
<ul>
<li>key为this，也就是当前ThreadLocal变量。</li>
<li>value为T，也就是要存储的值。</li>
</ul>
<p>每个线程中都有一个ThreadLocalMap,这样带来的好处就是，在不同的线程，访问同一个ThreadLocal对象，但是能获取到的值却不一样。</p>
</blockquote>
<p>为什么ThreadLocalMap要弱引用ThreadLocal?(需要懂内存泄漏的相关知识)</p>
<blockquote>
<p>因为ThreadLocalMap如果是强引用ThreadLocal的话，假如我们将<br>ThreadLocal置为null，会因为ThreadLocalMap持有了ThreadLocal的引用而无法被GC</p>
</blockquote>
<p>为什么不能在子线程中更新UI？</p>
<blockquote>
<p>因为Android中的UI控件不是线程安全的。</p>
<p>如果通过加锁来实现UI控件的线程安全会导致UI访问的效率降低影响用户体验。</p>
</blockquote>
<p>Looper中的quitAllowed字段是啥？有什么用？</p>
<blockquote>
<p>是否允许退出的标志字段。在quit方法中有被用到，如果这个字段为false，代表不允许退出，就会报错。</p>
<p>quit方法就是退出消息队列，终止消息循环。</p>
<ul>
<li>首先设置了mQuitting字段为true。</li>
<li>然后判断是否安全退出，如果安全退出，就清空所有的延迟消息，之前没处理的非延迟消息还是需要处理</li>
<li>如果不是安全退出，就直接清空所有的消息</li>
</ul>
<p>当调用了quit方法之后，mQuitting为true，enqueuemessage方法中消息就发不出去了，会报错。next方法返回null，那么loop方法中就会退出死循环。</p>
</blockquote>
<p>Handler、Looper、MessageQueue、线程是一一对应关系吗？</p>
<blockquote>
<p>一个线程只会有一个Looper对象，所以线程和Looper是一一对应的。</p>
<p>MessageQueue对象是在new Looper的时候创建的，所以Looper和MessageQueue是一一对应的。</p>
<p>Handler的作用只是将消息加到MessageQueue中，并后续取出消息后，根据消息的target字段分发给当初的那个handler，所以Handler对于Looper是可以多对一的，也就是多个Hanlder对象都可以用同一个线程、同一个Looper、同一个MessageQueue。</p>
<p>总结：Looper、MessageQueue、线程是一一对应关系，而他们与Handler是可以一对多的。</p>
</blockquote>
<p>Looper.loop方法是死循环，为什么不会卡死（ANR）?</p>
<blockquote>
<p>1.主线程需要这样的死循环来处理View界面的变化</p>
<p>2.而且没有消息的时候,handler会阻塞，主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生。所以死循环也不会特别消耗CPU资源。</p>
<p>3.在收到跨线程消息后，会交给主线程的Hanlder再进行消息分发。所以Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施，比如收到msg&#x3D;H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终执行到onCreate方法。</p>
<p>4.真正导致ANR的原因不是死循环，而是因为在某个消息处理的时候操作时间过长</p>
</blockquote>
<p>HandlerThread和IntentService的原理</p>
<blockquote>
<p>HandlerThread就是一个封装了Looper的Thread类<br>通过获取 HandlerThread 的 looper 对象传递给 Handler 对象，可以在 handleMessage()方法中执行异步任务。<br>HandlerThread 与线程池不同，HandlerThread 背后只有一个线程,多任务时需要等待处理</p>
<p>IntentService 是一个继承了 Service 的抽象类，它封装了HandlerThread 和 Handler，当 IntentService 被第一次启动时，它的 onCreate()方法会被调用，onCreat()方法会创建一个HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象，这样通过 handler 发送的消息最终都会在HandlerThread 中执行。</p>
</blockquote>
<p>Handler内存泄漏的原理</p>
<blockquote>
<p>内存泄漏的本质是因为长生命周期的对象持有了短生命周期对象的引用导致短生命周期的对象无法被正确回收。</p>
<p>Handler如果是activity的内部类，会导致handler持有activity的引用，而handler在发送message时,message会持有handler的引用，而message又被messageQueue引用，messagequeue又被looper引用，looper又被threadlocal引用，threadlocal又被主线程引用，从而导致handler内存泄漏。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://rq527.github.io">RQ527</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rq527.github.io/rq/9f08fd9f.html">http://rq527.github.io/rq/9f08fd9f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rq527.github.io" target="_blank">RayQuester</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Handler/">Handler</a></div><div class="post_share"><div class="social-share" data-image="/img/header.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/rq/cf6c3d31.html" title="设计模式学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/rq/260b5af1.html" title="Jetpack之四：ViewModel"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Jetpack之四：ViewModel</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/rq/784dd132.html" title="浅学Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">浅学Android性能优化</div></div></a></div><div><a href="/rq/9df138cf.html" title="Jetpack之一：Lifecycle"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">Jetpack之一：Lifecycle</div></div></a></div><div><a href="/rq/a365d41.html" title="Jetpack之二：Databinding和Navigation的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">Jetpack之二：Databinding和Navigation的使用</div></div></a></div><div><a href="/rq/e6b8b5a8.html" title="Jetpack之三：LiveData"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-27</div><div class="title">Jetpack之三：LiveData</div></div></a></div><div><a href="/rq/260b5af1.html" title="Jetpack之四：ViewModel"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">Jetpack之四：ViewModel</div></div></a></div><div><a href="/rq/e54d6d21.html" title="LeakCanary为什么这么神奇？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-15</div><div class="title">LeakCanary为什么这么神奇？</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODQ1Mi8zNDkxNQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQ527</div><div class="author-info__description">=与其诅咒黑暗，不如点亮蜡烛=</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQ527"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQ527" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://juejin.cn/user/3228640351367704" target="_blank" title="稀土掘金"><i class="fas fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎您的到来，希望我的文章能对您有所帮助，若有疑问和文章建议欢迎评论~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Handler是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Handler的几种常见使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E4%B8%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">1.作为内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%9C%E4%B8%BA%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2.作为匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">3.作为静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">Handler的内存泄漏问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">如何检测内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Handler%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">解决Handler的内存泄漏：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%9E%90Handler"><span class="toc-number">4.</span> <span class="toc-text">浅析Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BAHandler"><span class="toc-number">4.1.</span> <span class="toc-text">在子线程中创建Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%B6%88%E6%81%AF%E7%9A%84%E6%8F%92%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">分析消息的插入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">什么是异步消息，同步屏障？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Looper-prepare"><span class="toc-number">4.4.</span> <span class="toc-text">Looper.prepare()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Looper-loop"><span class="toc-number">4.5.</span> <span class="toc-text">Looper.loop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Looper-quit"><span class="toc-number">4.6.</span> <span class="toc-text">Looper.quit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread"><span class="toc-number">4.7.</span> <span class="toc-text">HandlerThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Question"><span class="toc-number">5.</span> <span class="toc-text">Question</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/22f4c025.html" title="一名（深陷Android无法自拔的）大二狗的年中总结">一名（深陷Android无法自拔的）大二狗的年中总结</a><time datetime="2023-07-18T12:52:31.632Z" title="发表于 2023-07-18 20:52:31">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/cf6c3d31.html" title="设计模式学习笔记">设计模式学习笔记</a><time datetime="2023-05-29T08:10:26.110Z" title="发表于 2023-05-29 16:10:26">2023-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/9f08fd9f.html" title="一文搞清楚Handler，再也不怕面试官">一文搞清楚Handler，再也不怕面试官</a><time datetime="2023-04-25T04:36:29.000Z" title="发表于 2023-04-25 12:36:29">2023-04-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/260b5af1.html" title="Jetpack之四：ViewModel">Jetpack之四：ViewModel</a><time datetime="2023-04-04T10:35:59.000Z" title="发表于 2023-04-04 18:35:59">2023-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/rq/e6b8b5a8.html" title="Jetpack之三：LiveData">Jetpack之三：LiveData</a><time datetime="2023-03-27T07:56:39.000Z" title="发表于 2023-03-27 15:56:39">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By RQ527</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>