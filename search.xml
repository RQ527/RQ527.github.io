<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一名（深陷Android无法自拔的）大二狗的年中总结</title>
      <link href="/rq/22f4c025.html"/>
      <url>/rq/22f4c025.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是入行没多久，不会写代码的RQ。一名来自四非学校的大二狗。2023时间已经过去了一半，我的大学生活也过去了一半。借着这个2023年中总结的话题我也想给我的前半段大学生活做一个总结和记录（希望大家原谅理工男的表达能力，已经在学着写博客了🙃）。</p><h2 id="大学之前"><a href="#大学之前" class="headerlink" title="大学之前"></a>大学之前</h2><p>大学之前，我的高中初中都是在一个小乡镇度过，每天都是过着教室、食堂、厕所三点一线的生活。可能偶尔会和几个好兄弟打打球，开开黑。那时候一心只读圣贤书，从未碰过电脑（也只有偶尔去网吧玩玩电脑游戏），也未曾了解过任何跟代码相关的东西。只有在高三快毕业了，学校进行志愿填报培训的时候，我才在想我想干什么。</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230718212410.png" style="zoom: 50%;" /><p>我想学编程，我想搞钱，我要成为编程高手！！哈哈哈，当时的确是这么想的，因为我一直都觉得会电脑，会编程的“大黑客”很酷！。然而结果是</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230718212434.png" style="zoom: 50%;" /><p>当时我还一时兴起，在京东上买了本0基础学python的书：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230718212505.png" style="zoom:50%;" /><p>奈何高三学业繁忙没时间看，而且也没有电脑实操，看了十几页压根不知道在讲什么，之后这本书也就放着吃灰了。现在看来当时确实挺傻×的。后来上了大学，自学了python，这本书也就送给了室友。</p><p>高三的时候大家都想着我要上某某985！我要上某某211！当然我也不例外。然而等到高考出分，才知道现实是多么残酷。我的高考成绩也只够报一个末流的211，报不了什么985。思虑最终我报了一个专业性比较强的双非计算机。因为我觉得一个专业不对口的末流211不如一个专业好的四非。</p><p>上大学前我是保持怀疑的，我没有任何相关编程经验，甚至是接触电脑的机会都少。不过幸运的是家里人都支持我，给我买了一台不错的笔记本。那个暑假我加入了我们学校的新生群，我发现原来大家都是卷王。有初中就开始接触编程的，有高中就学完的java的，有暑假已经快把c语言学完了的。为了不落后，高考完的那个后半个暑假我也在偷偷学c语言，能力有限，到开学也才学到指针多一点点（指针这个东西对于当时的我简直就是噩梦）。</p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><p>大一开学后，我同大多数人一样，满怀期待地踏进了向往的大学生活。在第一次年级集中会上，我收到了一份宣传单。那是一份我们学校的一个互联网组织的宣传单。分有产品、视觉、后端、移动、前端、运维几个部门。听说里面全是编程大牛，学校里顶尖技术人员的集聚地。这不就是我想成为的人吗？于是我下定决心我要加入他们。</p><p>大一的时候大部分课余时间都花在了这个叫做红岩网校工作站的课程上面。大一上半个学期学会了javase，下半个学期开始学写APP，会写几个简单的Activity页面，当时我还写了个恶搞APP(类似于o泡果奶APP，不过没有屏蔽按键的功能只是简单将声音放到最大然后播放恶搞音乐lost-rivers。哈哈哈这个不提倡，小心被打)。当然学校课程我也没有忘记，我记得c语言期末大作业自己写了个贪吃蛇和俄罗斯方块：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/image-20230718212201844.png" alt="image-20230718212201844"  /><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230718212547.png" style="zoom:50%;" /><p>一行一行敲了八九百行，对于当时还是编程小白的我是个不小的成就了。</p><p>后来的一整个寒假都在写我们移动开发部的寒假考核，也是我人生中的第一个项目–彩云天气app（地址就不贴了，现在看来写的代码就是💩）。</p><p>大一的下学期，开学自学了Koltin语言，从此再也不想用java了😭。之后也是按照网校的课程学了jetpack、rxjava、retrofit、MvvM等等。到了五一，写了自己的第二个项目–星球app（时间管理类app），也是网校的期中考核（当然也顺利通过啦~）。后面自学了python，简单写了一个抢课的脚本（以后再也不怕抢不到课了😭）。之后自己租了个服务器用python搭了个QQ机器人，后面搞到网校招新群里去玩了。不得不说NoneBot社区真的不错，文档什么的都很完善，对QQ机器人感兴趣的可以试试（<a href="https://nb2.baka.icu/docs/">概览 | NoneBot (baka.icu)</a>）。</p><p>大一的暑假，我留在了学校参加了网校的暑期培训。培训期间简单研究了一下Android性能优化跟LeakCanary，然后也是写了自己的第三个项目：开眼APP(<a href="https://github.com/RQ527/KaiYan">RQ527&#x2F;KaiYan</a>，图片可能寄掉了。)</p><p>最终呢也是没有辜负自己的努力通过了最终的考核成为了网校的干事：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230718212633.png" alt="mmexport1689672953594.jpg" width="30%" /><p>总的来说，大一学年算是踏入了编程的门吧，没有在荒废中度过。同时也要感谢网校给了我这个机会😁。</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h2><p>大二的课余时间主要都花在了给移动开发部门培养新血液的事情上面。因为我的上一届也就是带我们的学长他们大三了，准备考研的考研，就业的就业，自然教学的任务就落到了我们头上。期间上了三节课，我发现给他们上课的同时也是给我自己上课。学习一个东西最有效的方式就是给别人讲懂。</p><p>这是大二刚开学的宣讲会😁：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20221003_185411.jpg"  /><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/1664878518099.jpeg"></p><p>同时自己也接手了一个多人项目，跟我们部门的另外一个人写一个类似于微博投票表决的项目，不过还没上线。</p><p>下半个学期自己用github搭了个个人博客网站：<a href="https://rq527.github.io/">https://rq527.github.io</a> (还没钱买域名，暂时先用github吧😭)</p><h2 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h2><p><strong>我认识到了什么</strong></p><ul><li><p>接受自己的平庸，接受任何方面的平庸。</p></li><li><p>永远不要斤斤计较</p></li><li><p>杜绝一分钟热度，永远保持一颗热忱的心</p></li><li><p>打铁还需自身硬</p><blockquote><p>从入行Android 开发以来，网上很多人都说 “Android 开发早就凉了，现在就是死路一条”，“现在学Android就是49年入国军！”等等。但是我身边同行的人还不是能找到实习，找到工作。我的意思是，什么事情都是需要自己有实力。</p></blockquote></li></ul><p>说实话，上了大学我最痛惜的是那些曾经交好的朋友也逐渐不联系了，一张通知书撕裂了一群人，以后再见也不知道是什么时候了。</p><h2 id="未来的事情"><a href="#未来的事情" class="headerlink" title="未来的事情"></a>未来的事情</h2><ul><li>管理移动开发部</li><li>找实习（目标是进大厂）</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我想说很感谢家里人的支持，他们并没有像那些家长一样一味要求自己的孩子去学医，当老师，报军校，而是支持我所做的一切。<strong>同时也很感谢那个她，陪我一起成长，学习，愿意和我分享快乐，听我诉说（世上最幸运的事情莫过于此了吧😁）</strong>。也很感谢网校给我这么一个平台，让我认识了很多志同道合的兄弟和伙伴。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习笔记</title>
      <link href="/rq/cf6c3d31.html"/>
      <url>/rq/cf6c3d31.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章是学习设计模式过程中做的笔记（主要是每种设计模式的代码示例），部分代码和内容来自掘金社区。</p><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p></blockquote><h2 id="为什么要学设计模式？"><a href="#为什么要学设计模式？" class="headerlink" title="为什么要学设计模式？"></a>为什么要学设计模式？</h2><ol><li>设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</li><li>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码</li><li>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统</li><li>学习设计模式有助于更加深入地理解面向对象思想，能够踏出架构的第一步。</li></ol><h2 id="设计模式种类"><a href="#设计模式种类" class="headerlink" title="设计模式种类"></a>设计模式种类</h2><p>设计模式一共分为三种类型：</p><ol><li>创造型设计模式：单例模式、简单工厂模式、抽象工厂模式、建造者模式、原型模式</li><li>结构型设计模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型设计模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ol><h2 id="遵循的七大原则"><a href="#遵循的七大原则" class="headerlink" title="遵循的七大原则"></a>遵循的七大原则</h2><p>设计模式遵循六大原则：</p><ol><li><p>单一职责原则</p><blockquote><p>每个类应该实现单一的职责。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。想要避免这种现象的发生，就要尽可能的遵守单一职责原则。</p><p>单一职责原则的核心就是解耦和增强内聚性。</p></blockquote></li><li><p>里氏替换原则</p><blockquote><p>里式替换原则是用来帮助我们在继承关系中进行父子类的设计。</p><p>应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性。</p><p>不符合里氏替换原则的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p></blockquote></li><li><p>依赖倒置原则</p><blockquote><ol><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象. 不可分割的原子逻辑就是低层模式，原子逻辑组装成的就是高层模块。</li><li>抽象不应该依赖细节 java 中，抽象 -&gt; 接口或抽象类；细节 -&gt; 实现类</li><li>细节应该依赖抽象</li></ol><p>依赖倒转原则就是要针对接口编程，不要针对实现编程。这就是说，应当使用接口或者抽象类进行<strong>变量的类型声明</strong>，<strong>参数的类型声明</strong>，<strong>方法的返回类型说明</strong>，<strong>以及数据类型的转换</strong>等。</p><p>在java中体现为多态的使用</p></blockquote></li><li><p>接口隔离原则</p><blockquote><p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p></blockquote></li><li><p>迪米特法则</p><blockquote><p>也称为最少知识原则： <strong>一个对象应该对其他对象有最少的了解。对类的低耦合提出了明确的要求</strong></p><p>只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p></blockquote></li><li><p>开闭原则</p><blockquote><p><strong>对扩展开放，对修改封闭</strong></p><p>开放封闭原则是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。其他的设计原则，很多时候是为实现这一目标服务的.</p></blockquote></li><li><p>合成复用原则</p><blockquote><p>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p></blockquote></li></ol><h2 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而<strong>使用单例模式能够保证整个应用中有且只有一个实例</strong>。</p></blockquote><p>单例在于只有一个实例，所以必须私有化构造函数再向外暴露提供唯一实例的方法。</p><ol><li><p>饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饿汉式单例工作中.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：使用类加载机制避开线程安全问题</p><p>缺点：类加载的时候就创建实例，内存利用率低。</p></li><li><p>懒汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例工作中.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好处：懒加载，提高内存利用率，synchronized保证线程安全</p><p>缺点：synchronized作用的是整个getInstance方法，每次都要经过判断锁，等待锁，释放锁这些过程。</p></li><li><p>静态内部类单例（推荐）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InnerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> InnerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态内部类单例工作中.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InnerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与饿汉式不同的是静态内部类利用内部类达到了懒加载的效果，类加载保证线程安全。</p></li><li><p>双重校验锁（推荐）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoIfSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TwoIfSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TwoIfSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TwoIfSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TwoIfSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">TwoIfSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;双重校验锁单例类工作中.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重校验指的就是两次if判断，第一次是避免不必要的锁等待，第二次是避免重复new 实例。而new TwoIfSingleton并不是原子操作，不是原子操作就可能发生指令重排序，volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障，这样，在它的赋值完成之前，就不用会调用读操作。关于volatile指令重排因为篇幅原因这里不再赘述，大家可自行查阅。</p></li><li><p>枚举类实现单例</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举类单例工作中.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用java枚举类的特性实现私有化构造函数，反序列化创建对象。但没有懒加载的效果。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式其实就是产品和客户之间的解耦，客户通过工厂去获取相应的产品。</p><p>工厂模式包含了简单工厂模式，工厂方法模式和抽象工厂模式。</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>我们从一个例子入手。假设我们现在需要生产不同类型的形状，包括圆，三角形，四边形，平行四边形等等。</p><p>首先定义一个Shape接口，有一个draw方法。然后定义几个图形产品：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oval</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制椭圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个生产产品的工厂。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Shape <span class="title function_">createShape</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        Shape shape;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;三角形&quot;</span>:</span><br><span class="line">                shape = <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;矩形&quot;</span>:</span><br><span class="line">                shape = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;椭圆形&quot;</span>:</span><br><span class="line">                shape = <span class="keyword">new</span> <span class="title class_">Oval</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;圆形&quot;</span>:</span><br><span class="line">                shape = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                shape = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后模拟一下客户获取产品的过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactoryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> ShapeFactory.createShape(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> ShapeFactory.createShape(<span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">        rectangle.draw();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">oval</span> <span class="operator">=</span> ShapeFactory.createShape(<span class="string">&quot;椭圆形&quot;</span>);</span><br><span class="line">        oval.draw();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">triangle</span> <span class="operator">=</span> ShapeFactory.createShape(<span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">        triangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果达到了我们的预期：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绘制圆形</span><br><span class="line">绘制矩形</span><br><span class="line">绘制椭圆形</span><br><span class="line">绘制三角形</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>但是在上面的 的简单工程模式中你们有没有发现它解耦了但是没完全解耦，因为我每增加一个产品然后就要在工厂的switch里面去添加一个分支，耦合度似乎有点高。而工厂方法模式就将生产产品本身交给一个新的工厂，这样客户想要一个产品只需要知道产品的名字就行了。</p><p>我们产品还是不变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oval</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制椭圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂的定义改变一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    Shape <span class="title function_">createShape</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TriangleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OvalFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Oval</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是客户使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactoryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">circleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> circleFactory.createShape();</span><br><span class="line">        circle.draw();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">ovalFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OvalFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">oval</span> <span class="operator">=</span> ovalFactory.createShape();</span><br><span class="line">        oval.draw();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">rectangleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> rectangleFactory.createShape();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">triangleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TriangleFactory</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">triangle</span> <span class="operator">=</span> triangleFactory.createShape();</span><br><span class="line">        triangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到工厂和产品达到了一定程度的解耦，客户只需要知道产品的名字就可以了。但是每件产品都对应一个工厂，上千上万件产品那工厂的数量不起飞了。所以就有了抽象工厂模式：</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂和工厂方法的不同在于，工厂方法一个工厂只能生产一个具体的产品。而抽象工厂一个工厂能生产一组类型相同的产品。只有新增类型的产品时才会增加工厂。</p><p>这里我们再举一个例子，有手机，平板，电脑等几系列产品，然后有小米，苹果，华为等几个生产这些产品的工厂。用工厂方法模式肯定不行，工厂太多了。</p><p>我们来看看抽象工厂，先定义一系列的产品：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPhone</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">playPhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPad</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">playPad</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IComputer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">playComputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplePhone</span> <span class="keyword">implements</span> <span class="title class_">IPhone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果手机欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplePad</span> <span class="keyword">implements</span> <span class="title class_">IPad</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPad</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果Pad欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleComputer</span> <span class="keyword">implements</span> <span class="title class_">IComputer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果电脑欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title class_">IPhone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPad</span> <span class="keyword">implements</span> <span class="title class_">IPad</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPad</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为Pad欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiComputer</span> <span class="keyword">implements</span> <span class="title class_">IComputer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为电脑欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title class_">IPhone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiPad</span> <span class="keyword">implements</span> <span class="title class_">IPad</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playPad</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米Pad欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiComputer</span> <span class="keyword">implements</span> <span class="title class_">IComputer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米电脑欢迎您~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义工厂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    IPhone <span class="title function_">createPhone</span><span class="params">()</span>;</span><br><span class="line">    IPad <span class="title function_">createPad</span><span class="params">()</span>;</span><br><span class="line">    IComputer <span class="title function_">createComputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPhone <span class="title function_">createPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplePhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPad <span class="title function_">createPad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplePad</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IComputer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPhone <span class="title function_">createPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPad <span class="title function_">createPad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiPad</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IComputer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HuaweiComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPhone <span class="title function_">createPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPhone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPad <span class="title function_">createPad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiPad</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IComputer <span class="title function_">createComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XiaomiComputer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后模拟客户：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">huaweiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuaweiFactory</span>();</span><br><span class="line">        <span class="type">IPhone</span> <span class="variable">huaweiPhone</span> <span class="operator">=</span> huaweiFactory.createPhone();</span><br><span class="line">        <span class="type">IPad</span> <span class="variable">huaweiPad</span> <span class="operator">=</span> huaweiFactory.createPad();</span><br><span class="line">        <span class="type">IComputer</span> <span class="variable">huaweiComputer</span> <span class="operator">=</span> huaweiFactory.createComputer();</span><br><span class="line">        huaweiPhone.playPhone();</span><br><span class="line">        huaweiPad.playPad();</span><br><span class="line">        huaweiComputer.playComputer();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">IPhone</span> <span class="variable">applePhone</span> <span class="operator">=</span> appleFactory.createPhone();</span><br><span class="line">        <span class="type">IPad</span> <span class="variable">applePad</span> <span class="operator">=</span> appleFactory.createPad();</span><br><span class="line">        <span class="type">IComputer</span> <span class="variable">appleComputer</span> <span class="operator">=</span> appleFactory.createComputer();</span><br><span class="line">        applePhone.playPhone();</span><br><span class="line">        applePad.playPad();</span><br><span class="line">        appleComputer.playComputer();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">xiaomiFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaomiFactory</span>();</span><br><span class="line">        <span class="type">IPhone</span> <span class="variable">xiaomiPhone</span> <span class="operator">=</span> xiaomiFactory.createPhone();</span><br><span class="line">        <span class="type">IPad</span> <span class="variable">xiaomiPad</span> <span class="operator">=</span> xiaomiFactory.createPad();</span><br><span class="line">        <span class="type">IComputer</span> <span class="variable">xiaomiComputer</span> <span class="operator">=</span> xiaomiFactory.createComputer();</span><br><span class="line">        xiaomiPhone.playPhone();</span><br><span class="line">        xiaomiPad.playPad();</span><br><span class="line">        xiaomiComputer.playComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">华为手机欢迎您~</span><br><span class="line">华为Pad欢迎您~</span><br><span class="line">华为电脑欢迎您~</span><br><span class="line">苹果手机欢迎您~</span><br><span class="line">苹果Pad欢迎您~</span><br><span class="line">苹果电脑欢迎您~</span><br><span class="line">小米手机欢迎您~</span><br><span class="line">小米Pad欢迎您~</span><br><span class="line">小米电脑欢迎您~</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到这里有9个产品，但只需要三个工厂。抽象工厂的精髓就在于一个工厂负责生产一系列的产品，而不是一个工厂生产一种产品从而减少工厂类也成功解耦了产品和客户。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。</p><p><strong>需要用建造者模式的场景</strong>：</p><ol><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类将创建过程封装在指挥者类中，而不再建造者类和客户类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ol><p><strong>角色</strong>：</p><p><strong>Builder（抽象建造者）</strong>：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p><p><strong>ConcreteBuilder（具体建造者）</strong>：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p><p><strong>Product（产品角色）</strong>：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p><p><strong>Director（指挥者）</strong>：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p><p>我们举个例子，比如造手机：</p><p>首先定义产品Product：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String gpu;</span><br><span class="line">    <span class="keyword">private</span> String battery;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBattery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> battery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBattery</span><span class="params">(String battery)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.battery = battery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCamera</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCamera</span><span class="params">(String camera)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.camera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CPU：&quot;</span> + cpu + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;GPU：&quot;</span> + gpu + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Camera：&quot;</span> + camera + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Screen：&quot;</span> + screen + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Battery：&quot;</span> + battery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setBattery</span><span class="params">(String battery)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setCamera</span><span class="params">(String camera)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setGPU</span><span class="params">(String gpu)</span>;</span><br><span class="line"></span><br><span class="line">    Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建ConcreteBuilder具体建造者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">        phone.setScreen(screen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        phone.setCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBattery</span><span class="params">(String battery)</span> &#123;</span><br><span class="line">        phone.setBattery(battery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCamera</span><span class="params">(String camera)</span> &#123;</span><br><span class="line">        phone.setCamera(camera);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGPU</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">        phone.setGpu(gpu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建Director（指挥者）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    Phone <span class="title function_">direct</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        builder.setScreen(<span class="string">&quot;6.7英寸 120hz&quot;</span>);</span><br><span class="line">        builder.setCpu(<span class="string">&quot;A16&quot;</span>);</span><br><span class="line">        builder.setGPU(<span class="string">&quot;5核&quot;</span>);</span><br><span class="line">        builder.setBattery(<span class="string">&quot;20w 3279mh&quot;</span>);</span><br><span class="line">        builder.setCamera(<span class="string">&quot;4800万像素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> director.direct(<span class="keyword">new</span> <span class="title class_">PhoneBuilder</span>());</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU：A16</span><br><span class="line">GPU：5核</span><br><span class="line">Camera：4800万像素</span><br><span class="line">Screen：6.7英寸 120hz</span><br><span class="line">Battery：20w 3279mh</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这就是建造者模式的全部步骤。</p><p>在日常使用中，如果不需要多类型的Builder，Builder更多是作为产品的内部类，还是拿上面的例子，改一下Product，将具体的Builder作为内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String gpu;</span><br><span class="line">    <span class="keyword">private</span> String battery;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBattery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> battery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBattery</span><span class="params">(String battery)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.battery = battery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCamera</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCamera</span><span class="params">(String camera)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.camera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">            phone.setScreen(screen);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            phone.setCpu(cpu);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setBattery</span><span class="params">(String battery)</span> &#123;</span><br><span class="line">            phone.setBattery(battery);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setCamera</span><span class="params">(String camera)</span> &#123;</span><br><span class="line">            phone.setCamera(camera);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setGPU</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">            phone.setGpu(gpu);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> phone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CPU：&quot;</span> + cpu + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;GPU：&quot;</span> + gpu + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Camera：&quot;</span> + camera + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Screen：&quot;</span> + screen + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;Battery：&quot;</span> + battery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端就直接优雅地链式调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.Builder()</span><br><span class="line">                .setScreen(<span class="string">&quot;6.7英寸 120hz&quot;</span>)</span><br><span class="line">                .setCpu(<span class="string">&quot;A16&quot;</span>)</span><br><span class="line">                .setGPU(<span class="string">&quot;5核&quot;</span>)</span><br><span class="line">                .setBattery(<span class="string">&quot;20w 3279mh&quot;</span>)</span><br><span class="line">                .setCamera(<span class="string">&quot;4800万像素&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU：A16</span><br><span class="line">GPU：5核</span><br><span class="line">Camera：4800万像素</span><br><span class="line">Screen：6.7英寸 120hz</span><br><span class="line">Battery：20w 3279mh</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>与工厂模式不同的是，建造者模式更关注产品的内部构造，工厂模式更关注的是生产。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>定义</strong>：原型模式（Prototype）是指使用原型实例指定创建对象的种类，并且通过拷贝这个模型，创建新的对象</p><p>java中自带了克隆的方法，类实现Clonable接口，重写clone方法即可。但是java的clone方法对于基本的数据类型是深拷贝，对于引用数据类型的变量是浅拷贝，如果要实现深拷贝就必须一层一层去重写clone方法。</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="comment">//引用类型变量</span></span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">clone</span> <span class="operator">=</span> (User) user.clone();</span><br><span class="line">        clone.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        clone.age = <span class="number">14</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----基本数据类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name=&quot;</span>+user.name+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.name=&quot;</span>+clone.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.age=&quot;</span>+user.age+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.age=&quot;</span>+clone.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----引用类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.test=&quot;</span>+user.test+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.test=&quot;</span>+clone.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----基本数据类型是否相等--------</span><br><span class="line">user.name=王二,clone.name=张三</span><br><span class="line">user.age=13,clone.age=14</span><br><span class="line">-----引用类型是否相等--------</span><br><span class="line">user.test=prototype.Test@3feba861,clone.test=prototype.Test@3feba861</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，基本数据类型是深拷贝，引用类型是浅拷贝，地址没变。假如我改变了clone的test属性那原型的test属性肯定也会改变，这不是原型模式。</p><p>而Test类要实现深拷贝就必须实现Cloneable接口，然后User类重写clone方法将test类克隆：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="comment">//引用类型变量</span></span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">clone</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        clone.test = (Test) test.clone();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">clone</span> <span class="operator">=</span> (User) user.clone();</span><br><span class="line">        clone.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        clone.age = <span class="number">14</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----基本数据类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name=&quot;</span>+user.name+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.name=&quot;</span>+clone.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.age=&quot;</span>+user.age+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.age=&quot;</span>+clone.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----引用类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.test=&quot;</span>+user.test+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;clone.test=&quot;</span>+clone.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----基本数据类型是否相等--------</span><br><span class="line">user.name=王二,clone.name=张三</span><br><span class="line">user.age=13,clone.age=14</span><br><span class="line">-----引用类型是否相等--------</span><br><span class="line">user.test=prototype.Test@3feba861,clone.test=prototype.Test@5b480cf9</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，test变量地址变了，不是指向的同一个对象。这就实现了标准的克隆。</p><p>但是这里就有一个问题了，假如我有很多个引用类型的变量，引用类型变量里面还有引用类型变量，那我要实现深拷贝就得一个一个类地去修改，麻烦不说还容易漏掉。而且每次都去修改原型类侵入性有点大，不符合”开闭原则“。</p><p>那么怎么办呢，最简单的一种方式就是序列化和反序列化，怎么做？往下看：</p><p>我们只用重写克隆体的clone方法，然后每个引用类型的类要实现Serializable接口才能序列化。然后序列化将其写入文件，再序列化读出文件，这样他们肯定不是指向同一个地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span>  <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>,Serializable &#123;</span><br><span class="line">    <span class="comment">//基本数据类型变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="comment">//引用类型变量</span></span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">User</span> <span class="variable">clone</span> <span class="operator">=</span> (User) user.clone();</span><br><span class="line">        clone.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        clone.age = <span class="number">14</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----基本数据类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name=&quot;</span> + user.name + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;clone.name=&quot;</span> + clone.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.age=&quot;</span> + user.age + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;clone.age=&quot;</span> + clone.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----引用类型是否相等--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.test=&quot;</span> + user.test + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;clone.test=&quot;</span> + clone.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----基本数据类型是否相等--------</span><br><span class="line">user.name=王二,clone.name=张三</span><br><span class="line">user.age=13,clone.age=14</span><br><span class="line">-----引用类型是否相等--------</span><br><span class="line">user.test=prototype.Test@4bf558aa,clone.test=prototype.Test@7dc5e7b4</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>同样实现了深拷贝，相比第一种方法，这种方法代码侵入性更小，更推荐。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>定义</strong>：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><p><strong>角色</strong>：</p><p><strong>Target目标角色</strong>：该角色定义把其他类转化为何种接口</p><p><strong>Adaptee源角色</strong>：想把谁转化为目标角色，谁就是源角色，是已经存在的，运行良好的接口。</p><p><strong>Adaptor适配器角色</strong>：适配器模式的核心角色，其他两个角色都是已经存在的，只有这个角色需要新创建，将源角色转化为目标角色。通过类继承或类关联的方式。</p><p>举个例子，原本A类有过滤词汇里面脏话的功能，现在新添加了一个新地B类有过滤词汇里面政治敏感的功能，现在要两个功能一起用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老的类，就是adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitive</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">filterDirty</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理脏话词汇......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSensitive</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理政治敏感词汇.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构建适配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象公共的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配老的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ASensitive</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASensitive</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(ASensitive adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.filterDirty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试一起使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//添加到一个集合里面</span></span><br><span class="line">        ArrayList&lt;Target&gt; targets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">oldFeature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">ASensitive</span>());</span><br><span class="line">        <span class="type">Target</span> <span class="variable">newFeature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitive</span>();</span><br><span class="line">        targets.add(oldFeature);</span><br><span class="line">        targets.add(newFeature);</span><br><span class="line"><span class="comment">//这里就模拟了老的功能和新功能一起使用的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Target target : targets) &#123;</span><br><span class="line">            target.filter();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理脏话词汇......</span><br><span class="line">处理政治敏感词汇.....</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>上面是适配对象，适配类的话，直接继承即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">ASensitive</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.filterDirty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端测试，区别就在于少了一个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//添加到一个集合里面</span></span><br><span class="line">        ArrayList&lt;Target&gt; targets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">oldFeature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">newFeature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitive</span>();</span><br><span class="line">        targets.add(oldFeature);</span><br><span class="line">        targets.add(newFeature);</span><br><span class="line"><span class="comment">//这里就模拟了老的功能和新功能一起使用的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Target target : targets) &#123;</span><br><span class="line">            target.filter();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理脏话词汇......</span><br><span class="line">处理政治敏感词汇.....</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p><strong>定义</strong>：装饰模式就是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象地功能。他是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><p><strong>角色</strong>：</p><ol><li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li><li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li><li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li><li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li></ol><p>这里举个例子，就拿图形来说吧。</p><p>定义抽象构件（Component）角色，Shape：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构件（Concrete Component）角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oval</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;椭圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰（Decorator）角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShapeDecorator</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰（Concrete Decorator）角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Black</span> <span class="keyword">extends</span> <span class="title class_">ShapeDecorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Black</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">extends</span> <span class="title class_">ShapeDecorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Blue</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stroke</span> <span class="keyword">extends</span> <span class="title class_">ShapeDecorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stroke</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;描边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//黑色有描边的圆形</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle = <span class="keyword">new</span> <span class="title class_">Black</span>(circle);</span><br><span class="line">        circle = <span class="keyword">new</span> <span class="title class_">Stroke</span>(circle);</span><br><span class="line">        circle.draw();</span><br><span class="line">System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//蓝色的椭圆</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">oval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Oval</span>();</span><br><span class="line">        oval = <span class="keyword">new</span> <span class="title class_">Blue</span>(oval);</span><br><span class="line">        oval.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一层一层去套娃加功能装饰，输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">圆形</span><br><span class="line">黑色</span><br><span class="line">描边</span><br><span class="line">------------------</span><br><span class="line">椭圆形</span><br><span class="line">蓝色</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>到这里可能会有人会疑问，这装饰模式怎么和适配器有点像啊？</p><p>确实，二者实现结构上有点相似，但是各自实现的效果不同。适配器模式是将原有接口转变成另外一个接口，达成新接口适配老接口从而新老接口都能以一种方式使用也就是复用的目的。而装饰模式相反不改变原有接口而是保留原有接口增强原有接口的功能。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>定义：为其他对象提供一种代理以控制对这个对象的访问</p><p>代理意在客户和对象之间做中介的作用。生活中也不乏这些例子。比如客户和火车站之间通过中介买票。租房子通过中介联系房东等等。</p><p>代理模式总共就三个角色，包括<strong>抽象主题，委托者和代理者</strong>。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理者在编译时就能确定的称为静态代理。</p><p>举例，客户找中介租房子的例子。</p><p><strong>抽象主题</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>委托者</strong>，也就是被代理者房东：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Landlord</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东租出房子，1000元/月。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代理者</strong>，也就是中介：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span>&#123;</span><br><span class="line">    <span class="comment">//代理者拥有委托者的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Landlord</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理开始&quot;</span>);</span><br><span class="line">        mediator.rentHouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理者</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyMediator</span>();</span><br><span class="line">        <span class="comment">//通过代理者找房子</span></span><br><span class="line">        proxy.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中介代理开始找房子.....</span><br><span class="line">房东租出房子，1000元/月。</span><br><span class="line">代理结束。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>到这里可能又有人会有疑问，我直接调用委托者的方法不行吗？意思就是我直接去找这个房东不行吗？</p><p>你知道有这个房东的存在你当然可以直接去找他呀，还省了一笔中介费。但是现在是你不知道这个房东的联系方式，你也不想到处去找，去跑，你直接把你的要求告诉了中介，中介替你去找。这就是代理的作用。客户不需要关注委托者是谁，只需关注需求和功能。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理者在运行时才能确定的称为动态代理。</p><p>Java为开发者提供了InvocationHandler,实现该接口重写其invoke 方法即可实现动态代理。</p><p>还是拿刚刚的例子，我们现在不知道ProxyMediator的存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托者（房东）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Landlord</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rentHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东租出房子，1000元/月。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//动态创建代理者（反射）</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">proxy</span> <span class="operator">=</span> (Mediator) Proxy.newProxyInstance(Mediator.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Mediator.class&#125;, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;动态代理开始&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Landlord</span>());</span><br><span class="line">                System.out.println(<span class="string">&quot;动态代理结束&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//代理开始</span></span><br><span class="line">        proxy.rentHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动态代理开始</span><br><span class="line">房东租出房子，1000元/月。</span><br><span class="line">动态代理结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>当我们不知道代理者的时候就可以使用动态代理。</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。定义了一个高层接口，让子系统更容易使用。</p><p>说白了其实就是对子系统的一个统一。比如拍照，假如我们没有手机这个系统，我们拍照要先启动照相机系统，按下快门调用照相机系统拍照，然后调用存储系统存储照片文件等等等等，涉及的子系统很多调用很麻烦。手机就相当于一个统一，将调子系统的功能都封装起来了，你只需按下拍照按钮即可。</p><p>现在我们就以这个为例子来写一下代码：</p><p>我们有两个子系统，分别是相机和存储：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Camera</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开摄像头....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭摄像头....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">focus</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;聚焦...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getHead</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检测人脸...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">picture</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拍出照片&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RQ527的帅照&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="title function_">askPermission</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;申请权限...&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">storePicture</span><span class="params">(String picture)</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;存储照片：&quot;</span>+picture);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用外观模式提供统一接口拍照简化客户端的调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Storage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">picture</span><span class="params">()</span>&#123;</span><br><span class="line">        camera.open();</span><br><span class="line">        camera.focus();</span><br><span class="line">        camera.getHead();</span><br><span class="line">        <span class="type">String</span> <span class="variable">picture</span> <span class="operator">=</span> camera.picture();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> storage.askPermission();</span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            storage.storePicture(picture);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;照片存储失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        camera.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.picture();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开摄像头....</span><br><span class="line">聚焦...</span><br><span class="line">检测人脸...</span><br><span class="line">拍出照片</span><br><span class="line">申请权限...</span><br><span class="line">存储照片：RQ527的帅照</span><br><span class="line">关闭摄像头....</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到外观模式统一了之后客户端调用是非常方便的。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式（Bridge）能将抽象与实现分离，使二者可以各自单独变化而不受对方约束，使用时再将它们组合起来，就像架设桥梁一样连接它们的功能，如此降低了抽象与实现这两个可变维度的耦合度，以保证系统的可扩展性。</p><p>桥接模式的核心是将抽象和实现分离。在实现过程中，我们可以通过抽象类或者接口来定义抽象部分，通过另一个抽象类或者接口来定义实现部分。然后，我们可以通过组合的方式将两个部分组合起来，使得它们可以独立地变化。</p><p>我们举个例子，假如我们现在设计一个西游记地游戏。</p><p>首先定义接口武器，统一方法attack：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义另外一个抽象类角色，拥有实现类武器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Weapon weapon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Role</span><span class="params">(Weapon weapon)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weapon = weapon;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个武器的实现类金箍棒和钉耙：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JinGuBang</span> <span class="keyword">implements</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃俺老孙一棒！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DingPa</span> <span class="keyword">implements</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃俺老猪一耙！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是角色的实现类，悟空和八戒：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WuKong</span> <span class="keyword">extends</span> <span class="title class_">Role</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WuKong</span><span class="params">(Weapon weapon)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(weapon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        weapon.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaJie</span> <span class="keyword">extends</span> <span class="title class_">Role</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaJie</span><span class="params">(Weapon weapon)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(weapon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        weapon.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Role</span> <span class="variable">wuKong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WuKong</span>(<span class="keyword">new</span> <span class="title class_">JinGuBang</span>());</span><br><span class="line">        wuKong.attack();</span><br><span class="line"></span><br><span class="line">        <span class="type">Role</span> <span class="variable">baJie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaJie</span>(<span class="keyword">new</span> <span class="title class_">DingPa</span>());</span><br><span class="line">        baJie.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">吃俺老孙一棒！！！</span><br><span class="line">吃俺老猪一耙！！！</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>其实可以看到两个抽象类Role和Weapon，通过组合的方式Role拥有一个Weapon的实例，然后二者的实现类互不影响。这就是桥接模式的实现。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式(Composite Design Pattern)，将对象组合成树形结构表示整体-部分的层次结构，使得用户对每个单个对象和组合对象的使用具有一致性。</p><p>组合模式跟面向对象设计中的组合关系（通过组合来组装两个类），不同。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合。</p><p><strong>角色</strong>：</p><ol><li>Component 抽象根节点，为组合中的对象声明接口</li><li>Composite 定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作</li><li>Leaf 在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为</li></ol><p>举一个例子：请你设计表示一个学校的所有学院，所有学院下面所有的专业。</p><p>这属于树形结构，我们就可以使用组合模式。</p><p>首先定义Component 抽象根节点，根节点定义了添加删除结点和打印的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Composite枝干结点定义，枝干结点分别有University（大学）、College（学院），叶子结点（专业）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大学</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">University</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; colleges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">University</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        colleges.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        colleges.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>+name+<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Component component: colleges)&#123;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">College</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; professions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">College</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        professions.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        professions.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>+name+<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Component component: professions)&#123;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专业</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Profession</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Profession</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;叶子结点不支持插入操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;叶子结点不支持删除操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">University</span> <span class="variable">university</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">University</span>(<span class="string">&quot;重庆邮电大学&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">College</span> <span class="variable">college</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;计算机学院&quot;</span>);</span><br><span class="line">        college.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;计算机科学与技术专业&quot;</span>));</span><br><span class="line">        college.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;人工智能专业&quot;</span>));</span><br><span class="line">        college.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;网络工程专业&quot;</span>));</span><br><span class="line">        university.add(college);</span><br><span class="line"></span><br><span class="line">        <span class="type">College</span> <span class="variable">college1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;软件工程学院&quot;</span>);</span><br><span class="line">        college1.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;信息安全专业&quot;</span>));</span><br><span class="line">        college1.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;物联网工程专业&quot;</span>));</span><br><span class="line">        college1.add(<span class="keyword">new</span> <span class="title class_">Profession</span>(<span class="string">&quot;软件设计与开发专业&quot;</span>));</span><br><span class="line">        university.add(college1);</span><br><span class="line"></span><br><span class="line">        university.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------重庆邮电大学------------</span><br><span class="line">--------计算机学院------------</span><br><span class="line">计算机科学与技术专业</span><br><span class="line">人工智能专业</span><br><span class="line">网络工程专业</span><br><span class="line">--------软件工程学院------------</span><br><span class="line">信息安全专业</span><br><span class="line">物联网工程专业</span><br><span class="line">软件设计与开发专业</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，组合模式很好地描述了树形结构中部分和整体的关系，统一处理了一个结点中地多个对象。因为其数据结构要求是树形结构导致了他在日常开发中不是那么常用。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p><strong>定义</strong>：使用共享对象可有效地支持大量地细粒度对象。</p><p>“享”即共享，”元“即对象，就是共享对象地意思嘛。</p><p>适用于存在大量重复对象，但是重复创建销毁对象非常消耗资源的场景，通过共享池共享对象，达到对象共享，避免创建过多对象。享元对象中的字段可分为部分：内部状态（不随环境变化，可共享）；外部状态（随环境变化，不可共享）。</p><p><strong>角色</strong>：</p><ol><li>抽象享元（FlyWeight）：给出抽象接口，规定所有具体享元角色需要实现的方法</li><li>具体享元（ConcreteFlyWeight）：实现抽象享元所规定出的接口；存储内部状态</li><li>不共享具体享元（UnsharedConcreteFlyweight）：Flyweight接口使共享成为可能，但它并不强制共享。在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。</li><li>享元工厂（FlyWeightFactory）：创建和管理享元角色，保证享元对象可被共享；主要通过HashMap来实现。</li></ol><p>我们还是拿图形的那个例子，这次用享元模式优化对象地获取。</p><p>首先是FlyWeight，也就是我们抽象出的Shape：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color 外部状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String color)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的name其实就是内部状态不随外部环境变化，被创建时就确定了。color其实就是外部状态，随方法的调用而改变。</p><p>然后定义ConcreteFlyWeight，也就是Shape的实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我叫%s。我是%s的三角形。</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.printf(msg,name,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oval</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Oval</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我叫%s。我是%s的椭圆形。</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.printf(msg,name,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我叫%s。我是%s的矩形;</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.printf(msg,name,color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是FlyWeightFactory享元工厂，就是ShapeFactory：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String type,String name)</span>&#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> shapes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (shape==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;椭圆形&quot;</span>:</span><br><span class="line">                    <span class="type">Oval</span> <span class="variable">oval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Oval</span>(name);</span><br><span class="line">                    shapes.put(name,oval);</span><br><span class="line">                    <span class="keyword">return</span> oval;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;三角形&quot;</span>:</span><br><span class="line">                    <span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(name);</span><br><span class="line">                    shapes.put(name,triangle);</span><br><span class="line">                    <span class="keyword">return</span> triangle;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;矩形&quot;</span>:</span><br><span class="line">                    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(name);</span><br><span class="line">                    shapes.put(name,rectangle);</span><br><span class="line">                    <span class="keyword">return</span> rectangle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Factory可以写成单例模式，我们用Map模拟享元池，每次获取对象先判断享元池中是否存在，存在直接取出，不存在再创建。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;三角形&quot;</span>, <span class="string">&quot;阿三&quot;</span>);</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;三角形&quot;</span>, <span class="string">&quot;阿三&quot;</span>);</span><br><span class="line">        shape.draw(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        shape1.draw(<span class="string">&quot;蓝色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;两次取出的对象是否相等：&quot;</span>+(shape==shape1));</span><br><span class="line"></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;椭圆形&quot;</span>, <span class="string">&quot;阿圆&quot;</span>);</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;椭圆形&quot;</span>, <span class="string">&quot;阿圆&quot;</span>);</span><br><span class="line">        shape2.draw(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        shape3.draw(<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;两次取出的对象是否相等：&quot;</span>+(shape2==shape3));</span><br><span class="line"></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape4</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;矩形&quot;</span>, <span class="string">&quot;阿矩&quot;</span>);</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape5</span> <span class="operator">=</span> ShapeFactory.getShape(<span class="string">&quot;矩形&quot;</span>, <span class="string">&quot;阿正&quot;</span>);</span><br><span class="line">        shape4.draw(<span class="string">&quot;粉色&quot;</span>);</span><br><span class="line">        shape5.draw(<span class="string">&quot;紫色&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;两次取出的对象是否相等：&quot;</span>+(shape4==shape5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我叫阿三。我是红色的三角形。</span><br><span class="line">我叫阿三。我是蓝色的三角形。</span><br><span class="line">两次取出的对象是否相等：true</span><br><span class="line">我叫阿圆。我是黑色的椭圆形。</span><br><span class="line">我叫阿圆。我是白色的椭圆形。</span><br><span class="line">两次取出的对象是否相等：true</span><br><span class="line">我叫阿矩。我是粉色的矩形;</span><br><span class="line">我叫阿正。我是紫色的矩形;</span><br><span class="line">两次取出的对象是否相等：false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，固有属性相同的对象只有第一次获取的时候才被创建。color外部状态随外界变化而变化，name内部状态一直不变。这就达到了对象复用的效果。当然实际使用中内部状态不止name，外部状态也不止color，具体根据需求而定。</p><p>享元模式被广泛使用，诸如线程池，Integer对象地创建，在-127到128之间的对象已经创建好了，在这之外再重新new 的对象。</p><h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>定义</strong>：定义一组算法，将每个算法都封装起来，并且他们之间可以互换。</p><p><strong>角色</strong>：</p><ol><li><strong>上下文角色（context）</strong>：用来操作策略的上下文环境，屏蔽客户端或者高层模块对策略算法的直接访问，封装可能出现的变化。</li><li><strong>抽象策略角色（Strategy）</strong>：规定策略的算法或者行为</li><li><strong>具体策略角色（ConcreteStrategy）</strong>：具体策略的算法或者行为的实现</li></ol><p>我们以支付为例，支付的方式有支付宝支付，微信支付，银行卡支付。</p><p>抽象策略角色（Strategy），这里用Payment接口抽象支付行为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体策略角色（ConcreteStrategy）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支出&quot;</span> + amount + <span class="string">&quot;元。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankPay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银行卡支出&quot;</span> + amount + <span class="string">&quot;元。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支出&quot;</span> + amount + <span class="string">&quot;一万元。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上下文角色（context）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Payment payment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentStrategy</span><span class="params">(Payment payment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.payment = payment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        payment.pay(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">alipay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentStrategy</span>(<span class="keyword">new</span> <span class="title class_">AliPay</span>());</span><br><span class="line">        alipay.execute(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">WxPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentStrategy</span>(<span class="keyword">new</span> <span class="title class_">WechatPay</span>());</span><br><span class="line">        WxPay.execute(<span class="number">99999999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PaymentStrategy</span> <span class="variable">bankPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentStrategy</span>(<span class="keyword">new</span> <span class="title class_">BankPay</span>());</span><br><span class="line">        bankPay.execute(<span class="number">123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支付宝支出100000一万元。</span><br><span class="line">微信支出99999999元。</span><br><span class="line">银行卡支出123456789元。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>策略模式适合用于优化方法中大量的if-else语句，而且策略模式对算法和行为封装性更好更便于维护，安全性更高。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><strong>定义</strong>：一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p><p>模板在java中很好实现，就是抽象类和继承的运用。</p><p>我们这里用讲PPT作为例子。</p><p>首先抽象模板：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getSubject</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">talkEachOther</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isNeedTalk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speech</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                我叫%s，今天我要讲的主题是%s。</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.printf(msg,getName(),getSubject());</span><br><span class="line">        <span class="keyword">if</span> (isNeedTalk())&#123;</span><br><span class="line">            talkEachOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个模板方法speech，内部调用其他抽象方法作为模板调用，子类无需关心模板的实现，只需实现相应的步骤即可。还定义了一个子类可以选择是否重写的方法isNeedTalk用来决定是否调用talkEachOther方法，我们称这个函数为钩子函数。</p><p>具体的演讲者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhangSan</span> <span class="keyword">extends</span> <span class="title class_">Presenter</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isNeedTalk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZhangSan</span><span class="params">(<span class="type">boolean</span> isNeedTalk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isNeedTalk = isNeedTalk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;科技改变生活&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">talkEachOther</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同学们激烈当今前沿科技.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isNeedTalk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isNeedTalk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiSi</span> <span class="keyword">extends</span> <span class="title class_">Presenter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;人工智能&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">talkEachOther</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;同学们激烈讨论人工智能是否改变生活......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZhangSan</span> <span class="variable">zhangSan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZhangSan</span>(<span class="literal">false</span>);</span><br><span class="line">        zhangSan.speech();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">LiSi</span> <span class="variable">liSi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiSi</span>();</span><br><span class="line">        liSi.speech();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我叫张三，今天我要讲的主题是科技改变生活。</span><br><span class="line">-------------------------------</span><br><span class="line">我叫李四，今天我要讲的主题是人工智能。</span><br><span class="line">同学们激烈讨论人工智能是否改变生活......</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>在java的特性上实现模板方法模式是比较简单的，模板方法在日常开发中很常用，在一定程度上能减少代码量，提高代码复用性。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>定义</strong>：观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式主要有两个对象，主题（被观察者）和订阅者（观察者），这是一个一对多的关系，同一个主题可以有多个订阅者，当主题发生改变时，每个订阅者都能收到消息通知并执行对应的逻辑。</p><p>对于主题（被观察者）而言，需要提供注册、去注册、通知观察者的功能。</p><p>对于订阅者（观察者）而言，需要提供统一的接口让主题在通知时调用。</p><p>我们拿天气订阅来举例子。</p><p>首先抽象观察者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的观察者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WangEr</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;王二收到了天气更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WangWu</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;王五收到了天气更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象被观察者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeAllObservers</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被观察者提供添加、删除观察者的方法，通知观察者的方法。</p><p>天气主题（被观察者）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        observers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> observers.get(i);</span><br><span class="line">        <span class="keyword">if</span> (observer!=<span class="literal">null</span>)&#123;</span><br><span class="line">            observer.onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer:observers)&#123;</span><br><span class="line">            observer.onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWeather</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;天气更新，开始通知观察者....&quot;</span>);</span><br><span class="line">        notifyAllObserver();</span><br><span class="line">        System.out.println(<span class="string">&quot;通知完毕。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被观察者（天气）提供更新天气的方法，内部调用通知观察者的逻辑。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weather</span> <span class="variable">weather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weather</span>();</span><br><span class="line">        weather.addObserver(<span class="keyword">new</span> <span class="title class_">WangWu</span>());</span><br><span class="line">        weather.addObserver(<span class="keyword">new</span> <span class="title class_">WangEr</span>());</span><br><span class="line">        weather.addObserver(() -&gt; System.out.println(<span class="string">&quot;匿名用户收到天气更新。&quot;</span>));</span><br><span class="line">        weather.updateWeather();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天气更新，开始通知观察者....</span><br><span class="line">王五收到了天气更新</span><br><span class="line">王二收到了天气更新</span><br><span class="line">匿名用户收到天气更新。</span><br><span class="line">通知完毕。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>观察者模式降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。目标与观察者之间建立了一套触发机制。观察者模式精髓在于理解接口回调。</p><h3 id="迭代子模式"><a href="#迭代子模式" class="headerlink" title="迭代子模式"></a>迭代子模式</h3><p><strong>定义</strong>：迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。我们常见的集合有很多种类，其顶层数据存储和组织方式的不同导致了我们在对数据进行遍历的时候存在一些差异，迭代器模式就是通过实现某种统一的方式来实现对不同的集合的遍历，同时又不暴露出其底层的数据存储和组织方式。</p><p>常规的for循遍历对于集合来说耦合度太大，不便于维护，假如集合被修改，for循环也需要更改。</p><p><strong>角色</strong>：</p><ul><li>迭代器角色（Iterator）: 负责定义访问和遍历元素的接口。</li><li>具体迭代器角色（Concrete Iterator）：实现迭代器接口，并要记录遍历中的当前位置。</li><li>容器角色(Container): 负责提供创建具体迭代器角色的接口。</li><li>具体容器角色（Concrete Container）：实现创建具体迭代器角色的接口， 这个具体迭代器角色与该容器的结构相关。</li></ul><p>下面我们来写一写我们自己的迭代器。</p><p>抽象迭代器（Iterator）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">first</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器有四个方法，判断是否有下一个元素，获取第一个元素、下一个元素、前一个元素。</p><p>具体的迭代器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyIterator</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index != list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index!=<span class="number">0</span>) <span class="keyword">return</span> list.get(index-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index&lt;list.size()) <span class="keyword">return</span> list.get(++index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对四个方法具体实现，内部维护一个list和index，对外统一获取元素的方法。</p><p>抽象容器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T data)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(T data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法，添加、删除元素，获取迭代器。</p><p>具体容器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Container</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>&lt;T&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一个数&quot;</span> + iterator.first());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;之前的数&quot;</span> + iterator.previous());</span><br><span class="line">            System.out.println(<span class="string">&quot;下一个数&quot;</span> + iterator.next());</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个数1</span><br><span class="line">--------------------------</span><br><span class="line">之前的数null</span><br><span class="line">下一个数5</span><br><span class="line">-----------------------------</span><br><span class="line">之前的数1</span><br><span class="line">下一个数6</span><br><span class="line">-----------------------------</span><br><span class="line">之前的数5</span><br><span class="line">下一个数8</span><br><span class="line">-----------------------------</span><br><span class="line">之前的数6</span><br><span class="line">下一个数4</span><br><span class="line">-----------------------------</span><br><span class="line">之前的数8</span><br><span class="line">下一个数2</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>实现了我们统一迭代的需求。这里只是实例迭代子模式的使用，实际上我们不用自己去封装，像List，Map等java提供了封装好的Iterator。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><strong>定义</strong>：<strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p><p>一般责任链是用链表的形式将每个处理者串起来，我比较喜欢用集合，然后一条链将他们串起来，这也是Okhttp责任链的做法。</p><p><strong>角色</strong>：</p><ul><li><strong>抽象责任链（Chain）</strong>：抽象责任链的传递方法，提供获取请求的接口。</li><li><strong>具体责任链</strong>：实现抽象责任链，串起每个处理者。</li><li><strong>抽象处理者（Handler）角色：</strong>定义一个处理请求的接口，包含抽象处理方法。</li><li><strong>具体处理者（Concrete Handler）角色：</strong>实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li><strong>客户类（Client）角色：</strong>创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><p>我们这里举个例子，发个消息然后让每个处理者决定是否处理。</p><p>首先抽象责任链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Chain</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getRequest</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供两个方法，一个是获取数据，一个是将请求传递。</p><p>抽象处理者（Handler）角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Chain&lt;T&gt; chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>责任链的具体实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealChain</span> <span class="keyword">implements</span> <span class="title class_">Chain</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Handler&lt;Message&gt;&gt; interceptors;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealChain</span><span class="params">(List&lt;Handler&lt;Message&gt;&gt; interceptors, <span class="type">int</span> index, Message message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">RealChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealChain</span>(interceptors, index + <span class="number">1</span>, message);</span><br><span class="line">        interceptors.get(index).handle(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拥有三个属性，处理者集合，当前处理者索引和请求体message。process将每个处理者串起来。</p><p>模拟具体的处理者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Chain&lt;Message&gt; chain)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">request</span> <span class="operator">=</span> chain.getRequest();</span><br><span class="line">        System.out.println(<span class="string">&quot;传递到处理者1，内容：&quot;</span> + request.getContent() + <span class="string">&quot;，等级：&quot;</span> + request.getLevel());</span><br><span class="line">        request.setContent(<span class="string">&quot;我处理者1处理了消息。&quot;</span>);</span><br><span class="line">        chain.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;Message&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Chain&lt;Message&gt; chain)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">request</span> <span class="operator">=</span> chain.getRequest();</span><br><span class="line">        System.out.println(<span class="string">&quot;传递到处理者2，内容：&quot;</span> + request.getContent() + <span class="string">&quot;，等级：&quot;</span> + request.getLevel());</span><br><span class="line">        request.setContent(<span class="string">&quot;我处理者2处理了消息。&quot;</span>);</span><br><span class="line">        chain.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler3</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;Message&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Chain&lt;Message&gt; chain)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">request</span> <span class="operator">=</span> chain.getRequest();</span><br><span class="line">        System.out.println(<span class="string">&quot;传递到处理者3，内容：&quot;</span> + request.getContent() + <span class="string">&quot;，等级：&quot;</span> + request.getLevel());</span><br><span class="line">        request.setContent(<span class="string">&quot;我处理者3处理了消息。&quot;</span>);</span><br><span class="line">        chain.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chain.process();即表示将请求传递，我这里并没有拦截，实际开发中可以自行判断是否拦截。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Handler&lt;Message&gt;&gt; chains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        chains.add(<span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>());</span><br><span class="line">        chains.add(<span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>());</span><br><span class="line">        chains.add(<span class="keyword">new</span> <span class="title class_">ConcreteHandler3</span>());</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setContent(<span class="string">&quot;我是消息的具体内容。&quot;</span>);</span><br><span class="line">        message.setLevel(<span class="number">99</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RealChain</span>(chains, <span class="number">0</span>, message).process();</span><br><span class="line">        System.out.println(<span class="string">&quot;责任链传递完毕，message：内容：&quot;</span> + message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传递到处理者1，内容：我是消息的具体内容。，等级：99</span><br><span class="line">传递到处理者2，内容：我处理者1处理了消息。，等级：99</span><br><span class="line">传递到处理者3，内容：我处理者2处理了消息。，等级：99</span><br><span class="line">责任链传递完毕，message：内容：我处理者3处理了消息。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>责任链适合用于多流程控制，权限的控制。更有助于优化if-else语句，方便维护和扩展。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><strong>定义</strong>：命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p><strong>角色</strong>：</p><ul><li><strong>抽象接受者（Receiver）</strong>：命令接受者的抽象，提供执行的方法。</li><li><strong>具体接受者（ConcreteReceiever）</strong>：抽象接受者的具体实现，内部实现命令执行的方法。</li><li><strong>抽象命令角色（Command）</strong>：下发命令的角色，执行的命令在这里声明。</li><li><strong>具体命令角色（ConcreteCommand）</strong>：命令角色的具体实现，持有Receiver，收到命令后下发给每个Receiver</li><li><strong>调用者角色（Invoker）</strong>：命令的发动者和调用者。</li></ul><p>我们用代码简单实现一下：</p><p>首先是抽象接受者和命令者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的接受者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteReceiver1</span> <span class="keyword">implements</span> <span class="title class_">Receiver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者1执行命令。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteReceiver2</span> <span class="keyword">implements</span> <span class="title class_">Receiver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者2执行命令。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteReceiver3</span> <span class="keyword">implements</span> <span class="title class_">Receiver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者3执行命令。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的命令角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Receiver&gt; receivers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(List&lt;Receiver&gt; receivers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receivers = receivers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Receiver receiver : receivers) &#123;</span><br><span class="line">            receiver.action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令的发动者和调用者，Invoker：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Receiver&gt; receivers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        receivers.add(<span class="keyword">new</span> <span class="title class_">ConcreteReceiver1</span>());</span><br><span class="line">        receivers.add(<span class="keyword">new</span> <span class="title class_">ConcreteReceiver2</span>());</span><br><span class="line">        receivers.add(<span class="keyword">new</span> <span class="title class_">ConcreteReceiver3</span>());</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(<span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receivers));</span><br><span class="line">        invoker.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收者1执行命令。</span><br><span class="line">接收者2执行命令。</span><br><span class="line">接收者3执行命令。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p><strong>定义</strong>： 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态. 这样以后就可将该对象回复到原先保存的状态。</p><p><strong>角色</strong>：</p><ul><li><strong>Originator 发起人角色</strong>: 记录当前时刻的内部状态, 负责定义哪些属于备份范围的状态, 负责创建和恢复备忘录数据</li><li><strong>Memento 备忘录角色</strong>: 负责存储 发起人对象的内部状态, 在需要的时候提供发起人需要的内部状态</li><li><strong>Caretaker 备忘录管理员角色</strong>: 对备忘录进行管理、保存和提供备忘录.</li></ul><p>还是老规矩写个demo：</p><p>Memento 备忘录角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Originator 发起人角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Caretaker 备忘录管理员角色：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">        originator.setState(<span class="string">&quot;状态1&quot;</span>);</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">        originator.setState(<span class="string">&quot;状态2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态之前，状态：&quot;</span> + originator.getState());</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态之后，状态：&quot;</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">恢复状态之前，状态：状态2</span><br><span class="line">恢复状态之后，状态：状态1</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>备忘录模式用的比较多，像游戏存档，文档回退等等都用到了备忘录模式，demo实现的比较简单，篇幅原因真正的实现细节这里就不多说了。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p><strong>定义</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><p><strong>角色</strong>：</p><ul><li><strong>State</strong>：抽象状态类或者接口，其中的方法表示对应状态下的行为。</li><li><strong>StateA、StateB</strong>：<strong>State</strong>的具体实现类，以实现对应状态下具体的行为。</li><li><strong>Context</strong>：维护当前对象所对应的状态。</li></ul><p>我们拿出租车举例子。</p><p>首先抽象State：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是出租车的两个状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoPassengerState</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空车，待接客。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasPassengerState</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有客，不接单。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出租车Context：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaxiContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaxiContext</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receivePassenger</span><span class="params">()</span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">HasPassengerState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeCarry</span><span class="params">()</span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">NoPassengerState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到订单...&quot;</span>);</span><br><span class="line">        state.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TaxiContext</span> <span class="variable">taxiContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaxiContext</span>(<span class="keyword">new</span> <span class="title class_">NoPassengerState</span>());</span><br><span class="line">        taxiContext.receiveOrder();</span><br><span class="line">        taxiContext.receivePassenger();</span><br><span class="line">        taxiContext.receiveOrder();</span><br><span class="line">        taxiContext.completeCarry();</span><br><span class="line">        taxiContext.receiveOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">收到订单...</span><br><span class="line">空车，待接客。</span><br><span class="line">----------------------</span><br><span class="line">收到订单...</span><br><span class="line">有客，不接单。</span><br><span class="line">----------------------</span><br><span class="line">收到订单...</span><br><span class="line">空车，待接客。</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p><strong>定义</strong>：封装一些作用于某种数据结构中的各元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p><p><strong>角色</strong>：</p><ul><li>元素类（Element）：是一个抽象类或者接口，里面会定义一个接收(accept)访问者的抽象方法,使得每一个元素能被访问者访问。</li><li>具体元素（ConcreteElement）：继承或实现元素类，实现接收方法。</li><li>访问者（Visitor）：一般是一个抽象类，里面涵括了可以访问每个具体元素的方法，使得访问者可以访问每个具体元素（一般有几个具体元素就会有几个这个样的方法，这些方法的方法名相同参数不同，参数都是具体元素，所以一般来说具体元素的种类应该是比较固定的）。</li><li>具体访问者（ConcreteVisitor）：访问者的具体实现</li></ul><p>模版代码：</p><p>元素类和具体元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Element</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title class_">Element</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteElement1</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title class_">Element</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteElement2</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问者和具体访问者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElement1 element)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElement2 element2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElement1 element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问到元素1，信息：&quot;</span>+element.content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ConcreteElement2 element)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问到元素2，信息：&quot;</span>+element.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteElement1</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElement1</span>(<span class="string">&quot;元素1的内容&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteElement2</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteElement2</span>(<span class="string">&quot;元素2的内容&quot;</span>);</span><br><span class="line">        element1.accept(<span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>());</span><br><span class="line">        element2.accept(<span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问到元素1，信息：元素1的内容</span><br><span class="line">访问到元素2，信息：元素2的内容</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>访问者模式适合数据结构稳定，作用于数据结构的操作经常变化的时候，对于新增的元素会非常困难，实现起来也比较复杂。</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><strong>定义</strong>：用一个中介者对象来封装一系列的对象交互。中介者使得各对象不需要显式地相互引用，从而使其松散耦合，而且可以独立地改变它们之间的交互。</p><p><strong>角色</strong>：</p><ul><li><strong>Mediator</strong>：中介者定义一个接口用于与各同事（Colleague）对象通信。</li><li><strong>ConcreteMediator</strong>：具体中介者通过协调各同事对象实现协作行为，了解并维护它的各个同事。</li><li><strong>Colleague</strong>：抽象同事类。</li><li><strong>Colleagueclass</strong>：具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。</li></ul><p>模版代码，我们以同事之间发消息为例：</p><p>Colleague和Mediator定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">contact</span><span class="params">(String content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String content, Colleague colleague)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同事A和同事B的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColleagueA</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColleagueA</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contact</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        mediator.notify(content,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColleagueB</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColleagueB</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contact</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        mediator.notify(content,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体中介者的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    ColleagueA colleagueA;</span><br><span class="line">    ColleagueB colleagueB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ColleagueA <span class="title function_">getColleagueA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colleagueA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueA</span><span class="params">(ColleagueA colleagueA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleagueA = colleagueA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ColleagueB <span class="title function_">getColleagueB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colleagueB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueB</span><span class="params">(ColleagueB colleagueB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleagueB = colleagueB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String content, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleagueA) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同事B收到消息A的消息：&quot;</span> + content);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague == colleagueB) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;同事A收到消息B的消息：&quot;</span> + content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line">        <span class="type">ColleagueA</span> <span class="variable">colleagueA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColleagueA</span>(mediator);</span><br><span class="line">        <span class="type">ColleagueB</span> <span class="variable">colleagueB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColleagueB</span>(mediator);</span><br><span class="line">        mediator.setColleagueA(colleagueA);</span><br><span class="line">        mediator.setColleagueB(colleagueB);</span><br><span class="line">        colleagueA.contact(<span class="string">&quot;同事A发的消息&quot;</span>);</span><br><span class="line">        colleagueB.contact(<span class="string">&quot;同事B发的消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同事B收到消息A的消息：同事A发的消息</span><br><span class="line">同事A收到消息B的消息：同事B发的消息</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>中介者模式和代理模式有点类似，主要区别在于中介者模式是一对多的关系，解耦的是多个复杂对象之间的复杂交互，代理模式在于一对一，委托者和代理者是一一对应的。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><strong>定义</strong>：指给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。</p><p><strong>角色</strong>：</p><ul><li><strong>抽象表达式</strong>(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。</li><li><strong>终结符表达式</strong>(Terminal Expression)角色：实现了抽象表达式角色所要求的接口，主要是一个解释()方法。</li><li><strong>非终结符表达式</strong>(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式。</li><li><strong>环境</strong>(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值。</li></ul><p>我们以解释java语句为例：</p><p>首先抽象表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">explain</span><span class="params">(String context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终结符表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TerminalExpression</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">explain</span><span class="params">(String context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.contains(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非终结者表达式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression expression1;</span><br><span class="line">    <span class="keyword">private</span> Expression expression2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">explain</span><span class="params">(String context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.explain(context) &amp;&amp; expression2.explain(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression expression1;</span><br><span class="line">    <span class="keyword">private</span> Expression expression2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">explain</span><span class="params">(String context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.explain(context) || expression2.explain(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境Context这里就用字符串来代表java语言环境了。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TerminalExpression</span> <span class="variable">aPublic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;public&quot;</span>);</span><br><span class="line">        <span class="type">TerminalExpression</span> <span class="variable">aVoid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;void&quot;</span>);</span><br><span class="line">        <span class="type">AndExpression</span> <span class="variable">isVoidFun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AndExpression</span>(aPublic, aVoid);</span><br><span class="line"></span><br><span class="line">        <span class="type">TerminalExpression</span> <span class="variable">aClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="type">TerminalExpression</span> <span class="variable">anInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;interface&quot;</span>);</span><br><span class="line">        <span class="type">OrExpression</span> <span class="variable">isClassOrInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(aClass, anInterface);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVoidFun</span> <span class="operator">=</span> <span class="string">&quot;public void test()&#123;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">kotlinVoidFun</span> <span class="operator">=</span> <span class="string">&quot;fun test():Unit&#123;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaClass</span> <span class="operator">=</span> <span class="string">&quot;class Test&#123;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaInterface</span> <span class="operator">=</span> <span class="string">&quot;interface Expression&#123;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span> + javaVoidFun + <span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;是无返回值方法？：&quot;</span> + isVoidFun.explain(javaVoidFun));</span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span> + kotlinVoidFun + <span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;是无返回值方法？：&quot;</span> + isVoidFun.explain(kotlinVoidFun));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span> + javaClass + <span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;是类或者接口？：&quot;</span> + isClassOrInterface.explain(javaClass));</span><br><span class="line">        System.out.println(<span class="string">&quot;\&quot;&quot;</span> + javaInterface + <span class="string">&quot;\&quot;&quot;</span> + <span class="string">&quot;是类或者接口？：&quot;</span> + isClassOrInterface.explain(javaInterface));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;public void test()&#123;&#125;&quot;是无返回值方法？：true</span><br><span class="line">&quot;fun test():Unit&#123;&#125;&quot;是无返回值方法？：false</span><br><span class="line">&quot;class Test&#123;&#125;&quot;是类或者接口？：true</span><br><span class="line">&quot;interface Expression&#123;&#125;&quot;是类或者接口？：true</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>解释模式应用场景很多，常见的有SQL解析，xml解析等等等等。</p><h2 id="学完总结"><a href="#学完总结" class="headerlink" title="学完总结"></a>学完总结</h2><p>23种设计模式在实际应用场景中常用的模式也就几种，比如工厂模式，建造者模式，代理模式，享元模式，观察者模式等等，其他模式不必过多研究，遇到再来琢磨即可。设计模式一个重要思想是面向接口编程，面向抽象编程，最大程度解耦。设计模式其实也是java三大特性的灵活运用。设计模式代码虽然耦合度低，扩展性好，但不可过度设计，过度设计只会写出虚而不实的代码，让人感觉是为了设计而设计。设计模式是在不断地迭代，不断地重构中考虑的。实际开发中，能简则简，以别人能看懂你写的代码为主，应用设计模式往往是多种设计模式组合使用，比如工厂模式+原型模式，建造者模式+代理模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞清楚Handler，再也不怕面试官</title>
      <link href="/rq/9f08fd9f.html"/>
      <url>/rq/9f08fd9f.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Handler可以说是Android框架里面很精髓的一部分了，面试必问，用的也最多，这篇文章带你彻底搞清楚Handler。</p><h2 id="Handler是什么？"><a href="#Handler是什么？" class="headerlink" title="Handler是什么？"></a>Handler是什么？</h2><p>提到Handler大家一定不陌生，我们经常用它来切换线程，或者是说做一些延时任务等等。最常用的地方可能就是在网络请求中去切换到主线程中去操作UI。为什么要切换到主线程去操作UI呢？在这之前我们知道在Android里面所有的View都是线程不安全的，意思就是你不能多线程去操作UI，这是Android不允许的，它规定了你只能在主线程去操作UI。</p><p>总结一句话就是：<strong>Handler就是用于线程间通信，解决子线程无法访问UI的问题</strong></p><h2 id="Handler的几种常见使用方法"><a href="#Handler的几种常见使用方法" class="headerlink" title="Handler的几种常见使用方法"></a>Handler的几种常见使用方法</h2><p>注意：Handler的无参构造已经弃用</p><h3 id="1-作为内部类"><a href="#1-作为内部类" class="headerlink" title="1.作为内部类"></a>1.作为内部类</h3><p>作为内部类的使用方法相信大家在熟悉不过了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span>() : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-作为匿名内部类"><a href="#2-作为匿名内部类" class="headerlink" title="2.作为匿名内部类"></a>2.作为匿名内部类</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = <span class="keyword">object</span> :Handler(Looper.myLooper()!!)&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为匿名内部类和作为内部类的方法差不多，不过是把内部类的名字去掉了。</p><h3 id="3-作为静态内部类"><a href="#3-作为静态内部类" class="headerlink" title="3.作为静态内部类"></a>3.作为静态内部类</h3><p>作为静态类的使用方法就是把内部类变为静态类：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyHandler</span>(context: Context) : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> weakContext = WeakReference(context)</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            Toast.makeText(weakContext.<span class="keyword">get</span>(), <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中不加inner关键字的内部类默认就是静态的。这里为什么用WeakReference去引用context？这是防止内存泄漏，等会说。</p><h2 id="Handler的内存泄漏问题"><a href="#Handler的内存泄漏问题" class="headerlink" title="Handler的内存泄漏问题"></a>Handler的内存泄漏问题</h2><blockquote><p>内存泄漏可以说是面试必问的，也是我们开发者所必须熟知的。</p></blockquote><h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><blockquote><p>那么什么是内存泄漏呢？就是程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。</p><p>简单来说就是一个对象该被回收却没有被回收，造成了内存浪费。最常见的就是长生命周期引用短生命周期。</p><p>比如你的activity实例被一个静态变量引用，当你的activity销毁的时候，activity对象应该被回收，而静态变量会一直存在程序中，所以JVM会认为你的activity被一个静态变量引用，认为它还有用，它就不会回收activity实例，从而造成内存泄漏。</p></blockquote><p>Handler虽然好用，但是也容易用错，最容易犯的错误就是内存泄漏。</p><p>在上述的1和2的使用方法都是会出现内存泄漏的情况的。为什么呢？因为内部类和匿名内部类（lamda表达式，回调也是一样的）会持有外部内的引用。正是因为有外部类的引用，所以你的Hander作为内部类才能拿到外部类的变量，比如context，view等等。但是也正是因为有这个引用，比如内部类Handler持有外部类Activity的引用，会导致你的内存泄漏。举个例子，我们知道Hander发送消息到处理消息都可能会有延迟，这就有可能Handler的存在时间比Activity的时间还长，假如此时你发送了一个延时消息，但是消息还没处理你就推出界面，这时候就会内存泄漏。因为Handler的生命周期比Acivity的生命周期长嘛。</p><h3 id="如何检测内存泄漏"><a href="#如何检测内存泄漏" class="headerlink" title="如何检测内存泄漏"></a>如何检测内存泄漏</h3><p>检测内存泄漏有一个很方便的开源库——-LeakCanary：</p><p>使用：</p><p>在build.gradle引入依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.10&#x27;</span></span><br></pre></td></tr></table></figure><p>在重新运行你的APP，这时候你的桌面就会出现金丝雀的图标：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212001.png" style="zoom:200%;" /><p>然后对着你的APP一顿测试，假如有内存泄漏就会弹出一个小黄鸟提示，然后你会看到这样的通知：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212205.png" style="zoom:50%;" /><p>点击这个通知它会进行分析，分析完成之后再点进去就会进去小黄鸟应用，里面是你的APP所有的内存泄漏的记录：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212359.png" style="zoom:50%;" /><p>点进去你就会看到泄漏对象的引用链：</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230404212510.png" style="zoom:50%;" /><p>接下来就靠你自己分析引用链来判断是哪里内存泄漏了。</p><h3 id="解决Handler的内存泄漏："><a href="#解决Handler的内存泄漏：" class="headerlink" title="解决Handler的内存泄漏："></a>解决Handler的内存泄漏：</h3><p>上述说了，1和2会发生内存泄漏，是因为内部Handler引用了外部activity，那怎么解决呢？既然是Handler存在时间比Activity长那就缩短Handler的存在时间嘛，所以在onDestory中去移除所有发送的消息：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    myHandler.removeCallbacksAndMessages(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在Activity被销毁的时候Handler所有的消息都被移除了，也就不存在对Activity的引用了，内存泄漏也就解决了。</p><p>而在3中Handler是用做静态内部类的，作为静态类的话就没有与外部类连接的通道了，这时候就只能传参，但为了防止使用强引用造成内存泄漏这里改为弱引用。Java里的四种引用这里做一个简单的介绍：</p><blockquote><p>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</p><p>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</p><p>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</p><p>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</p></blockquote><p>​正式因为使用activity的context容易泄漏，我们toast一般使用application的context。因为application的生命周期一般都比较长，它是伴随你的app整个应用的。那么怎么使用呢？要使用，要知道application在哪里。在我们的注册文件，也就是声明activity的地方：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Teach&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个application就是系统默认的application，要使用我们自定义的application肯定的继承系统的application然后把context暴露出来：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> mContext: App</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        mContext = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application本身就是context。但是同时也要注意不要让application去引用任何短生命周期对象。然后在注册文件中去替换掉系统的application：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  通过替换掉application的name为我们自定义的App 去指定application为自定义的application  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.App&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Teach&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:targetApi</span>=<span class="string">&quot;31&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在toast里面去用context：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivitySecondBinding.inflate(layoutInflater) &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> myHandler = MyHandler()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button2.setOnClickListener &#123;</span><br><span class="line">            myHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyHandler</span>() : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="comment">//这里context换成App的Context</span></span><br><span class="line">            Toast.makeText(App.mContext, <span class="string">&quot;处理消息&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你的静态Handler就不需要和外部的Activity去通信。</p><h2 id="浅析Handler"><a href="#浅析Handler" class="headerlink" title="浅析Handler"></a>浅析Handler</h2><p>上面我们说到，Handler的无参构造已经废弃，取而代之的是有参构造，传入的参数是Looper.myLooper()。为什么要传这个参数呢？因为Handler的创建是根据Looper来获取的，而Looper是和Thread对应的。Google认为原来的无参构造你没有指定Looper，这容易导致Looper的获取为空从而导致崩溃。所以原来的无参被废弃，让你自己传Looper等于是应用崩溃了是你的原因而不是官方代码出问题了。</p><p>那么Handler是怎么保证在主线程运行的，Looper、Thread、Handler又是怎么样的一个关系呢？听我慢慢讲来。</p><h3 id="在子线程中创建Handler"><a href="#在子线程中创建Handler" class="headerlink" title="在子线程中创建Handler"></a>在子线程中创建Handler</h3><p>在构建Handler的时候，我们会获取Looper并且传进去，那么Looper肯定会初始化。</p><p>我们创建的Handler一般都是主线程的Handler，那在子线程怎么创建Handler呢？</p><p>有人说直接new啊：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            Thread&#123;</span><br><span class="line">                <span class="keyword">val</span> handler = Handler(Looper.myLooper()!!)</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那当你点击按钮的时候你的app就崩了，并且给你报Looper为空的错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">        at com.wssg.teach.MainActivity.onCreate$lambda$1$lambda$0(MainActivity.kt:20)</span><br><span class="line">        at com.wssg.teach.MainActivity.$r8$lambda$nMCVh1lEoyHQZBD9S2vny8Epw_k(MainActivity.kt)</span><br><span class="line">        at com.wssg.teach.MainActivity$$ExternalSyntheticLambda0.run(D8$$SyntheticClass)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:761)</span><br></pre></td></tr></table></figure><p>说明咱们的Looper还没初始化，子线程创建不了Handler，正确的Handler的创建方式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        <span class="keyword">var</span> handler: Handler? = <span class="literal">null</span></span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            Thread &#123;</span><br><span class="line">                Looper.prepare()</span><br><span class="line">                handler = <span class="keyword">object</span> : Handler(Looper.myLooper()!!) &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">                        Log.d(<span class="string">&quot;RQRQRQ&quot;</span>, <span class="string">&quot;handleMessage: 收到消息！！！！&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Looper.loop()</span><br><span class="line">            &#125;.start()</span><br><span class="line">            Thread &#123;</span><br><span class="line">                handler?.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是举个例子怎么在子线程创建Handler并且发送消息给它。首先开启了一个线程，Looper.prepare()就是初始化Looper，这样在下面创建Handler的时候Looper.myLooper才不会为null，然后Looper.loop()是开始接收Handler收到消息，没这行代码是收不到消息的，然后又开启了子线程给Handler发送一个消息，之后你就能在子线程看到消息收到了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-04-06 22:23:38.673  5646-5706  RQRQRQ                  com.wssg.teach                       D  handleMessage: 收到消息！！！！</span><br></pre></td></tr></table></figure><p>日志也确实如此。</p><p>总结Handler的创建：</p><p>1.Looper.prepare()       初始化Looper</p><p>2.new Handler(Looper.myLooper)       创建Handler</p><p>3.Looper.loop()    开始接收消息</p><p>4.在其他地方发送消息</p><h3 id="分析消息的插入流程"><a href="#分析消息的插入流程" class="headerlink" title="分析消息的插入流程"></a>分析消息的插入流程</h3><p>但是我们平常使用的时候并没有去初始化Looper.prepare()，而且也没有报错，那Android底层肯定初始化了Looper。那么在哪里呢？</p><p>我们在学java的时候总是会有一个main函数作为程序运行的入口对不对。而我们之前写Android也是用java写的，并且源码很多也是java，那源码里面肯定有一个main函数。在哪里呢？在ActivityThread里面。ActivityThrea也就是Android的Ui线程。我们在Android Studio里面全局搜索进去ActivityThread的源码，然后在代码里面搜索main函数：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230406223748.png"></p><p>一眼看去就看到了Looper.prepareMainLooper()和Looper.loop();两行代码，果然是在这初始化了Looper。而Looper.prepareMainLooper();本身也是调用Looper.prepare()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> The main looper for your application is created by the Android environment,</span></span><br><span class="line"><span class="comment"> *   so you should never need to call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);<span class="comment">//本身就是调用了Looper.prepare()</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper初始化流程我们弄清楚了，我们看看具体的流程。我们先看我们常用的Handler的发送消息的方法，Handler有多个发送消息的方法：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230406235200.png"></p><p>sendMessage，sendEmptyMessage，post…….等等等等都是调用的sendMessageDelayed，sendMessageDelayed调用的是sendMessageAtTime()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的就是enqueueMessage：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，this也就是Handler存到了message的target，给了个唯一的Id，mAsynchronous是用于判断是否是加急消息，加急消息之后说。然后就是调用queue.enqueueMessage(msg, uptimeMillis);，queue是什么呢？是MessageQueue，就是MessageQueue的enqueueMessage：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;<span class="comment">//Handler不能为空</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//判断message是否在使用中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//判断是否停止</span></span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();<span class="comment">//回收message</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();<span class="comment">//标记当前的message在使用</span></span><br><span class="line">        msg.when = when;<span class="comment">//把message发生的时间存到message</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;<span class="comment">//message的表头</span></span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler为null就抛出异常，然后有个关键字synchronized，synchronized是什么呢？它就是一把锁。我们用handler经常跨线程操作嘛，而synchronized就是保证线程安全的一个关键字，你可以理解为当一个线程在操作synchronized括号里的东西的时候，其他线程也执行到这里了就会进行等待，等到前一个把synchronized括号里的操作执行完了其他线程才会被唤醒执行这里面得代码。以此来保证一个数据同一时间只能被一个线程操作。</p><p>然后是判断message是否在使用，在使用就会抛出异常。如果正在停止，而这里又是异步操作，这里就会产出一个异常，再回收Message，当我们调用Looper.quit()去结束Looper的时候就会走到这里。而回收Message其实就是清除Message携带的所有信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment"> * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    replyTo = <span class="literal">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="literal">null</span>;</span><br><span class="line">    callback = <span class="literal">null</span>;</span><br><span class="line">    data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="built_in">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除所有的信息之后就把Message加入到sPool中。为什么要这么做呢？为了Message的复用。要知道Handler是Android框架经常用的东西，每次都new一个message多麻烦，也耗性能。Message是一个链表结构，把当前message回收后把当前的message插入表头。那我们怎么拿回收的Message呢？用Message.obtain()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从回收池里面拿，拿不到再new。事实上也推荐这种获取message的方式，在源码里也能经常看到，比如sendEmptyMessageDelayed：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendEmptyMessageDelayed</span><span class="params">(<span class="type">int</span> what, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单了解了message，我们再看看enqueueMessage关键的部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//消息队列为空，需要立即发生，发生时间早于表头</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前message是否锁住，p的Handler是否为null，msg是否为异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//下面这一段就是链表的插入操作，如果到末尾了或者当前的Message发生时间小于要插入的Message发生时间就break</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面循环break，代表找到了要插入的位置</span></span><br><span class="line">            <span class="comment">//将当前结点插入</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;<span class="comment">//当前需要唤醒就调用native层的方法去唤醒当前线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记message在使用，把时间存到Message。mMessages是一个要处理的消息链表。</p><p>首先是第一个分支，p引用mMessages的表头。如果表头为空，发生时间为0（也就是需要立即执行）或者发生时间比mMessages表头早的话就把当前的Message作为表头插入消息链表。这里的needWake是用于唤醒线程的，这里把mBlocked是否需要锁住当前Message操作赋值给了needWake。被锁住了那肯定就需要唤醒嘛。</p><p>一般走的都是第二个分支，needWake需要唤醒的条件为当前Message是否被锁住，Handler是否为null，Message是否为异步消息。之后就是一个死循环去遍历链表的所有结点，插入结点的位置为，发生时间早于后一个结点或者是末尾。最后就是唤醒线程。</p><p>这里有两个疑问点：1.什么是异步消息，有什么用？    2.为什么要唤醒线程    我们先看什么是异步消息   </p><h3 id="什么是异步消息，同步屏障？"><a href="#什么是异步消息，同步屏障？" class="headerlink" title="什么是异步消息，同步屏障？"></a>什么是异步消息，同步屏障？</h3><p>Handler一般有三种消息：同步消息，异步消息，同步屏障</p><p>我们平常所发送的消息都是同步消息。</p><p>同步屏障用于处理异步消息。什么意思呢？</p><p>我们知道屏幕是有刷新率的，60hz，120hz，144hz等等。以60hz来说，它的所有界面都需要在16ms内画完，假如此时需要处理的消息太多了，16ms处理不完，此时界面就会发送卡顿现象。这时候就需要异步消息了。在发送异步消息后，如果在取消息过程中遇到了同步屏障就会去寻找异步消息，找到异步消息就返回，没有异步消息才会去找同步消息。简而言之，同步屏障就是一个标记，遇到这个标记就忽略同步消息去找异步消息。</p><p>怎么创建异步消息？</p><p>1.创建Handler的时候声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的async参数就代表此Handler发送的消息是否是异步消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插入消息的时候会去调用msg.setAsynchronous(true);将异步Handler发送的消息设置成异步消息</p><p>2.当然我们传Message的时候也可以直接将它设置成异步消息：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> msg = Message.obtain()</span><br><span class="line">msg.isAsynchronous = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>怎么发送同步屏障？通过postSyncBarrier()方法，但是postSyncBarrier()方法是隐藏的只能通过反射调用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> token: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;DiscouragedPrivateApi&quot;</span>)</span></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postSyncBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> method = MessageQueue::<span class="keyword">class</span>.java.getDeclaredMethod(<span class="string">&quot;postSyncBarrier&quot;</span>);</span><br><span class="line">    token = method.invoke(Looper.getMainLooper().queue) <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeSyncBarrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> method =</span><br><span class="line">        MessageQueue::<span class="keyword">class</span>.java.getDeclaredMethod(<span class="string">&quot;removeSyncBarrier&quot;</span>, <span class="built_in">Int</span>::<span class="keyword">class</span>.java);</span><br><span class="line">    method.invoke(Looper.getMainLooper().queue, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而postSyncBarrier()就是target也就是handler为null的message：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        <span class="comment">//这里没有对target赋值，就是为null</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"><span class="comment">//下面就是插入message</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们简单分析了一下Message的插入流程，那么我们现在来看看Looper.prepare()和Looper.loop干了什么事情。</p><h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收一个boolean值，quitAllowed是否允许这个Looper停止嘛。判断ThreadLocal是否为null，不为null抛出异常，为null就new 一个Looper设置到ThreadLocal里面。</p><p>ThreadLocal是什么呢？<strong>是一个以线程为作用域存储数据的一个类</strong>，什么叫以线程为作用域？就是说对于同一个ThreadLocal变量，不同的线程从里面去取数据能取到不同的值，就比如A线程在这个sThreadLocal里面存了A线程的Looper，B线程在这个sThreadLocal里面也存了B线程的Looper，然后A线程去和这个sThreadLocal说，我要取Looper出来，sThreadLocal会把A线程的Looper取出来，而不会取到B线程的Looper，B线程同理.构造这个ThreadLocal里面的泛型的实际类型就表明了这个ThreadLocal希望为线程存储什么类型的数据。：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//通过线程去获取map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">//map存在就直接拿里面的值返回</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map为nul就初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();<span class="comment">//初始化value，默认为null</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)<span class="comment">//map存在就设置值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);<span class="comment">//不存在就创建map，并且把初始值传进去</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);<span class="comment">//第一次设置值map不存在就创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">//就是创建了一个ThreadLocalMap，并且设置了值</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal创建Map获取Map都是通过Thread去操作的，创建获取的都是Thread的ThreadLocalMap，map的key是ThreadLocal，value是泛型也就是Looper。也就是说一个ThreadLocal变量通过不同的线程获取不同的ThreadLocalMap，从而获取到自己的Looper</p><p>而ThreadLocalMap是ThreadLocal的静态内部类，是一个对键值对的弱引用包装：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230407171128.png"></p><p>为什么不直接用map而是要用个Entry去维护呢？这主要是一个不破坏原则，为了扩展WeakReference去弱化引用。他的设计很完美，感兴趣可以研究一下。</p><p>那我们现在知道了Looper.prepare就是用ThreadLocal去用线程获取map把Looper存进去key是ThreadLocal，那我们看看new Looper干了啥：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 了一个MessageQueue，并记录quitAllowed的值。</p><p>好了，prepare我们分析清清楚了。总结一下：</p><p>ThreadLocal通过Thread去获取对应的ThreadLocalMap，通过Map去存Looper实例，key是ThreadLocal，new Looper的时候初始化了MessageQueue消息队列把是否允许停止的值记录在了这里。也难怪没初始化Looper的时候我们调用Looper.myLoop()会报空指针异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没初始化之前sThreadLocal.get()获取的肯定为空。</p><p>接下来分析Looper.loop()</p><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;AndroidFrameworkBinderIdentity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛弃对代码健壮性的处理，关键的代码只有这么几行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;AndroidFrameworkBinderIdentity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper(); </span><br><span class="line">......</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是开启了一个死循环，一直调用loopOnce()，如果返回flase就结束死循环。那我们看看loopOnce：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">//拿消息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//这里调用的就是创建Handler重写的handlerMessage</span></span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.messageDispatched(token, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除去了无关的代码，关键的就两行Message msg &#x3D; me.mQueue.next();和msg.target.dispatchMessage(msg)，先拿消息，然后处理消息。</p><p>看看Message msg &#x3D; me.mQueue.next();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次进入一次循环都会睡眠线程</span></span><br><span class="line">        <span class="comment">//调用native层对当前线程进行睡眠，睡眠时间是nextPollTimeoutMillis一开始是0就是不睡眠</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//加锁</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;<span class="comment">//拿到消息队列的头</span></span><br><span class="line">            <span class="comment">//下面这条分支是当target为null的时候，也就是遇到了同步屏障</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//直到找到异步消息或者到结尾的时候才会退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拿到消息就会到这个分支</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//要执行的时间比当前时间晚的话就会计算要睡眠的时间进行睡眠</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//这里就是找到当前要执行的消息</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;<span class="comment">//把当前消息从链表中删除</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;<span class="comment">//返回拿到的message</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//这条分支表示messages为空也就是没有任何消息要处理</span></span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;<span class="comment">//睡眠时间为-1表示当前线程会一直睡眠</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是调用Looper.quit()的情况，销毁MessageQueue</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//这里返回null，loopOnce就返回false，loop就退出了死循环，程序运行结束</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ........</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是处理IdleHandler，这是在没有任何消息的情况下才会走到这里，说明idleHandler的消息级别最低</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();<span class="comment">//调用重写的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;<span class="comment">//如果不需要保存就移除</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一个死循环，每次进入循环都会调用native层的方法睡眠当前线程，而睡眠时间是在for循环中去计算的。首先是判断是不是遇到了同步屏障，是就去找异步消息而忽略同步消息。之后拿到了消息会判断跟当前的时间大小，比当前时间晚，就会睡眠直到消息的执行时间。否则把当前的message从消息队列中删除并返回。如果没拿到消息说明没有消息要处理了，就一直睡眠，直到有消息进来。如果中途调用Looper.quit就直接退出程序。</p><p>最后是没有任何消息需要处理才会去处理IdleHandler，那么它是什么呢？它就是一个优先级最低的Handler，当你有一个不那么重要的任务需要处理的时候你就可以用它。怎么使用呢？使用MessageQueue添加：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="literal">false</span><span class="comment">//返回false表示执行任务后移除自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后再看看</p><h3 id="Looper-quit"><a href="#Looper-quit" class="headerlink" title="Looper.quit()"></a>Looper.quit()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">    mQueue.quit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quit</span><span class="params">(<span class="type">boolean</span> safe)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把mQuitting的值设为true，然后移除所有的Message，唤醒线程结束程序。</p><p>好了整体的流程我们大概讲完了，我们再来捋一捋，ThreadLocal对应线程的ThreadLcoalMap，ThreadLocalMap对应保存了ThreadLocal和Looper，Looper对应一个MessageQueue。Looper.loop里面有个死循环一直取消息，取不到消息就睡眠当前线程，取到就回调dispatchMessage方法。sendMessage就是在MessageQueue里面插入消息。</p><p>我们再看看HandlerThread和IntentService</p><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> mPriority;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mTid</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wasInterrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getThreadHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quitSafely</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getThreadId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler就是一个内部封装了Looper的Thread，方便我们创建handler，使用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> handlerThread = HandlerThread(<span class="string">&quot;测试线程&quot;</span>)</span><br><span class="line">handlerThread.start()</span><br><span class="line"><span class="keyword">val</span> mHandler = <span class="keyword">object</span> :Handler(handlerThread.looper)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个使用HandlerThread的IntentService，不过在API26也就是Android 8以后被废弃了，官方推荐使用WorkManager。这里还是贴一下源码吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IntentService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntentService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIntentRedelivery</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> <span class="title class_">ServiceHandler</span>(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是一个HandlerThread的Service，现在也很少用它来做后台任务了。</p><p>Handler的讲解差不多是这些了，接下来我们来看几个常见面试题吧：</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>MessageQueue是干嘛呢？用的什么数据结构来存储数据？</p><blockquote><p>MessageQueue就是一个用于存储消息、用链表实现的特殊队列结构。</p></blockquote><p>Handler中延时消息是怎么实现的？</p><blockquote><p>MessageQueue是一个按照消息时间排列的一个链表结构，根据消息的when字段插入即可。</p></blockquote><p>MessageQueue的消息怎么被取出来的？</p><blockquote><p>通过Looper的next方法取消息，里面是一个死循环，保证一定可以取到一条消息,如果没有可用消息，那么就阻塞在这里，一直到有新消息的到来。</p><p>阻塞的情况有俩种 没有消息 和当前消息还没有到要发送的时间</p></blockquote><p>ThreadLocal运行机制？这种机制设计的好处？</p><blockquote><p>ThreadLocal中有一个ThreadLocalMap变量，这个变量存储着键值对形式的数据。</p><ul><li>key为this，也就是当前ThreadLocal变量。</li><li>value为T，也就是要存储的值。</li></ul><p>每个线程中都有一个ThreadLocalMap,这样带来的好处就是，在不同的线程，访问同一个ThreadLocal对象，但是能获取到的值却不一样。</p></blockquote><p>为什么ThreadLocalMap要弱引用ThreadLocal?(需要懂内存泄漏的相关知识)</p><blockquote><p>因为ThreadLocalMap如果是强引用ThreadLocal的话，假如我们将<br>ThreadLocal置为null，会因为ThreadLocalMap持有了ThreadLocal的引用而无法被GC</p></blockquote><p>为什么不能在子线程中更新UI？</p><blockquote><p>因为Android中的UI控件不是线程安全的。</p><p>如果通过加锁来实现UI控件的线程安全会导致UI访问的效率降低影响用户体验。</p></blockquote><p>Looper中的quitAllowed字段是啥？有什么用？</p><blockquote><p>是否允许退出的标志字段。在quit方法中有被用到，如果这个字段为false，代表不允许退出，就会报错。</p><p>quit方法就是退出消息队列，终止消息循环。</p><ul><li>首先设置了mQuitting字段为true。</li><li>然后判断是否安全退出，如果安全退出，就清空所有的延迟消息，之前没处理的非延迟消息还是需要处理</li><li>如果不是安全退出，就直接清空所有的消息</li></ul><p>当调用了quit方法之后，mQuitting为true，enqueuemessage方法中消息就发不出去了，会报错。next方法返回null，那么loop方法中就会退出死循环。</p></blockquote><p>Handler、Looper、MessageQueue、线程是一一对应关系吗？</p><blockquote><p>一个线程只会有一个Looper对象，所以线程和Looper是一一对应的。</p><p>MessageQueue对象是在new Looper的时候创建的，所以Looper和MessageQueue是一一对应的。</p><p>Handler的作用只是将消息加到MessageQueue中，并后续取出消息后，根据消息的target字段分发给当初的那个handler，所以Handler对于Looper是可以多对一的，也就是多个Hanlder对象都可以用同一个线程、同一个Looper、同一个MessageQueue。</p><p>总结：Looper、MessageQueue、线程是一一对应关系，而他们与Handler是可以一对多的。</p></blockquote><p>Looper.loop方法是死循环，为什么不会卡死（ANR）?</p><blockquote><p>1.主线程需要这样的死循环来处理View界面的变化</p><p>2.而且没有消息的时候,handler会阻塞，主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生。所以死循环也不会特别消耗CPU资源。</p><p>3.在收到跨线程消息后，会交给主线程的Hanlder再进行消息分发。所以Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施，比如收到msg&#x3D;H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终执行到onCreate方法。</p><p>4.真正导致ANR的原因不是死循环，而是因为在某个消息处理的时候操作时间过长</p></blockquote><p>HandlerThread和IntentService的原理</p><blockquote><p>HandlerThread就是一个封装了Looper的Thread类<br>通过获取 HandlerThread 的 looper 对象传递给 Handler 对象，可以在 handleMessage()方法中执行异步任务。<br>HandlerThread 与线程池不同，HandlerThread 背后只有一个线程,多任务时需要等待处理</p><p>IntentService 是一个继承了 Service 的抽象类，它封装了HandlerThread 和 Handler，当 IntentService 被第一次启动时，它的 onCreate()方法会被调用，onCreat()方法会创建一个HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象，这样通过 handler 发送的消息最终都会在HandlerThread 中执行。</p></blockquote><p>Handler内存泄漏的原理</p><blockquote><p>内存泄漏的本质是因为长生命周期的对象持有了短生命周期对象的引用导致短生命周期的对象无法被正确回收。</p><p>Handler如果是activity的内部类，会导致handler持有activity的引用，而handler在发送message时,message会持有handler的引用，而message又被messageQueue引用，messagequeue又被looper引用，looper又被threadlocal引用，threadlocal又被主线程引用，从而导致handler内存泄漏。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack之四：ViewModel</title>
      <link href="/rq/260b5af1.html"/>
      <url>/rq/260b5af1.html</url>
      
        <content type="html"><![CDATA[<h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><h2 id="1-什么是VeiwModel"><a href="#1-什么是VeiwModel" class="headerlink" title="1.什么是VeiwModel"></a>1.什么是VeiwModel</h2><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 类是一种<a href="https://developer.android.google.cn/topic/architecture/ui-layer/stateholders?hl=zh-cn">业务逻辑或屏幕级状态容器</a>。它用于将状态公开给界面，以及封装相关的业务逻辑。 它的主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态。这意味着在 activity 之间导航时或进行配置更改后（例如旋转屏幕时），界面将无需重新提取数据。</p><p>简单来说就是保存activity和fargment页面的数据的。</p><h3 id="何谓配置变更"><a href="#何谓配置变更" class="headerlink" title="何谓配置变更?"></a>何谓配置变更?</h3><p>配置变更指的是，<strong>应用在运行时，内置的配置参数变更从而触发的Activity重新创建</strong>。</p><p>常见的场景有：旋转屏幕、深色模式切换、屏幕大小变化、更改了默认语言或者时区、更改字体大小或主题颜色等。</p><h3 id="何谓异常重建？"><a href="#何谓异常重建？" class="headerlink" title="何谓异常重建？"></a>何谓异常重建？</h3><p>异常重建指的是非配置变更情况下导致的 <code>Activity</code> 重新创建。</p><p>常见场景大多是因为 <strong>内存不足，从而导致后台应用被系统回收</strong> ，当我们切换到前台时，从而触发的重建，这个机制在Android中为 <code>Low Memory Killer</code> 机制，简称 <code>LMK</code>。</p><blockquote><p>可以在开发者模式，限制后台任务数为1，从而测试该效果。</p></blockquote><h2 id="2-为什么需要ViewModel？"><a href="#2-为什么需要ViewModel？" class="headerlink" title="2.为什么需要ViewModel？"></a>2.为什么需要ViewModel？</h2><p>在 <code>ViewModel</code> 出现之前,对于 <code>View</code> 逻辑与数据，我们往往都是直接存在 <code>Activity</code> 或者 <code>Fragment</code> 中，优雅一点，会细分到具体的单独类中去承载。当配置变更时，无可避免，会触发界面重绘。相应的，我们的数据在没有额外处理的情况下，往往也会被初始化，然后在界面重启时重新加载。</p><p>但如果当前页面需要维护某些状态不被丢失呢，比如 选择、上传状态 等等? 此时问题就变得棘手起来。</p><p>稍有经验同学会告诉你，<strong>在 onSaveInstanceState 中重写，使用bundle去存储相应的状态啊？</strong></p><p><strong>但状态如果少点还可以，多一点就非常头痛，更别提包含继承关系的状态保存。</strong></p><p>所以就有了ViewModel，<strong>但ViewModel并不是<code>onSaveInstanceState()</code>的替代品</strong>。</p><p>随着 <code>ViewModel</code> 组件推出之后，上述因配置变更而导致的状态丢失问题就迎刃而解。</p><p><code>ViewModel</code> 可以做到在配置变更后依然持有状态。所以，在现在的开发中，我们开始将 <strong>View数据</strong> 与 逻辑 藏于 <code>ViewModel</code> 中，然后对外部暴漏观察者，比如我们常常会搭配 <code>LiveData</code> 一起使用，以此更容易的保持状态同步。这其实就很接近之后要讲的MVVM架构。</p><p>关于 <code>ViewModel</code> 的生命周期，具体如下图所示：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230319145649.png"></p><p>虽然 <code>ViewModel</code> 非常好用，但 <code>ViewModel</code> 也不是万能，其只能避免配置变更时避免状态丢失。比如如果我们的App是因为 <strong>内存不足</strong> 而被系统<strong>kill</strong> 掉，此时 <code>ViewModel</code> 也会被清除  。</p><p>不过对于这种情况，仍然有以下三个方法可以依然保存我们的状态:</p><ul><li>重写 <code>onSaveInstanceState()</code> 与 <code>onRestoreInstanceState()</code>;</li><li>使用 <code>SavedState</code>,本质上其实还是 <code>onSaveInstanceState()</code> ；</li><li>使用 <code>SavedStateHandle</code> ，本质上是依托于 <code>SaveState</code> 的实现;</li></ul><blockquote><p>上述的后两种都是随着 <strong>JetPack</strong> 逐步被推出，可以理解为是对原有的onSavexx的封装简化，从而使其变得更易用。</p></blockquote><h2 id="3-ViewModel的使用"><a href="#3-ViewModel的使用" class="headerlink" title="3.ViewModel的使用"></a>3.ViewModel的使用</h2><p>首先肯定是导入viewmodel的依赖</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1&quot;</span></span><br></pre></td></tr></table></figure><p>然后定义viewmodel，一般情况我们都是结合LiveData一起使用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RQ527 (Ran Sixiang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> 1799796122<span class="doctag">@qq</span>.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/3/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> homeLiveData: LiveData&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _mutableHomeLiveData</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _mutableHomeLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getHomeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//这里从网络或者本地获取数据</span></span><br><span class="line"></span><br><span class="line">        _mutableHomeLiveData.value = <span class="string">&quot;我获取到了数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般是不建议viewmodel暴露mutableLivedata给activtiy，而是内部使用mutableLiveData去修改值，然后转化成LiveData暴露给activity。</p><p>注：为了保证Activity不被泄漏，不要在Activity传回调或者view进去，也不要在Viewmodel导入android.的包，（android.arch.除外），这样做是为了不要让ViewModel知晓Android的FrameWork，ViewModel只是用来写点逻辑代码和存数据的。</p><p> 然后我们在activity去获取viewmodel：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: ActivityMainBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> lazy &#123;ViewModelProvider(<span class="keyword">this</span>)[TestViewModel::<span class="keyword">class</span>.java]&#125;<span class="comment">//懒加载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line"></span><br><span class="line">        mViewModel.homeLiveData.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            mBinding.textView.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            mViewModel.getHomeData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们用ViewmodelProvider传了lifecycleowner进去，传我们自定义的viewmodel类。创建viewmodel大概就是这样。然后在下面去观察livedata，点击一个按钮获取数据。这是正确的创建viewmodel的方法，你直接new 的话是不正确的，完全没有效果。</p><p>ktx提供了很多的扩展函数简化我们创建Viewmodel的步骤，我们先导入依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation<span class="string">&quot;androidx.activity:activity-ktx:1.6.1&quot;</span><span class="comment">//activity</span></span><br><span class="line">implementation<span class="string">&quot;androidx.fragment:fragment-ktx:1.5.5&quot;</span><span class="comment">//fragment</span></span><br></pre></td></tr></table></figure><p>然后我们的viewmodel就可以这么创建了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> viewModels&lt;TestViewModel&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> viewModels&lt;TestViewModel&gt;&#123;TestViewModelFactory()&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是比之前精简了很多，其本质也是调用ViewModelProvider.get。</p><p>假如你在viewmodel里需要application的话，可以使用AndroidVeiwModel：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> homeLiveData: LiveData&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _mutableHomeLiveData</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _mutableHomeLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mApplication: Application</span><br><span class="line">        <span class="keyword">get</span>() = getApplication()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getHomeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Toast.makeText(mApplication, <span class="string">&quot;aaaa&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        <span class="comment">//这里从网络或者本地获取数据</span></span><br><span class="line"></span><br><span class="line">        _mutableHomeLiveData.value = <span class="string">&quot;我获取到了数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承自AndroidViewModel，然后getApplication就可以获取application了。</p><p>在Fragment里面的用法和fragment是一样的，就不再说了。同时，一个viewmodel多个Fragment或者activity可以共享。</p><p>假如viewmodel需要传参怎么办？有人会说直接这样：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModel</span>(<span class="keyword">val</span> tag: String) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> homeLiveData: LiveData&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _mutableHomeLiveData</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _mutableHomeLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getHomeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//这里从网络或者本地获取数据</span></span><br><span class="line"></span><br><span class="line">        _mutableHomeLiveData.value = <span class="string">&quot;我获取到了数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你怎么去创建viewmodel实例呢？要知道我们获取viewmodel是这样的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> lazy &#123;ViewModelProvider(<span class="keyword">this</span>)[TestViewModel::<span class="keyword">class</span>.java]&#125;</span><br></pre></td></tr></table></figure><p>这样去创建viewmodel默认是无参数的，肯定会出错。那怎么办呢？</p><p>其实我们的ViewModelProvider的构造函数有三个：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230320162525.png"></p><p>第二参数是ViewModelProvider.Factory，是干什么的呢？用来实例化viewmodel的，默认是无参的，所以要传参我们肯定要自定义一个ViewModelProvider.Factory：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModelFactory</span>(<span class="keyword">val</span> tag: String) : ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">val</span> testViewModel = TestViewModel(tag)</span><br><span class="line">        <span class="keyword">return</span> testViewModel <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个有参数的Factory，实现ViewModelProvider.Factory这个接口然后创建ViewModel实例再把参数传进去就可以了。最后在activtiy获取viewmodel的时候把参数传进去：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    ViewModelProvider(</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        TestViewModelFactory(<span class="string">&quot;我传了个参数&quot;</span>)</span><br><span class="line">    )[TestViewModel::<span class="keyword">class</span>.java]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们new了一个我们自定义的Factory实例并把参数传了进去，这个参数你们可以自定义也可以从别的地方来，具体看你们的需求。</p><p>刚刚我们在上面提到了，如果我们的App是因为 <strong>内存不足</strong> 而被系统<strong>kill</strong> 掉，此时 <code>ViewModel</code> 也会被清除  。这时候我们可以：</p><ul><li>重写 <code>onSaveInstanceState()</code> 与 <code>onRestoreInstanceState()</code>;</li><li>使用 <code>SavedState</code>,本质上其实还是 <code>onSaveInstanceState()</code> ；</li><li>使用 <code>SavedStateHandle</code> ，本质上是依托于 <code>SaveState</code> 的实现;</li></ul><blockquote><p>上述的后两种都是随着 <strong>JetPack</strong> 逐步被推出，可以理解为是对原有的onSavexx的封装简化，从而使其变得更易用。</p></blockquote><p>方法本质都是用<code>onSaveInstanceState()</code>我们就讲个方便的<code>SavedStateHandle</code>：</p><p>首先导入依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.5.1&quot;</span></span><br></pre></td></tr></table></figure><p>然后稍微修改一下ViewModel：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> savedStateHandle: SavedStateHandle) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> homeLiveData: LiveData&lt;String&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _mutableHomeLiveData</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _mutableHomeLiveData = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> MY_KEY = <span class="string">&quot;MY_KEY&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getHomeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//这里从网络或者本地获取数据</span></span><br><span class="line"></span><br><span class="line">        _mutableHomeLiveData.value = <span class="string">&quot;我传了个数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">saveData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        savedStateHandle[MY_KEY] = <span class="string">&quot;我保存了一个数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> savedStateHandle[MY_KEY]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Activity中修改一下viewmode的创建方式：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> lazy &#123;ViewModelProvider(<span class="keyword">this</span>,SavedStateViewModelFactory(application, <span class="keyword">this</span>))[TestViewModel::<span class="keyword">class</span>.java]&#125;</span><br></pre></td></tr></table></figure><p>就是传一个SavedStateViewModelFactory然后把application和当前activity传进去。之后就可以调方法保存数据获取数据了。</p><h2 id="4-详解viewmodel"><a href="#4-详解viewmodel" class="headerlink" title="4.详解viewmodel"></a>4.详解viewmodel</h2><p>大概的用法讲完了，我们看看viewmodel是怎么从出生到死亡的。</p><h3 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a><strong>ViewModelProvider</strong></h3><p>我们先从获取viewmodel的实例说起，也就是：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> lazy &#123; ViewModelProvider(<span class="keyword">this</span>)[TestViewModel::<span class="keyword">class</span>.java] &#125;</span><br></pre></td></tr></table></figure><p>我们把当前的activity传进了ViewmodelProvider的构造函数，我们看一看</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates `ViewModelProvider`. This will create `ViewModels`</span></span><br><span class="line"><span class="comment"> * and retain them in a store of the given `ViewModelStoreOwner`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will use the</span></span><br><span class="line"><span class="comment"> * [default factory][HasDefaultViewModelProviderFactory.getDefaultViewModelProviderFactory]</span></span><br><span class="line"><span class="comment"> * if the owner implements [HasDefaultViewModelProviderFactory]. Otherwise, a</span></span><br><span class="line"><span class="comment"> * [NewInstanceFactory] will be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(</span><br><span class="line">    owner: ViewModelStoreOwner</span><br><span class="line">) : <span class="keyword">this</span>(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates `ViewModelProvider`, which will create `ViewModels` via the given</span></span><br><span class="line"><span class="comment"> * `Factory` and retain them in a store of the given `ViewModelStoreOwner`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> owner   a `ViewModelStoreOwner` whose [ViewModelStore] will be used to</span></span><br><span class="line"><span class="comment"> * retain `ViewModels`</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory a `Factory` which will be used to instantiate</span></span><br><span class="line"><span class="comment"> * new `ViewModels`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(owner: ViewModelStoreOwner, factory: Factory) : <span class="keyword">this</span>(</span><br><span class="line">    owner.viewModelStore,</span><br><span class="line">    factory,</span><br><span class="line">    defaultCreationExtras(owner)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其实就是调用了三个参数的构造方法，首先就是viewModelStoreOwner，那我们的activity肯定实现了这个接口，我们先不管，往后看。之后是构造默认的Factory：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">defaultFactory</span><span class="params">(owner: <span class="type">ViewModelStoreOwner</span>)</span></span>: Factory =</span><br><span class="line">    <span class="keyword">if</span> (owner <span class="keyword">is</span> HasDefaultViewModelProviderFactory)</span><br><span class="line">        owner.defaultViewModelProviderFactory <span class="keyword">else</span> instance</span><br></pre></td></tr></table></figure><p>首先看是否实现了HasDefaultViewModelProviderFactory，否则返回instance，instance就是NewInstanceFactory：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> instance: NewInstanceFactory</span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = NewInstanceFactory()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance!!</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而NewInstanceFactory就是new 一个viewmodel的实例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">NewInstanceFactory</span> : <span class="type">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;DocumentExceptions&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            modelClass.newInstance()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InstantiationException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of <span class="variable">$modelClass</span>&quot;</span>, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Cannot create an instance of <span class="variable">$modelClass</span>&quot;</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那我们看看实现了HasDefaultViewModelProviderFactory的情况，我们的MainActivity继承自AppCompatActivity，AppCompatActivity继承自FragmentActivity，FragmentActivity继承自ComponentActivity，而ComponentActivity实现了HasDefaultViewModelProviderFactory接口的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller,</span><br><span class="line">        OnConfigurationChangedProvider,</span><br><span class="line">        OnTrimMemoryProvider,</span><br><span class="line">        OnNewIntentProvider,</span><br><span class="line">        OnMultiWindowModeChangedProvider,</span><br><span class="line">        OnPictureInPictureModeChangedProvider,</span><br><span class="line">        MenuHost &#123;</span><br><span class="line">            .........</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                    getApplication(),</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">    &#125;</span><br><span class="line">            .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是返回SavedStateViewModelFactory，那我们来看看它的create干了什么：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;, extras: <span class="type">CreationExtras</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> key = extras[ViewModelProvider.NewInstanceFactory.VIEW_MODEL_KEY]</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;VIEW_MODEL_KEY must always be provided by ViewModelProvider&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (extras[SAVED_STATE_REGISTRY_OWNER_KEY] != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        extras[VIEW_MODEL_STORE_OWNER_KEY] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> application = extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY]</span><br><span class="line">        <span class="keyword">val</span> isAndroidViewModel = AndroidViewModel::<span class="keyword">class</span>.java.isAssignableFrom(modelClass)</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">constructor</span>: Constructor&lt;T&gt;? = <span class="keyword">if</span> (isAndroidViewModel &amp;&amp; application != <span class="literal">null</span>) &#123;</span><br><span class="line">            findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn&#x27;t need SavedStateHandle</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">constructor</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.create(modelClass, extras)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> viewModel = <span class="keyword">if</span> (isAndroidViewModel &amp;&amp; application != <span class="literal">null</span>) &#123;</span><br><span class="line">            newInstance(modelClass, <span class="keyword">constructor</span>, application, extras.createSavedStateHandle())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newInstance(modelClass, <span class="keyword">constructor</span>, extras.createSavedStateHandle())</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> viewModel = <span class="keyword">if</span> (lifecycle != <span class="literal">null</span>) &#123;</span><br><span class="line">            create(key, modelClass)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;SAVED_STATE_REGISTRY_OWNER_KEY and&quot;</span> +</span><br><span class="line">                <span class="string">&quot;VIEW_MODEL_STORE_OWNER_KEY must be provided in the creation extras to&quot;</span> +</span><br><span class="line">                <span class="string">&quot;successfully create a ViewModel.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是先判断SAVED_STATE_REGISTRY_OWNER_KEY和VIEW_MODEL_STORE_OWNER_KEY存不存在，不存在就创建，方法大同小异，一般是存在的情况，我们来看看，先根据是不是AndroidViewModel去findMatchingConstructor，而findMatchingConstructor是：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> ANDROID_VIEWMODEL_SIGNATURE = listOf&lt;Class&lt;*&gt;&gt;(</span><br><span class="line">    Application::<span class="keyword">class</span>.java,</span><br><span class="line">    SavedStateHandle::<span class="keyword">class</span>.java</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> VIEWMODEL_SIGNATURE = listOf&lt;Class&lt;*&gt;&gt;(SavedStateHandle::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="comment">// it is done instead of getConstructor(), because getConstructor() throws an exception</span></span><br><span class="line"><span class="comment">// if there is no such constructor, which is expensive</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">findMatchingConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    signature: <span class="type">List</span>&lt;<span class="type">Class</span>&lt;*&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Constructor&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">constructor</span> <span class="keyword">in</span> modelClass.constructors) &#123;</span><br><span class="line">        <span class="keyword">val</span> parameterTypes = <span class="keyword">constructor</span>.parameterTypes.toList()</span><br><span class="line">        <span class="keyword">if</span> (signature == parameterTypes) &#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">constructor</span> <span class="keyword">as</span> Constructor&lt;T&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signature.size == parameterTypes.size &amp;&amp; parameterTypes.containsAll(signature)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">&quot;Class <span class="subst">$&#123;modelClass.simpleName&#125;</span> must have parameters in the proper &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;order: <span class="variable">$signature</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是根据你自定义的ViewModel的构造参数去决定给你什么构造函数，你需要application就给你有application的构造函数，你需要saveStateHandle就给你saveStateHandle的构造函数。所以默认的Factory就是根据你是否需要application或者saveStateHandle去反射给你创建实例。</p><p>那好，现在构造函数我们搞清楚了，我们看看我们传进去的TestViewModel::class.java干了什么，那它肯定重写了操作符get，我们看看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">get</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> canonicalName = modelClass.canonicalName</span><br><span class="line">        ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(<span class="string">&quot;<span class="variable">$DEFAULT_KEY</span>:<span class="variable">$canonicalName</span>&quot;</span>, modelClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or</span></span><br><span class="line"><span class="comment"> * an activity), associated with this `ViewModelProvider`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The created ViewModel is associated with the given scope and will be retained</span></span><br><span class="line"><span class="comment"> * as long as the scope is alive (e.g. if it is an activity, until it is</span></span><br><span class="line"><span class="comment"> * finished or process is killed).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key        The key to use to identify the ViewModel.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelClass The class of the ViewModel to create an instance of it if it is not</span></span><br><span class="line"><span class="comment"> * present.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A ViewModel that is an instance of the given type `T`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>, modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> viewModel = store[key]</span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        (factory <span class="keyword">as</span>? OnRequeryFactory)?.onRequery(viewModel)</span><br><span class="line">        <span class="keyword">return</span> viewModel <span class="keyword">as</span> T</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;ControlFlowWithEmptyBody&quot;</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> extras = MutableCreationExtras(defaultCreationExtras)</span><br><span class="line">    extras[VIEW_MODEL_KEY] = key</span><br><span class="line">    <span class="comment">// AGP has some desugaring issues associated with compileOnly dependencies so we need to</span></span><br><span class="line">    <span class="comment">// fall back to the other create method to keep from crashing.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        factory.create(modelClass, extras)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: AbstractMethodError) &#123;</span><br><span class="line">        factory.create(modelClass)</span><br><span class="line">    &#125;.also &#123; store.put(key, it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是调用了两个参数的get方法，第一个参数就是我们viewmodel的包名以此保证唯一性，第二个参数就是我们传进来的TestViewmodel。两个参数的get方法先从store里去获取viewmodel，这个sotre是ViewModelstore，是用来管理viewmodel的，等会说。然后判断你是否继承了抽象类viewmodel，如果存在就直接给你返回。否则，在最后调用factory的create方法去给你new 一个viewmodel的实例，然后存在viewmodelstore里面。这就是为什么我们直接去new ViewMdoel没用的原因，虽然不会报错，但是它就是一个普通的类，没啥用。</p><h3 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a><strong>ViewModelStore</strong></h3><p>那viewmodelstore是个啥玩意儿呢？在上面我们知道，viewmodel的存取都是在viewmodelStore里面的，那viewmodel的生死消亡都跟viewmodelstore有关。我们刚刚分析ViewModelProvider的构造函数的时候只是分析了第二个参数factory，第一个参数我们还没分析我们看看：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">constructor</span>(</span><br><span class="line">    owner: ViewModelStoreOwner</span><br><span class="line">) : <span class="keyword">this</span>(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))</span><br></pre></td></tr></table></figure><p>我们的activity肯定实现了ViewModelStoreOwner，分析它的继承关系可以发现，componentActivity实现了这个接口，我们看看它的getViewModelStore方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureViewModelStore();</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是尝试从NonConfigurationInstances中去获取viewmodelstore，获取不到就直接new ，那NonConfigurationInstances是干什么的呢？它是Android官方提供给因配置改变而要保存的数据的。那在什么时候保存的呢？在onRetainNonConfigurationInstance()中。而Activity重建的时候生命周期：onPause —-&gt; onSaveInstanceState —-&gt;onStop —&gt;onRetainCustomNonConfigurationInstance —&gt; onDestroy —&gt; onCreate —&gt; onStart —-&gt;  onRestoreInstanceState —-&gt; onResume           onStop和onDeatory的时候会在onRetainCustomNonConfigurationInstance (后面简称onRCNC) 中保存的自定义非配置实例。他的前身是onRetainNonConfigurationInstance（简称onRNC），但是现在onRCNC已经被废弃，onRNC被final修饰不能被复写，官方更推荐我们用viewmodel去保存非配置实例，而在onRetainNonConfigurationInstance()中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Maintain backward compatibility.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">custom</span> <span class="operator">=</span> onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStore;</span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">        <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">            viewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span> &amp;&amp; custom == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">    nci.custom = custom;</span><br><span class="line">    nci.viewModelStore = viewModelStore;</span><br><span class="line">    <span class="keyword">return</span> nci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是先看看有没有已经保存的NonConfigurationInstances，有就直接把里面的viewmodelstore拿出来再存在新的NonConfigurationInstances里面，否则就创建一个viewmodel，那viewmode和viewmodelStore的存取我们都清楚了，而viewmodelStore也只是个map来保存viewmodel的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那他的clear方法在哪里调用的呢？也就是说viewmodel是在啥时候被清除的？肯定跟ComponentActivity的生命周期有关，研究他的生命周期你会发现，在初始化中有这么一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">                    <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    <span class="comment">// Clear out the available context</span></span><br><span class="line">                    mContextAwareHelper.clearAvailableContext();</span><br><span class="line">                    <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">                    <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                        getViewModelStore().clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用lifecycle的特性当activity即将detory的时候，调用isChangingConfigurations()去判断是否能因配置变更而导致的destory，如果是正常detroy的话就调用viewmodelstore.clear真正地清除viewmodel。</p><p>至此viewmodel的出生和消亡我们就分析结束了，在lifecycle的基础上他的实现还是很简单的。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack之三：LiveData</title>
      <link href="/rq/e6b8b5a8.html"/>
      <url>/rq/e6b8b5a8.html</url>
      
        <content type="html"><![CDATA[<p>上篇我们介绍了Lifecyle，这篇继续了解一下Jetpack系列之二：Livedata。</p><h2 id="1-什么是LiveData？"><a href="#1-什么是LiveData？" class="headerlink" title="1.什么是LiveData？"></a>1.什么是LiveData？</h2><p>LiveData是一种类，持有可被观察的数据。LiveData是一种可感知生命周期的组件，它是基于lifecycle组件的，意味着该组件重视其他app组件的生命周期，如Activity、Fragment、Service。该组件能确保，仅仅在Activity\Fragment\Service等组件都处于活跃的生命周期状态的时候，才去更新app组件。Activity、Fragment不用担心会出现内存泄露，在Activity、Fragment销毁时，LiveData会自动解除其注册关系。</p><h2 id="2-为什么要用Livedata？"><a href="#2-为什么要用Livedata？" class="headerlink" title="2.为什么要用Livedata？"></a>2.为什么要用Livedata？</h2><ol><li><p>LiveData能确保UI和数据状态相符</p><blockquote><p>因为是观察者模式，LiveData会在生命周期状态改变时，通知观察者<br>可以在观察者对象中进行UI的更新操作</p></blockquote></li><li><p>LiveData没有内存泄露</p><blockquote><p>观察者和Lifecycle对象绑定，能在销毁时自动解除注册</p></blockquote></li><li><p>LiveData不会给已经停止的Activity发送事件</p><blockquote><p>如果观察者处于非活跃状态，LiveData不会再发送任何事件给这些Observer对象</p></blockquote></li><li><p>LiveData能确保不再需要手工对生命周期进行处理</p><blockquote><p>UI组件仅仅需要对相关数据进行观察<br>LiveData自动处理生命周期状态改变后，需要处理的代码。</p></blockquote></li><li><p>LiveData能保证数据最新</p><blockquote><p>一个非活跃的组件进入到活跃状态后，会立即获取到最新的数据<br>不用担心数据问题</p></blockquote></li><li><p>LiveData在横竖屏切换等Configuration改变时，也能保证获取到最新数据</p><blockquote><p>例如Acitivty、Fragment因为屏幕选装导致重建, 能立即接收到最新的数据</p></blockquote></li><li><p>LiveData能资源共享</p><blockquote><p>如果将LiveData对象扩充，用单例模式将系统服务进行包裹。这些服务就可以在app中共享。<br>只需要LiveData和系统服务connect，其他观察者只需要监视LiveData就能获取到这些资源</p></blockquote></li></ol><h2 id="3-简单使用"><a href="#3-简单使用" class="headerlink" title="3.简单使用"></a>3.简单使用</h2><p>首先在你的模块build.gradle里面添加依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.5.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的一种使用是MutableLivedata：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mLivedata = MutableLiveData&lt;String&gt;()<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: ActivityMainBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mLivedata.observe(<span class="keyword">this</span>) &#123;<span class="comment">//2</span></span><br><span class="line">            mBinding.textView.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            mLivedata.value = num++.toString()<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里用了viewbinding代替了findviewbyid。首先在1处定义了mLivedata，类型是MutableLiveData，MutableLiveData是LiveData的子类，暴露出了setValue和postValue两个方法。然后在2处订阅，传入的第一个参数是拥有生命周期的组件，一般是Activity或者Fragment或者是fragment里面的veiw，第二个参数是收到数据之后的回调，这里就是用一个textVeiw将值呈现了出来。然后在3处给一个按钮设置监听，每按一次就发送一个数据。大概的用法还是比较简单的。</p><p>再看几个比较进阶的用法：</p><p>如果我们想要在LiveData对象分发给观察者之前对其中存储的值进行更改，可以使用Transformations.map()和Transformations.switchMap()</p><p>map()是在数据分发之前进行一些处理，而switchMap更多是在多条LiveData下选择一条LiveData：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mLivedata = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: ActivityMainBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mLivedata.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            mBinding.textView.text = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            mLivedata.value = num++</span><br><span class="line">        &#125;</span><br><span class="line">        Transformations.map(mLivedata) &#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@map</span> it - <span class="number">10000</span></span><br><span class="line">        &#125;.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, it.toString(), Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        Transformations.switchMap(mLivedata) &#123;<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">val</span> mutableLiveData1 = MutableLiveData&lt;String&gt;()</span><br><span class="line">            <span class="keyword">val</span> mutableLiveData2 = MutableLiveData&lt;String&gt;()</span><br><span class="line">            mutableLiveData1.value = (it + <span class="number">10</span>).toString()</span><br><span class="line">            mutableLiveData2.value = (it - <span class="number">10</span>).toString()</span><br><span class="line">            <span class="keyword">if</span> (it &lt; <span class="number">10</span>) <span class="keyword">return</span><span class="symbol">@switchMap</span> mutableLiveData1</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span><span class="symbol">@switchMap</span> mutableLiveData2</span><br><span class="line">        &#125;.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            mBinding.textView2.text = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法很简单，在1处使用Transformations.map对值进行处理，这里就是对原值减10000，然后observer新的LiveData，这里就是弹一个吐司。在2处Transformations.switchMap(mLivedata)对原值进行判断，大于10就返回mutableLiveData1，否则mutableLiveData2，然后对新的LiveDataObserver显示在TextView上面。</p><p>这两种用法不是很常用。还有一种用法，当有多条LiveData时，我们需要合并成一条LiveData，这时候可以用MediatorLiveData：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mediatorLiveData = MediatorLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mutableLiveData1=MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mutableLiveData2 = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: ActivityMainBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            mutableLiveData1.value = num+<span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">        mBinding.button2.setOnClickListener &#123;</span><br><span class="line">            mutableLiveData2.value = num-<span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">        mediatorLiveData.addSource(mutableLiveData1)&#123;</span><br><span class="line">            mediatorLiveData.value = it</span><br><span class="line">        &#125;</span><br><span class="line">        mediatorLiveData.addSource(mutableLiveData2)&#123;</span><br><span class="line">            mediatorLiveData.value = it</span><br><span class="line">        &#125;</span><br><span class="line">        mediatorLiveData.observe(<span class="keyword">this</span>)&#123;</span><br><span class="line">            mBinding.textView.text = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建了两条MutableLiveData，然后定义了一个MediatorLiveData，用了两个按钮，分别发送LiveData1和LiveData2的值，再将他们加入到MediatorLiveData，MediatorLiveData本身也是LiveData，再对其Observer这样就达到合并多条LiveData的值。到这里LiveData的一些简单用法就是这些了。那大家有没有疑问，Activity是怎么感知LiveData发送了值的？LiveData为什么不会造成内存泄漏？我们来看看它的源码，把它扒个精光。</p><h2 id="4-原理"><a href="#4-原理" class="headerlink" title="4.原理"></a>4.原理</h2><p>首先我们看LiveData的源码和看LifeCycle的源码一样，从我们写的代码入手，那就是Observer：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;<span class="comment">//1</span></span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);<span class="comment">//2</span></span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注解在主线程运行，1处的条件判断说明我们在Destroy去Observer是没用的，2处把我们传进来的owner和observer封装成了LifecycleBoundObserver，它的作用我们等会分析，3处把wrapper添加进了一个map里面，说明我们的liveData是可以有多处Observer的，之后是一些安全判断，最后在4处将我们的wrapper注册到lifeCycle，这不就是我们lifeCycle里面学的嘛，那这个LifecycleBoundObserver肯定实现了LifeCycleObserver我们看一看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        Lifecycle.<span class="type">State</span> <span class="variable">currentState</span> <span class="operator">=</span> mOwner.getLifecycle().getCurrentState();<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (currentState == DESTROYED) &#123;<span class="comment">//2</span></span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Lifecycle.<span class="type">State</span> <span class="variable">prevState</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (prevState != currentState) &#123;<span class="comment">//3</span></span><br><span class="line">            prevState = currentState;</span><br><span class="line">            activeStateChanged(shouldBeActive());<span class="comment">//4</span></span><br><span class="line">            currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，实现了LifecycleEventObserver来感知我们的activity生命周期，那肯定在生命周期回调的方法onStateChanged里面做了文章，我们看，在1处获取了activtiy当前的生命周期状态，2处，处于destroy的话就移除Observer，这说明了当我 们的activtiy销毁的时候livedata会自动解除监听，所以才不会造成内存泄漏。然后在3处判断如果当前状态和即将发生的状态不一样就执行activeStateChanged(shouldBeActive())，那我们看看shouldBeActive：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span></span><br><span class="line"><span class="comment">         * any more events. For instance, for an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state is reached</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;right before&lt;/b&gt; Activity&#x27;s &#123;<span class="doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DESTROYED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Initialized state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this is</span></span><br><span class="line"><span class="comment">         * the state when it is constructed but has not received</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INITIALIZED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Created state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CREATED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Started state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached in two cases:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;</span></span><br><span class="line"><span class="comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        STARTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Resumed state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span></span><br><span class="line"><span class="comment">         * is reached after &#123;<span class="doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Compares if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state State to compare with</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是将当前状态和START状态相减，大于等于0为true，那也就是START和RSUME这两个状态，LiveData才有效，这也符合用户使用习惯，activtiy也是在START和RSUME呈现页面。</p><p>再来看看activeStateChanged()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">    <span class="comment">// owner</span></span><br><span class="line">    mActive = newActive;</span><br><span class="line">    changeActiveCounter(mActive ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">        dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断mActive是否和newActive相等，mActive初始状态是不活越的，为flase，所以在newActive为false时也就是activty为不活越的状态就会直接返回而不会直接分发值，之后如果是活跃的状态就changeActiveCounter(mActive ? 1 : -1);改变activeCounter的值，这个我们用不到，不用管，主要是dispatchingValue，如果是活跃状态就分发值，并且将当前的this传进去，我们看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要操作在下面的do while循环里面，判断我们传进来的ObserverWrapper是否为空，不为空就执行considerNotify(initiator);为空就循环遍历我们一开始observer里面添加的observerWrapper，为什么是for循环？因为我们刚才说了，一个liveData可以被多个生命周期组件观测。所以在这里为null的时候从Observers这个map里面去拿。我们看看considerNotify(initiator);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;<span class="comment">//2</span></span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;<span class="comment">//3</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1处判断，不活越就直接结束。在2处是一些边界处理，上面的注释也说了当activty生命周期改变时，还未来的及改变mActive的值，此时应该先更改活跃的状态再分发值，这其实不重要我们一般碰不到。然后在3处判断上次的version是否比当前的mVersion大，否则再在下面更新mLastVersion，并且执行onChange，也就是我们再observer方法里面传进来的lamda表达式。一开始mLastVersion和mVersion都是为-1的，所以不会执行下面的回调。到这里Observer方法我们从始至终理解了一边。那一开始我们的onChanged不会回调，那什么时候会呢？答案在setValue里面，我们看一看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解说明，setValue是在主线程执行，然后mVersion++；因为一开始mVersion是等于mLastVersion的，现在++了，肯定比mLastVersion大，之后dispatchingValue(null)，注意看，这时候传入的值为null，也就是我们刚刚说的dispatchingValue传入值为null的时候会for遍历所有的Oberver然后considerNotify，也就到了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候mVsersion小于mLastVersion，所以就是会执行onChanged，也就是我们传进来的lamda表达式，这就说清楚了为什么每次setValue，activity都能收到值得原因啦。那我们再看看liveData的另外一个方法，postValue：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> postTask;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;<span class="comment">//1</span></span><br><span class="line">        mPendingData = value;<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mPostValueRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            setValue((T) newValue);<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>postValue是用来在子线程向liveData发送值的，首先判断mPendingData的值是不是还没设置过，是的话才会分发值，并且将value赋给mPendingData，然后将mPostValueRunnable扔到主线程运行，mPostValueRunnable里面把mPendingData赋值给newValue，再将mPendingData置为未设置，最后执行的就是setValue；其实postToMainThread也就是用Handler发送一个消息到主线程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postToMainThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                mMainHandler = createAsync(Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    mMainHandler.post(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那你们有没有发现一个问题，既然setValue是用Handler发一个消息到主线程，而Handler消息是个队列，那假如我同时postValue多次，但由于前面的消息还没处理完，mPostValueRunnable还没有运行，mPendingData还没有被置为NOT_SET，postTask就一直为false，所以后面的postValue直接return了，造成我中间postValue的值直接被覆盖了，从而只收到了最新postValue的值，造成了中间值丢失的问题。解决问题很简单，自己切换到主线程然后用setValue，setValue是不会丢值得。</p><p>至此，LiveData的源码分析的差不多了，至于liveData的其他什么方法比如说，observerForever，rmoveobserverForever，都比较简单了，而且也不常用，相信你把这些基础的搞懂，其他的不会太难理解。</p><h2 id="LiveData数据倒灌"><a href="#LiveData数据倒灌" class="headerlink" title="LiveData数据倒灌"></a>LiveData数据倒灌</h2><p>数据倒灌简而言之就是我们并没有给livedata设置数据而收到了旧的数据。</p><p>LiveData的数据倒灌问题。就是当我们用LiveData去发送数据发生事件的时候，你会发现事件会多次发生。我们知道我们的LiveData是在onCreate去Observe的，并且通过源码我们知道，Observer的时候内部会new 一个LifecycleBoundObserver，并且将observe.mLastVersion置为默认值-1，但是此时LiveData的mVersion是没有改变的。而我们的LiveData一般是放在viewmoodel中的，liveData肯定比Activity活的时间长，假如我们在onCreate里去Observe并且给LiveData发送数据，在此过后mVersion是++了的也就是说mVersion至少是大于初始值-1的，假如此时Activtiy重建，重走onCreate方法，此时mVersion是保存在LiveData里面，LiveData是在viewmodel里面，LiveData的实例没有被重建，但是重新走了onCreate，重新Observe了，又重新new了一个LifecycleBoundObserver，也就是mLastVersion为-1，所以此时mLastVersion&lt;mVersion，会回调我们的onChanged()。这就是为什么用LiveData发送事件会被消费多次。而数据多贴一遍我们也不会觉得有问题。但是这其实也不是LiveData的一个bug，liveData设计理念就是专注于给UI层发送数据，对于事件这种我们更应该使用flow或者rxjava。但是把LiveData改改也能用：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLiveData</span>&lt;<span class="type">T</span>&gt; : <span class="type">MutableLiveData</span>&lt;<span class="type">T</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mPending = AtomicBoolean(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">observe</span><span class="params">(owner: <span class="type">LifecycleOwner</span>, observer: <span class="type">Observer</span>&lt;<span class="type">in</span> <span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasActiveObservers()) &#123;</span><br><span class="line">            Log.w(</span><br><span class="line">                <span class="string">&quot;SingleLiveEvent&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Multiple observers registered but only one will be notified of changes.&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.observe(owner) &#123; t -&gt;</span><br><span class="line">            <span class="keyword">if</span> (mPending.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                observer.onChanged(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(t: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">        mPending.<span class="keyword">set</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">super</span>.setValue(t)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicBoolean是通过原子方式更新 boolean 值，能够保证线程安全。这也是官方Demo里面的解决方案，用个boolean记录一次value是否被消费。一次setValue对应一次onChanged并且这个Boolean值是保存在LiveData中的，这样就能用于发送事件了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack之二：Databinding和Navigation的使用</title>
      <link href="/rq/a365d41.html"/>
      <url>/rq/a365d41.html</url>
      
        <content type="html"><![CDATA[<p>DataBinding&#x2F;ViewBinding和Navigation的源码分析在我看来价值不大，这里只是做一些使用的说明。</p><h1 id="DataBinding-x2F-ViewBinding"><a href="#DataBinding-x2F-ViewBinding" class="headerlink" title="DataBinding&#x2F;ViewBinding"></a>DataBinding&#x2F;ViewBinding</h1><h2 id="1-什么是DataBinding，什么是ViewBinding？两者有什么区别"><a href="#1-什么是DataBinding，什么是ViewBinding？两者有什么区别" class="headerlink" title="1.什么是DataBinding，什么是ViewBinding？两者有什么区别"></a>1.什么是DataBinding，什么是ViewBinding？两者有什么区别</h2><p>还记得被findViewById支配的恐惧吗 在还在用 <code>java</code>的时候 每次编写<code>Activity</code>的时候都需要用大量代码量去findViewById 到后来出现了黄油刀Butterknife 但是依旧需要去声明变量；然后到了<code>kotlin</code>第一次接触<code>kotlin-android-extensions</code>插件 卧槽这玩意也太香了吧 然而用着用着 这玩意就被弃用了，之后黄油刀Butterknife也被废弃了。之后就被viewbinding替代了，然后由于viewbing引入会拖垮编译速度，之后又加入了databinding。</p><p><strong>ViewBinding</strong> 相当于是 <strong>DataBinding</strong> 的阉割版 只是做到了能够快速简单的获得布局中的<code>View</code> 也就是视图绑定； 而 <strong>DataBinding</strong>  可以做到数据绑定 也就是view和数据的双向绑定，但是目前它的双向绑定有坑，我的建议是不要用，这里也不会去介绍它的数据绑定，感兴趣可自行查阅。</p><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><p>先讲viewbinding </p><p>首先在build.gradle中加入：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    .....</span><br><span class="line">    viewBinding&#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后sysnc一下项目，之后在activtiy中去获取viewbinding的实例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding: ActivityMainBinding <span class="keyword">by</span> lazy &#123; ActivityMainBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(mBinding.root)</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统会根据的xml布局文件名字生成一个Binding类，比如我们的MainActivity生成的viewbinding类就是ActivityMainBinding，这里就是通过懒加载去ActivityMainBinding.inflate(layoutInflater)渲染布局，接下来setContentView(mBinding.root)的参数view也改为binding.root，然后就可以直接用你的binding去获取的view，view的名字就是他的id：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321141213.png"></p><p>这样我们就少去了findviewbyId 的流程，而是直接用view的id。</p><p>databinding的使用方法略有不同，手先在build.gradle中：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    .....</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sysnc一下，然后xml需要改成databinding 的形式系统才会给你生成对应的类，快捷方法是点击顶部的标签，Alt+Enter快捷键：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321141811.png"></p><p>选择第一个Convert to databinding layout，就变成这个样子了：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321141901.png"></p><p>之后在代码中获取的方式就和viewbinding一样了。</p><p>总结：</p><p>1.引入依赖</p><p>2.如果是databinding则要将xml改成databinding的形式</p><p>3.用系统生成的Binding类去inflate渲染布局</p><p>4.binding.root替代渲染的view</p><p>在recyclerview中的用法和这里差不多，这里不多说了，在这之后文章里用的都是viewBinding。</p><h1 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h1><h2 id="1-什么是Navigation？"><a href="#1-什么是Navigation？" class="headerlink" title="1.什么是Navigation？"></a>1.什么是Navigation？</h2><p>翻译过来就是导航，应用官方的话就是说：</p><p>导航是指支持用户导航、进入和退出应用中不同内容片段的交互。Android Jetpack 的导航组件可帮助您实现导航，无论是简单的按钮点击，还是应用栏和抽屉式导航栏等更为复杂的模式，该组件均可应对。导航组件还通过遵循<a href="https://developer.android.google.cn/guide/navigation/navigation-principles?hl=zh-cn">一套既定原则</a>来确保一致且可预测的用户体验。</p><p>简单来说就是负责页面之间的跳转的。</p><h2 id="2-为什么需要Navigation？"><a href="#2-为什么需要Navigation？" class="headerlink" title="2.为什么需要Navigation？"></a>2.为什么需要Navigation？</h2><p>导航组件提供各种其他优势，包括以下内容：</p><ul><li>处理 Fragment 事务。</li><li>默认情况下，正确处理往返操作。</li><li>为动画和转换提供标准化资源。</li><li>实现和处理深层链接。</li><li>包括导航界面模式（例如抽屉式导航栏和底部导航），用户只需完成极少的额外工作。</li><li><a href="https://developer.android.google.cn/guide/navigation/navigation-pass-data?hl=zh-cn#Safe-args">Safe Args</a> - 可在目标之间导航和传递数据时提供类型安全的 Gradle 插件。</li><li><code>ViewModel</code> 支持 - 您可以将 <code>ViewModel</code> 的范围限定为导航图，以在图表的目标之间共享与界面相关的数据。</li></ul><h2 id="3-如何使用？"><a href="#3-如何使用？" class="headerlink" title="3.如何使用？"></a>3.如何使用？</h2><p>首先是导入依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.navigation:navigation-fragment-ktx:2.5.3&quot;</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.navigation:navigation-ui-ktx:2.5.3&quot;</span></span><br></pre></td></tr></table></figure><p>然后我们在开始前先了解一下Navigation由哪几部分组成：</p><p>Naviagation由以下三个关键部分组成：</p><ul><li>导航图（NavGraph）：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为<em>目标</em>）以及用户可以通过应用获取的可能路径。</li><li><code>NavHost</code>：显示导航图中目标的空白容器。导航组件包含一个默认 <code>NavHost</code> 实现 (<a href="https://developer.android.google.cn/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn"><code>NavHostFragment</code></a>)，可显示 Fragment 目标。</li><li><code>NavController</code>：在 <code>NavHost</code> 中管理应用导航的对象。当用户在整个应用中移动时，<code>NavController</code> 会安排 <code>NavHost</code> 中目标内容的交换。</li></ul><p>首先是导航图：</p><p>我这里创建了两个Fragment：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321120122.png"></p><p>然后创建导航图，导航图怎么创建呢？右键resource–&gt;new—-&gt;Android Resource File，然后输入文件名称，名字可以自己取，然后Resource Type选择Navigation：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321120310.png"></p><p>创建好了之后你的文件就在res–&gt;navigation文件夹下，然后我们打开，切换到desigin：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321120709.png"></p><p>点击左上角像页面一样的图标：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321120757.png"></p><p>这里就可以选择你要添加的activity或者Fragment页面：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321121624.png"></p><p>添加好图片之后，就可以拖动页面右边的小圆点指向SecondFragment，就表示从FirstFragment跳转到SecondFragment，我这里简单做了两个跳转：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321122042.png"></p><p>然后你会发现xml给我们生成这么些代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/navi_graph&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/firstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/firstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.wssg.androidteach.fragment.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;fragment_second&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_second&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_firstFragment_to_secondFragment3&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/secondFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/secondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.wssg.androidteach.fragment.SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;SecondFragment&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_secondFragment_to_firstFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/firstFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是NaviGraph的代码，startDestination就是一开始的页面，然后一个Fragment标签或者activity标签就是一个页面，name必须是你Fragment或者activity的包名，然后就是action，一个action就是一个跳转，所以一个Fragment可以有多个跳转，在用NaviController跳转的时候指定action的id来实现一个跳转，destination就是目的地嘛，顾名思义就是要跳转到的页面。</p><p>好，NaviGraph有了，现在是NaviHost，在activity的xml布局中点击右上角的搜索符号，搜索NavHost：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321123851.png"></p><p>然后将那个NavHostFragment拖到activity页面里面，NavHost就添加成功了：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321124032.png"></p><p>之后你会在xml发现生成了这样的代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragmentContainerView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;409dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;261dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:defaultNavHost</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:navGraph</span>=<span class="string">&quot;@navigation/navi_graph&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>name必须是NavHostFragment，defaultNavHost设置为true，再指定navGraph为我们的写的navi_graph。</p><p>好，现在NavHost有了，再在代码中用NavController去控制跳转：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; FragmentFirstBinding.inflate(layoutInflater) &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            findNavController().navigate(</span><br><span class="line">                R.id.action_firstFragment_to_secondFragment,</span><br><span class="line">                Bundle().apply &#123; putString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;我传了个数据&quot;</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转代码就是：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">findNavController().navigate(R.id.action_firstFragment_to_secondFragment,Bundle().apply &#123; putString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;我传了个数据&quot;</span>) &#125;)</span><br></pre></td></tr></table></figure><p>这是你要传参数的情况，不传参数你就直接去掉bundle就行了：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">findNavController().navigate(R.id.action_firstFragment_to_secondFragment)</span><br></pre></td></tr></table></figure><p>在SecondeFragment里面也是如此，不过是执行action的id不同：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinding <span class="keyword">by</span> lazy &#123; FragmentSecondBinding.inflate(layoutInflater) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> string = arguments?.getString(<span class="string">&quot;data&quot;</span>)<span class="comment">//你如果用bundle传了参数就这样获取</span></span><br><span class="line">        mBinding.textView3.text = string</span><br><span class="line">        mBinding.button.setOnClickListener &#123;</span><br><span class="line">            findNavController().navigate(R.id.action_secondFragment_to_firstFragment)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们navigation就可以完美运行了。传参数的话官方有个Safe Args插件，可以保证类型安全，但是我觉得用起来很麻烦，这种原生传参我觉得更好一些，感兴趣的可以自己查阅一下，这里就不介绍了。</p><p>加入你需要跳转动画的话，打开你的NavGraph：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321125027.png"></p><p>在右侧有Animators一栏，在这里用@引用你的动画文件，我这里是用的系统默认的动画，enter&#x2F;exitAnim是进入&#x2F;结束动画，popEnter&#x2F;popExitAnim是弹入弹出动画。</p><p>动画是加在action里面的，你也可以手动码代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/firstFragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.wssg.androidteach.fragment.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;fragment_second&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_second&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_firstFragment_to_secondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:destination</span>=<span class="string">&quot;@id/secondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:enterAnim</span>=<span class="string">&quot;@anim/nav_default_enter_anim&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:exitAnim</span>=<span class="string">&quot;@anim/nav_default_exit_anim&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Navigation的用法差不多就是这些了，接下来我讲个比较常用的NavigationUI吧，就是很常用的底部导航栏——BottomNavigationView：</p><h1 id="BottomNavigationView"><a href="#BottomNavigationView" class="headerlink" title="BottomNavigationView"></a>BottomNavigationView</h1><p>BottomNavigationView就是官方的底部导航栏。我们看看怎么使用</p><p>首先我们需要创建一个menu，右键res，选择Android Resource File，名字自取，然后编写这样的代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_nav_home&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/home&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;首页&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_nav_marketplace&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/find&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;广场&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_nav_wechat&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/wechat&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;公众号&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_nav_system&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/system&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;体系&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_nav_project&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/project&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;项目&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个item就底部导航栏的一个按钮，icon是按钮的图片，title是按钮的文字。</p><p>然后将我们的theme改成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.WanAndroid&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不然BottomNavgationView背景会变黑，然后再activtiy加入bottomNavigationView：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230321134201.png"></p><p>注意：BottomNavigationView规定，底部按钮不能超过5个，否则会抛出异常。</p><p>指定menu文件，然后在代码中设置按钮监听：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mBinding.bottomNav.setOnItemSelectedListener &#123;</span><br><span class="line">    <span class="keyword">when</span> (it.itemId) &#123;</span><br><span class="line">        R.id.bottom_nav_home -&gt; &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        R.id.bottom_nav_project -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        R.id.bottom_nav_system -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        R.id.bottom_nav_marketplace -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        R.id.bottom_nav_wechat -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@setOnItemSelectedListener</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是用id来判断你点中的是menu里面的哪个按钮，我们一般会搭配viewpager+fragment这也是市面上大多数的app页面设计，搭配viewpager+fragment就是：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mBinding.bottomNav.setOnItemSelectedListener &#123;</span><br><span class="line">    <span class="keyword">when</span> (it.itemId) &#123;</span><br><span class="line">        R.id.bottom_nav_home -&gt; binding.viewPager.currentItem = <span class="number">0</span></span><br><span class="line">        R.id.bottom_nav_marketplace -&gt; binding.viewPager.currentItem = <span class="number">1</span></span><br><span class="line">        R.id.bottom_nav_wechat -&gt; binding.viewPager.currentItem = <span class="number">2</span></span><br><span class="line">        R.id.bottom_nav_system -&gt; binding.viewPager.currentItem = <span class="number">3</span></span><br><span class="line">        R.id.bottom_nav_project -&gt; binding.viewPager.currentItem = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@setOnItemSelectedListener</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>viewpager2+fragment就不多说了，你们应该都会，这里其实就是点击底部按钮，然后将viewpager2翻至对应的页面。</p><p>简单的用法就是这样，还有更多的用法这里说不完了，比如NavigationUI里还有侧滑栏DrawerLayout和顶部导航栏，都是可以和BottomNavigationIView联动的，但是用的不多，感兴趣可自行查阅。BottomNavigationIView还有很多属性，比如说影藏文字，更改选中的颜色等等等等，这里篇幅不够，大家自行挖掘吧。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetpack之一：Lifecycle</title>
      <link href="/rq/9df138cf.html"/>
      <url>/rq/9df138cf.html</url>
      
        <content type="html"><![CDATA[<p>在介绍Lifecycle之前我们先了解一下Jetpack。</p><p>Android已经发展了15年，可以说是比较成熟的技术了，一开始时框架很少，也没有什么规范，所有的代码都是要自己写，比如网络请求，数据库请求，数据解析等等。后来出现了一些框架来帮助开发者快速进行开发，比如XUtils、Volley、OKHttp、EventBus等，随着框架越来越多，一个应用可以有多种技术选型，直接导致应用开发越来越不规范，导致做出来的应用质量参差不齐，这显然不是谷歌想看到的。谷歌随后推出了MVP和MVVM相关的官方例子，效果很一般，而且覆盖只是在架构上，Goole I&#x2F;O 2018大会上推出的Android Jetpack有望解决以上的问题。</p><p>在此之前，相信大家都已经学过Kotlin了，本节课也全采用Kotlin教学。</p><h2 id="1-jetpack是什么？"><a href="#1-jetpack是什么？" class="headerlink" title="1.jetpack是什么？"></a>1.jetpack是什么？</h2><p><strong>Jetpack就是Google官方推出的一套方便开发者的库。</strong></p><p><a href="https://developer.android.google.cn/jetpack?hl=zh-cn">Android Jetpack 开发资源 - Android 开发者  | Android Developers (google.cn)</a></p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230312213948.png" style="zoom:150%;" /><p>Android Jetpack 组件覆盖以下 4 个方面：</p><h5 id="Foundation-基础组件"><a href="#Foundation-基础组件" class="headerlink" title="Foundation (基础组件)"></a>Foundation (基础组件)</h5><ul><li><strong>AppCompat：</strong>使得支持较低的 Android 版本。从以前继承 Activity 到现在继承AppCompatActivity 就是属于这一部分</li><li><strong>Android KTX：</strong>Kotlin 的扩展支持库</li><li><strong>Multidex：</strong>多 dex 文件支持</li><li><strong>Test：</strong>测试支持库</li></ul><h5 id="Architecture-架构组件"><a href="#Architecture-架构组件" class="headerlink" title="Architecture (架构组件)"></a>Architecture (架构组件)</h5><ul><li><strong>DataBinding：</strong>MVVM 的一种实践</li><li><strong>Lifecycle：</strong>管理你的 Activity 和 Fragment 生命周期</li><li><strong>LiveData：</strong>通过观察者模式感知数据变化，类比 RxJava</li><li><strong>Navigation：</strong>处理 Fragment 导航相关逻辑</li><li><strong>Paging：</strong>分页数据加载方案</li><li><strong>Room：</strong>官方数据库</li><li><strong>ViewModel：</strong>通过数据驱动 V 视图发生改变</li><li><strong>WorkManager：</strong>管理后台任务</li></ul><h5 id="Behavior-行为组件"><a href="#Behavior-行为组件" class="headerlink" title="Behavior (行为组件)"></a>Behavior (行为组件)</h5><ul><li><strong>DownloadManager：</strong>管理下载任务</li><li><strong>Media App：</strong>多媒体播放和一些向后兼容的API。主要包含 MediaPlayer 和 ExoPlayer</li><li><strong>Notifications：</strong>提供向后兼容的通知 API，支持 Wear 和 Auto</li><li><strong>Permissions：</strong>权限管理，这个应该都接触过。用于检查和请求应用权限</li><li><strong>Settings：</strong>Preference 相关 API。基本每个应用都会用到</li><li><strong>Share Action：</strong>提供分享操作。这块在国内使用的不多，都是自己封装或者采用第三方方案</li><li><strong>Slices：</strong>可以让应用通过外部（其他 APP）显示 APP 界面（通过设备自带的搜索，语音助手等）</li></ul><h5 id="UI-界面组件"><a href="#UI-界面组件" class="headerlink" title="UI (界面组件)"></a>UI (界面组件)</h5><ul><li><strong>Animations and Transitions：</strong>动画，界面转场等</li><li><strong>Auto：</strong>针对车辆的标准化界面和模式</li><li><strong>Emoji：</strong>表情符号相关</li><li><strong>Fragment：</strong>基础概念</li><li><strong>Layout：</strong>基础概念</li><li><strong>Palette-Colors：</strong>调色板</li><li><strong>TV：</strong>Android TV 开发相关</li><li><strong>Wear：</strong>可穿戴设备（目前主要是手表）开发相关</li></ul><p>官方描述：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230312214555.png"></p><h2 id="2-为什么使用Jetpack"><a href="#2-为什么使用Jetpack" class="headerlink" title="2.为什么使用Jetpack?"></a>2.为什么使用Jetpack?</h2><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230312215058.png"></p><ol><li><p>遵循最佳做法<br>Android Jetpack 组件采用最新的设计方法构建，具有向后兼容性，可以减少崩溃和内存泄露。</p></li><li><p>消除样板代码<br>Android Jetpack 可以管理各种繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于打造出色的应用。</p></li><li><p>减少不一致<br>这些库可在各种 Android 版本和设备中以一致的方式运作，助您降低复杂性。</p></li></ol><h2 id="3-jetpack的使用"><a href="#3-jetpack的使用" class="headerlink" title="3.jetpack的使用"></a>3.jetpack的使用</h2><p>在使用之前，先添加依赖，打开项目根目录的build.gradle，添加google()，如下：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">        repositories &#123;</span><br><span class="line">            google()</span><br><span class="line">            mavenCentral()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在你需要使用jetpack组件的模块的build.gradle里添加依赖，比如我要使用lifecycle：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> lifecycle_version = <span class="string">&quot;x.x.x&quot;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最新的版本请查看Android官网，之后就是最爽的调包环节了。</p><p>上面讲到jetpack分为四个板块，包含了很多组件，但是常用的只有几个：</p><ul><li>LiveData </li><li>ViewModel </li><li>Lifecycle </li><li>Room </li><li>Navigation </li><li>DataBinding&#x2F;ViewBindingg </li><li>Paging</li><li>Dagger2&#x2F;Hilt</li></ul><p>本节课只讲解lifecycle，DataBinding&#x2F;ViewBindingg ，livedata，viewmodel，navigation。Room下节课会给你们讲。paging的话一般是上拉加载，下拉刷新会用到，这里有时间的话可以讲一讲。</p><h1 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h1><p>因为livedata，viewmodel都是基于lifecyccle基础上的，所有先讲讲lifecycle。</p><h2 id="1-什么是lifecycle？"><a href="#1-什么是lifecycle？" class="headerlink" title="1.什么是lifecycle？"></a>1.什么是lifecycle？</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 activity 和 fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。</p><h2 id="2-为什么需要lifecycle？"><a href="#2-为什么需要lifecycle？" class="headerlink" title="2.为什么需要lifecycle？"></a>2.为什么需要lifecycle？</h2><p>我们知道Activity和fragment是由生命周期的，onCreate，onStart，onResume，onPasue，onStop，onDestroy等等。在开发中我们避免不了和他们打交道。比如，现在给你一个需求，要你写一个定时器，在页面退出到主界面时停止计时，你要怎么做？写一个回调在onPasue里面？确实是可以。但是时间一长，功能需求一多，Activity避免不了臃肿，而且处理不好还容易发生内存泄漏。什么是内存泄漏？简言之就是该被回收的对象未被回收。比如一个Activity已经被销毁了，这时候Activity这个对象应该被回收但是被你的回调引用却未被回收，这就是内存泄漏，原理这里就不多讲。因此我们需要一个能管理Activity和Fragment的生命周期的库，这个库就是Lifecycle。</p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p>先构建Observer，字面意思就是观察者，感知生命周期肯定是观察者，被观察者就是拥有生命周期的组件，一般是Activity和Fragment</p><h3 id="方法一，实现DefaultLifecycleObserver："><a href="#方法一，实现DefaultLifecycleObserver：" class="headerlink" title="方法一，实现DefaultLifecycleObserver："></a>方法一，实现DefaultLifecycleObserver：</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RQ527 (Ran Sixiang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> 1799796122<span class="doctag">@qq</span>.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/3/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span>: <span class="type">DefaultLifecycleObserver</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onCreate: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onStart...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onResume...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onPause...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onStop...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver onDestroy...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在activity中添加</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MyObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313002019.png"></p><h3 id="方式二，实现LifecycleEventObserver："><a href="#方式二，实现LifecycleEventObserver：" class="headerlink" title="方式二，实现LifecycleEventObserver："></a>方式二，实现LifecycleEventObserver：</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RQ527 (Ran Sixiang)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> 1799796122<span class="doctag">@qq</span>.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/3/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver2</span>:<span class="type">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event) &#123;</span><br><span class="line">            Lifecycle.Event.ON_CREATE-&gt;&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onCreate: &quot;</span>) &#125;</span><br><span class="line">            Lifecycle.Event.ON_START -&gt; &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onStart...&quot;</span>)&#125;</span><br><span class="line">            Lifecycle.Event.ON_RESUME-&gt;&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onResume...&quot;</span>)&#125;</span><br><span class="line">            Lifecycle.Event.ON_PAUSE-&gt;&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onPause...&quot;</span>)&#125;</span><br><span class="line">            Lifecycle.Event.ON_STOP-&gt;&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onStop...&quot;</span>)&#125;</span><br><span class="line">            Lifecycle.Event.ON_DESTROY-&gt;&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;MyObserver2 onDestroy...&quot;</span>)&#125;</span><br><span class="line">            <span class="keyword">else</span>-&gt;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity添加：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MyObserver2())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313002211.png"></p><p>这么来看。lifecycle的使用还是很简单的，作为jetpack很多组件的基础组件，我们有必要了解一下它的原理。</p><h2 id="4-原理"><a href="#4-原理" class="headerlink" title="4.原理"></a>4.原理</h2><p>相信大家这也是第一次看框架的源码，可能会有点绕，但是多看看还是能理解的，源码就是要多看，越看越简单。</p><p>看源码一个比较好的方法就是带着问题去看，就是为什么去看。为什么？我们想知道lifecycle是怎么感知activity生命周期的嘛。</p><p>那我们先来看我们刚刚写的代码，很简单，就是定义了一个observer，然后在activity里面getlifecycle.addObserver就完事了。</p><p>那我们先来看addObserver。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycle.addObserver(MyObserver())</span><br></pre></td></tr></table></figure><p>要看addObserver，肯定要看看调用者是是谁，是lifecycle，我们点进去看看</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313194225.png"></p><p>那我们再看看mLifecycleRegistry是怎么个事。</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313194349.png"></p><p>是个lifecycleRegistry，并且创建的时候把当前activity传了进去。我们看一看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313195439.png"></p><p>他将我们当前的activity用weakRefernce进行引用了，weakReference是什么，是java里的弱引用。java里的引用分为强引用，软引用，弱引用，和虚引用。强引用就是我们常见的直接用对象点调用他的属性，这里用弱引用是为了防止内存泄露，具体原理这里就不讲了，打脑壳。然后初始化了mState为初始状态。这里参数用的是lifecycleOwner，那说明我们的activity肯定是实现了lifecycleowner的。我们看一看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313200522.png"></p><p>确实实现了lifecycleowner，而lifecycleowner仅仅是一个接口，提供了获取lifecycle的方法：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313200635.png"></p><p>ok，再MainAvtivity里面，我们用lifecycle.addObserver的lifecycle怎么来的我们搞清楚了。现在我们看看addObserver，</p><p>也就是LifecycleRegistry的addObserver：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">    <span class="type">State</span> <span class="variable">initialState</span> <span class="operator">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);<span class="comment">//1</span></span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isReentrance</span> <span class="operator">=</span> mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    <span class="type">State</span> <span class="variable">targetState</span> <span class="operator">=</span> calculateTargetState(observer);<span class="comment">//3</span></span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;<span class="comment">//4</span></span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> Event.upFrom(statefulObserver.mState);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;no event up from &quot;</span> + statefulObserver.mState);</span><br><span class="line">        &#125;</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不看一些null和false或true的判断。我们看看我们传进来的Observer也就是我们定义的MyObserver他干了什么？首先在注释1处他把我们的Observer包装成了ObserverWithState，然后在注释2处把封装起来的ObserverWithState和observer放到mObserverMap里面。3和4分别就是计算状态和判断mObserverMap是否添加过observer。看来就是把我们的observer封装起来用了。那我们再来看看，这里面做了什么事情，首先再4行的地方初始化state，之后在11行获取了刚刚弱引用引用的lifecycleowner也就是我们的activity，之后将observerCount++。最后是有个while循环，这个循环有什么用呢？我们先来看我们一开始在哪里addObserver的，在onCreate对吧。那有没有想过，我可不可以在onStart，onResume的其他生命周期addObserver呢？是可以的。那假如说我在onResume里面addObserver，前面的onCreate，onStart生命周期我们的MyObserver能感知吗？能！原因就在这个while循环，它会逐步将之前的生命周期回调，具体回调方法在statefulObserver.dispatchEvent(lifecycleOwner, event);里面。我们点进去看看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313203245.png"></p><p>其实回调的就是mLifecycleObserver.onStateChanged(owner, event);，有没有很熟悉？我们好像重写过这个方法把。mLifecycleObserver就是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br></pre></td></tr></table></figure><p>我们可以点进lifecycleEventObserver看，其实就是返回LifecycleEventOberver或者FullLifecycleObserver，就是将我们自己写的observer转换了一下：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230313203648.png"></p><p>而FullLifecycleObserverAdapter内部也是调FullLifecycleObserver对应的生命周期方法，也就是我们MyObserver重写的方法：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314145254.png"></p><p>OK，现在addObserver我们看差不多了，但这仅仅是addObserver的一些处理，那我们的MyObserver是怎么感知Activity的周期的呢？我们刚刚寻找lifecycle在哪里创建的时候知道，它是在ComponentActivity里面创建的，而我们的MainActivity也是继承自ComponentActivity并且实现了LifecycleOwner，那感知生命周期肯定在ComponentActivity的生命周期里做了手脚，我们看一看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314150258.png"></p><p>果然，在他的onCreate有这么一行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReportFragment.injectIfNeededIn(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>我们跟进看一看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314150720.png"></p><p>在API29之后注册了一个LifecycleCallbacks并且吧当前activity传了进去，在老版本是添加了一个ReportFragment到当前ACtivity，添加了一个没有界面的Fragment，那我们看看这个Fragment：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314152340.png"></p><p>分别在对应的生命周期dispatch，我们知道Fragment的生命周期是随Activity变化的，Activity onResumeFragment也肯定onResume了，好家伙原来是用一个无形的Fragment寄生在ACtivity上去感知Activity的生命周期的，原来如此，那我们再看看dispatch干了什么：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314152705.png"></p><p>如果是LifecycleRegistryOwner就getLifecycle然后调用handleLifecycleEvent，这里的getLifecycle就是LifecycleRegistry和下面是一样的，那我们看看LifecycleRegistry的handleLifecycleEvent：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314153014.png"></p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314153036.png"></p><p>抛去其他null和状态判断，我们看关键的sync()：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314153133.png"></p><p>分别调用了两个关键的方法：backwardPass和forwardPass并把当前的lifeCycleOwner传了进去，字面意思就是向前，向后移动，就是根据当前的生命周期和即将发生的生命周期进行相减以判断是前移还是后移，onCreate，onStart，onResume就是往前，反之往后，两者差不多，我们就拿向后看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">            mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Map.Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        <span class="type">ObserverWithState</span> <span class="variable">observer</span> <span class="operator">=</span> entry.getValue();<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> Event.downFrom(observer.mState);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;no event down from &quot;</span> + observer.mState);</span><br><span class="line">            &#125;</span><br><span class="line">            pushParentState(event.getTargetState());</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);<span class="comment">//3</span></span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是获取我们在addObserver里面创建的ObserverWithState，也就是我们的MyObserver，然后在2处获取下一个事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Event <span class="title function_">downFrom</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_STOP;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结合要结合宿主的生命周期和LifeCycle的state来看：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230325213614.png"></p><p>最后在3处调用observer的dispatchEvent，然后while循环一步一步回调至对应的生命周期，再看看observer.dispatchEvent(lifecycleOwner, event)：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314154134.png"></p><p>当当当，就是回调我们自己写的MyObserver了，到此我们就明白了，其实就是用一个无形的Fragment寄生Activtiy去感知，那我们再看看API 29之后：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20230314154346.png"></p><p>其实就是API29之后 Application提供了监听acitvity生命周期的方法，之后就是调用ReportFragment的dispatch。至此，lifecycle的源码分析结束了，整体看来还是比较简单的，就是一些回调。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeakCanary为什么这么神奇？</title>
      <link href="/rq/e54d6d21.html"/>
      <url>/rq/e54d6d21.html</url>
      
        <content type="html"><![CDATA[<p>之前简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p><p>在理解LeakCanary源码之前我们先来了解一下java虚拟机里的强引用，软引用，弱引用和虚引用。</p><ul><li>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</li><li>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</li><li>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</li><li>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</li></ul><p>而LeakCanary核心原理就是利用弱引用和引用队列ReferenceQueue来检测Activity&#x2F;Fragment被销毁后是否被回收。如果弱引用的引用对象被垃圾回收器回收，虚拟机就会把这个弱引用加入到与之关联的引用队列中，我们就可以此特性来检查一个对象是否被垃圾回收器回收成功。我们将上述用代码简单实现就是下面这样</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> obj: Any? = Object()</span><br><span class="line">    <span class="keyword">val</span> referenceQueue = ReferenceQueue&lt;Any?&gt;()</span><br><span class="line">    <span class="keyword">val</span> weakReference = WeakReference&lt;Any?&gt;(obj, referenceQueue)<span class="comment">//将对象obj与软引用关联，再将软引用与引用队列关联</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ref = referenceQueue.poll()<span class="comment">//从引用队列取出软引用，此时obj未被回收，取出的是null</span></span><br><span class="line">    println(<span class="string">&quot;gcBefore:<span class="subst">$&#123;ref&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    obj = <span class="literal">null</span><span class="comment">//将obj与Object()的引用断开，此时obj将被GC回收</span></span><br><span class="line">    </span><br><span class="line">    System.gc()</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    </span><br><span class="line">    ref = referenceQueue.poll()<span class="comment">//obj被回收，软引用入列，取出不为null</span></span><br><span class="line">    println(<span class="string">&quot;gcAfter:<span class="subst">$&#123;ref&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcBefore:null</span><br><span class="line">gcAfter:java.lang.ref.WeakReference@60f82f98</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>恰好印证。那么我们知道了核心原理，是否可以实现一个简单版的LeakCanary捏？说干就干！</p><p>首先，我们需要封装一下我们的弱引用，因为往往我们观测的是多个对象，那么就有多个弱引用，所以我们需要给每个弱引用设置一个Key方便查找。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyWeakCanary</span>&lt;<span class="type">T</span>&gt; : <span class="type">WeakReference</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> key: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(referent: T, key: String) : <span class="keyword">super</span>(referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(referent: T, queue: ReferenceQueue&lt;<span class="keyword">in</span> T?&gt;, key: String) : <span class="keyword">super</span>(referent, queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写toString，方便观察值</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;KeyWeakReference(key=<span class="variable">$key</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用简单封装了一下，那么还差个观察者，你要监测肯定需要一个观察者嘛。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监测列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> watchedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保留列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retainedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any?&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(obj: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//生成UUID Key，便于从列表取出相应的引用</span></span><br><span class="line">        <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> reference = KeyWeakReference(obj, queue, key)<span class="comment">//弱引用引用对象，引用对象与弱引用关联</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//登记</span></span><br><span class="line">        watchedReferences[key] = reference</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启子线程监测对象是否泄漏</span></span><br><span class="line">        <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line">        executor.execute &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            moveToRetain(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将符合泄漏的对象转移到留存区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetain</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ref: KeyWeakReference&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            queue.poll()?.also &#123; ref = it <span class="keyword">as</span> KeyWeakReference&lt;Any?&gt; &#125;</span><br><span class="line">            <span class="comment">//回收成功，没有发生内存泄漏的情况</span></span><br><span class="line">            ref?.key.let &#123;</span><br><span class="line">                watchedReferences.remove(it)</span><br><span class="line">                retainedReferences.remove(it)</span><br><span class="line">            &#125;</span><br><span class="line">            ref = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有回收成功，那这个对象那这个对象肯定还在观察区，将其转移到留存区</span></span><br><span class="line">        watchedReferences.remove(key)?.also &#123;</span><br><span class="line">            retainedReferences[key] = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//供外部取出内存泄漏对象的值</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getReferences</span><span class="params">()</span></span>:MutableMap&lt;String,KeyWeakReference&lt;Any?&gt;&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> retainedReferences</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建了观察列表和留存列表，这就好比现在的疫情，从外省回来会被隔离（观察列表），如果观察你有新冠就将你运往隔离医院治疗（留存列表）。然后就是观察方法，传入观察对象，之后用java自带的UUID工具生成唯一的UUID给弱引用方便根据key查询弱引用，之后是弱引用引用对象，引用队列与弱引用关联，再把该弱引用记录进观察区，之后用线程池开启子线程进行内存监测。在内存检测方法里先从引用队列拿出一个引用对象，若为空，则表明它没有被回收，观察区也就不会将它移除，之后下面remove它的时候就不为null，它就会被转移进留存区。之后外界通过这个留存区取出内存泄漏的对象进行分析通知一系列操作。</p><p>然后在主线程测试一下</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> obj:Any? = Object()</span><br><span class="line">    <span class="keyword">val</span> watcher = Watcher()</span><br><span class="line">    watcher.watch(obj)</span><br><span class="line"></span><br><span class="line">    obj = <span class="literal">null</span><span class="comment">//改变obj为null的状态来模拟内存泄漏与否</span></span><br><span class="line">    System.gc()</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">    watcher.getReferences().forEach &#123; (key, reference) -&gt;</span><br><span class="line">        println(<span class="string">&quot;key:<span class="variable">$key</span>,<span class="variable">$reference</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将obj置为null此时调用GC obj将被回收，无输出。再将这行注释，模拟obj被引用的情况，此时GC无法将其回收，留存区有值，打印：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key:ca1485f4-929a-45f2-8977-483f05245f0d,KeyWeakReference(key=ca1485f4-929a-45f2-8977-483f05245f0d)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>证明我们这个简易版的（可以说很丑陋）内存泄漏检测工具是成功的。但实际上，LeakCanary的做法比我们这个更加细节，我们这个只能检测单个对象，而LeakCanary对Activity、Fragment、Service、RootView、Viewmodel都进行了生命周期监听，并且对泄漏对象的通报和分析都是在内部进行的。</p><p>我们现在来看看它的源码，在看他的源码之前我们先问几个问题</p><ol><li>在LeakCanary1.0版本之前是需要在Application里面初始化的，2.0版本之后直接添加依赖就可以用了，那之后的版本它在哪初始化的捏？</li><li>LeakCanary是怎么对Activity、fragment（view和fragment本身）、Service、RootView、Viewmodel进行生命周期的监听的捏？</li><li>检测到泄漏之后是怎么处理的呢？</li></ol><p>相信带着这几个问题去看他的源码会更好理解。</p><p>首先看LeakCanary是在哪里初始化的？其实，在1.0版本之前，LeakCanary都是在自定义的Application里面初始化的，在2.0之后只需添加一行依赖即可。之前也提到过ContentProvider得onCreate()是在Application.onCreate前面执行的，不难想到LeakCanary就是这么许哦的。</p><h5 id="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"><a href="#为什么ContentProvider的onCreate方法是在Application前面执行的呢？" class="headerlink" title="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"></a>为什么ContentProvider的onCreate方法是在Application前面执行的呢？</h5><p>这就要看看ActivityThread的源码了，要知道他们两个的onCreate先后顺序肯定要先理清Application的创建流程，因为Application是伴随整个app的生命周期的。看到ActivityThread的main函数，我们看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">...</span><br><span class="line">        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">        thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line">    ...</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Application和整个app的生命周期那肯定也伴随着主线程的启动与消亡，那肯定跟thread.attach有关，跟进看一看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">sCurrentActivityThread = <span class="built_in">this</span>;</span><br><span class="line">mSystemThread = system;</span><br><span class="line"><span class="keyword">if</span> (!system) &#123;</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                            UserHandle.myUserId());</span><br><span class="line">    RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">    <span class="comment">// mgr为ActivityManagerService实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// mAppThread为ApplicationThread实例,ApplicationThread是ActivityThread与AMS交互的桥梁</span></span><br><span class="line">        mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取AMS之后调用了attachApplication(mAppThread, startSeq)，跟进看一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread thread, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Invalid application interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">callingPid</span> <span class="operator">=</span> Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingUid</span> <span class="operator">=</span> Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);<span class="comment">//这里又调用了AMS的内部方法，跟踪下去</span></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread, <span class="type">int</span> pid, <span class="type">int</span> callingUid, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//判断是否是isolato进程，这个可通过设置service的android:isolatedProcess开启，设置该服务是否</span></span><br><span class="line">       <span class="comment">//作为一个单独的进程运行，如果设置为true，此服务将在与系统其余部分隔离的特殊进程下运行，并且没有自己的权限，与它唯一//的通信是通过服务API（绑定和启动),这个我们一般不会去这么做，直接略过</span></span><br><span class="line">   thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">   thread.bindApplication(processName, appInfo, providerList,<span class="comment">//跟踪到者发现调用了bindApplication</span></span><br><span class="line">           instr2.mClass,</span><br><span class="line">           profilerInfo, instr2.mArguments,</span><br><span class="line">           instr2.mWatcher,</span><br><span class="line">           instr2.mUiAutomationConnection, testMode,</span><br><span class="line">           mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">           isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">           app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">           mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">           buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">           app.mDisabledCompatChanges);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   thread.bindApplication(processName, appInfo, providerList, <span class="literal">null</span>, profilerInfo,<span class="comment">//同样是这个方法的重载</span></span><br><span class="line">           <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, testMode,</span><br><span class="line">           mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">           isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">           app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">           mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">           buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">           app.mDisabledCompatChanges);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们继续点进thread.bindApplication看看它做了什么</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span><br><span class="line"><span class="params">                ProviderInfoList providerList, ComponentName instrumentationName,</span></span><br><span class="line"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span><br><span class="line"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span><br><span class="line"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="type">int</span> debugMode,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> enableBinderTracking, <span class="type">boolean</span> trackAllocation,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> isRestrictedBackupMode, <span class="type">boolean</span> persistent, Configuration config,</span></span><br><span class="line"><span class="params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span><br><span class="line"><span class="params">                String buildSerial, AutofillOptions autofillOptions,</span></span><br><span class="line"><span class="params">                ContentCaptureOptions contentCaptureOptions, <span class="type">long</span>[] disabledCompatChanges,</span></span><br><span class="line"><span class="params">                SharedMemory serializedSystemFontMap)</span> &#123;</span><br><span class="line">...</span><br><span class="line">           </span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);<span class="comment">//看这里</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>找来找去发现没有关于application的函数了，但是我们可以看到最后一行调用了sendMessage函数，并传了H.BIND_APPLICATION这个参数，那么我们点进去看看它是否跟bindApplication有关捏？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what, Object obj)</span> &#123;</span><br><span class="line">        sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="type">int</span> what, Object obj, <span class="type">int</span> arg1, <span class="type">int</span> arg2, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">            Slog.v(TAG,</span><br><span class="line">                    <span class="string">&quot;SCHEDULE &quot;</span> + what + <span class="string">&quot; &quot;</span> + mH.codeToString(what) + <span class="string">&quot;: &quot;</span> + arg1 + <span class="string">&quot; / &quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        msg.obj = obj;</span><br><span class="line">        msg.arg1 = arg1;</span><br><span class="line">        msg.arg2 = arg2;</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);<span class="comment">//发现这里发送了一个消息，传入的message携带的信息就是上面传入的H.BIND_APPLICATION</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现这里调用了mH的sendMessage方法，mH会不会就是Handler?跟进mH看一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br></pre></td></tr></table></figure><p>是H的对象，那H是否继承了Handler方法呢？点进去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//通过Handler进入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:<span class="comment">//根据我们传入的值进入这个分支</span></span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);<span class="comment">//在这里处理了Application的绑定</span></span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                ...</span><br><span class="line">                &#125;</span><br><span class="line">          ...</span><br><span class="line">         &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>发现果然是这样。并且实现了handle Message方法，那上面我们sendMessage最终通过Handler肯定执行handle Message方法，并且根据我们传入的H.BIND_APPLICATION进入了第一个分支，继续跟进handleBindApplication(data);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">          <span class="comment">//创建appContext</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, data.info);<span class="comment">//6660</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在这创建了application</span></span><br><span class="line">            app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);<span class="comment">//6723</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<span class="comment">//6747</span></span><br><span class="line">                    installContentProviders(app, data.providers);<span class="comment">//可以看到这里应该就是启动ContentProvider的地方</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//看函数名不难发现这儿就是回调Applicatio.onCreate的地方  6762</span></span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                      <span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class="line">                      + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，先创建appContext和application，具体创建过程这里就不细细分析了，这里我们只是简单看看ContentProvier和Application的onCreate执行顺序。然后是installContentProviders，那这里肯定就和ContentProvider有关了，等会再分析，先看下面的mInstrumentation.callApplicationOnCreate(app)，我们跟进发现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callApplicationOnCreate</span><span class="params">(Application app)</span> &#123;</span><br><span class="line">        app.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实就是调用了application的onCreate方法，那我们再跟进前面的installContentProviders看看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installContentProviders</span><span class="params">(</span></span><br><span class="line"><span class="params">            Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line">                buf.append(<span class="string">&quot;Pub &quot;</span>);</span><br><span class="line">                buf.append(cpi.authority);</span><br><span class="line">                buf.append(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">                buf.append(cpi.name);</span><br><span class="line">                Log.i(TAG, buf.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ContentProviderHolder</span> <span class="variable">cph</span> <span class="operator">=</span> installProvider(context, <span class="literal">null</span>, cpi,<span class="comment">//在这里进行了ContentProvider的一些创建</span></span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*noisy*/</span>, <span class="literal">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="literal">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (cph != <span class="literal">null</span>) &#123;</span><br><span class="line">                cph.noReleaseNeeded = <span class="literal">true</span>;</span><br><span class="line">                results.add(cph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续跟进installProvider</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ContentProviderHolder <span class="title function_">installProvider</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">            ContentProviderHolder holder, ProviderInfo info,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> noisy, <span class="type">boolean</span> noReleaseNeeded, <span class="type">boolean</span> stable)</span> &#123;</span><br><span class="line">        <span class="type">ContentProvider</span> <span class="variable">localProvider</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        IContentProvider provider;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="literal">null</span> || holder.provider == <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> c.getClassLoader();</span><br><span class="line">                <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> peekPackageInfo(ai.packageName, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// System startup case.</span></span><br><span class="line">                    packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">                &#125;</span><br><span class="line">                localProvider = packageInfo.getAppFactory()</span><br><span class="line">                        .instantiateProvider(cl, info.name);</span><br><span class="line">                provider = localProvider.getIContentProvider();</span><br><span class="line">                <span class="keyword">if</span> (provider == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">&quot;Failed to instantiate class &quot;</span> +</span><br><span class="line">                          info.name + <span class="string">&quot; from sourceDir &quot;</span> +</span><br><span class="line">                          info.applicationInfo.sourceDir);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                    TAG, <span class="string">&quot;Instantiating local provider &quot;</span> + info.name);</span><br><span class="line">                <span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">                localProvider.attachInfo(c, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(<span class="literal">null</span>, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                            <span class="string">&quot;Unable to get provider &quot;</span> + info.name</span><br><span class="line">                            + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            provider = holder.provider;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">&quot;Installing external provider &quot;</span> + info.authority + <span class="string">&quot;: &quot;</span></span><br><span class="line">                    + info.name);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> retHolder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这句英文注释Need to create the correct context for this provider.需要为此提供者创建正确的上下文，那肯定就是他了，跟进localProvider.attachInfo(c, info)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="type">boolean</span> testing)</span> &#123;</span><br><span class="line">        mNoPerms = testing;</span><br><span class="line">        mCallingAttributionSource = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Only allow it to be set once, so after the content service gives</span></span><br><span class="line"><span class="comment">         * this to us clients can&#x27;t change it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            mContext = context;</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span> &amp;&amp; mTransport != <span class="literal">null</span>) &#123;</span><br><span class="line">                mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                        Context.APP_OPS_SERVICE);</span><br><span class="line">            &#125;</span><br><span class="line">            mMyUid = Process.myUid();</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                setReadPermission(info.readPermission);</span><br><span class="line">                setWritePermission(info.writePermission);</span><br><span class="line">                setPathPermissions(info.pathPermissions);</span><br><span class="line">                mExported = info.exported;</span><br><span class="line">                mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="number">0</span>;</span><br><span class="line">                setAuthorities(info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">                setTransportLoggingEnabled(Log.isLoggable(getClass().getSimpleName(),</span><br><span class="line">                        Log.VERBOSE));</span><br><span class="line">            &#125;</span><br><span class="line">            ContentProvider.<span class="built_in">this</span>.onCreate();<span class="comment">//在这里回调了contentProvider的onCreate</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终我们在这发现回调了onCreate。这里我们只是根据函数名+源码注释+猜测去验证了他们两个的执行顺序，更多细枝末节就没看（其实是看不懂），如果大家想真正搞明白ContentProvider和Application完整的创建流程，大家可以去研究一下Android的源码。</p><p>知道了这个之后我们就能理解LeakCanary的做法了，翻其源码也确实是这样。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.squareup.leakcanary.objectwatcher&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那可能有人会疑问，为啥它那定义的清单文件我这也能用捏？其实这是Gradle的功劳，一个app是只能有一个清单文件的，在构建应用的时候，Gradle会合并所有的清单文件，所有文件优先级如下</p><ol><li>Product flavors 和构建类型所指定的清单文件。</li><li>应用程序的主清单文件。</li><li>类库的清单文件。</li></ol><p>具体的合并逻辑就涉及Gradle的东西了，这里就不说了。那好，那我们的第一个问题就解决了。</p><h5 id="LeakCanary是如何监听的"><a href="#LeakCanary是如何监听的" class="headerlink" title="LeakCanary是如何监听的"></a>LeakCanary是如何监听的</h5><p>现在我们看MainProcessAppWatcherInstaller</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcessAppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化了AppWatcher</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,<span class="comment">//对检测对象延迟5秒检测</span></span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="comment">//默认的一些观察器</span></span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()<span class="comment">//日志的初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对每一个检测器进行初始化</span></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Only install after we&#x27;re fully done with init.</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不看核心组件，它比较复杂，我们先看看默认的检测器是如何对Activity、Fragment、Viewmodel等的监听的，先看appDefaultWatchers(application)这个生成默认检测器的方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher),<span class="comment">//对Activity的检测器</span></span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),<span class="comment">//对Fragment和Viewmodel的检测器</span></span><br><span class="line">    RootViewWatcher(reachabilityWatcher),<span class="comment">//对RootView的检测器</span></span><br><span class="line">    ServiceWatcher(reachabilityWatcher)<span class="comment">//对Service的检测器</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建各个检测器，传入objectWatcher和application，这四个监听器我们一个一个来看</p><h6 id="ActivityWatcher"><a href="#ActivityWatcher" class="headerlink" title="ActivityWatcher"></a><strong>ActivityWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<span class="comment">//注册Activity的生命周期监听</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过Activity生命周期对的Application.ActivityLifecycleCallbacks回调来达到监听Activity的结束。其实就是在Activity快onDestroy的时候调用了Application.ActivityLifecycleCallbacks的onActivityDestroyed。然后在onActivityDestroyed里面调用了reachabilityWatcher的expectWeaklyReachable，reachabilityWatcher就是刚刚创建的时候传进来的，我们返回去看看reachabilityWatcher对expectWeaklyReachable的实现。跟踪发现，传进来的是objectWatcher，点击跟踪</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The [ObjectWatcher] used by AppWatcher to detect retained objects.</span></span><br><span class="line"><span class="comment"> * Only set when [isInstalled] is true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">  clock = &#123; SystemClock.uptimeMillis() &#125;,</span><br><span class="line">  checkRetainedExecutor = &#123;</span><br><span class="line">    check(isInstalled) &#123;</span><br><span class="line">      <span class="string">&quot;AppWatcher not installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mainHandler.postDelayed(it, retainedDelayMillis)</span><br><span class="line">  &#125;,</span><br><span class="line">  isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们这里看到传入时间、一个Executor任务执行器，该任务执行器将传入的任务交给主线程的Handler延时处理，延时retainedDelayMillis就是刚刚初始化AppWatcher默认设置的5秒，看看ObjectWatcher对expectWeaklyReachable的实现，</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()<span class="comment">//先清空观察区里已经被回收的对象</span></span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">    .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">      (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">      (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">      <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实之前仿写的LeakCanary有点故意模仿LeakCanary的意思，这不LeakCanary里面也有观察区和留存区，只不过我们为了好获取泄漏对象而用了一个列表存储，这里没有列表存储，而是直接回调出去通知。每次观测之前先清除观察区已经被回收的对象</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;<span class="comment">//不为空说明已经被回收</span></span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就和我们刚仿写的差不多，生成一个唯一的UUID，将弱引用引用对象，再登记，只不过这里它记录了时间。最后执行moveToRetained(key)</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">      <span class="comment">//责任链模式</span></span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候如果还有对象存在观察区，说明已经是可能内存泄漏的对象，然后记录此时的时间，再回调监听，onObjectRetainedListeners在哪设置的呢，在刚刚的核心组件里面，等会分析。</p><p>至此我们分析完LeakCanary是如何监听Activity生命周期和检测是否泄露的。接下来看Fragment和Viewmodel</p><h6 id="FragmentAndViewModelWatcher"><a href="#FragmentAndViewModelWatcher" class="headerlink" title="FragmentAndViewModelWatcher"></a><strong>FragmentAndViewModelWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentAndViewModelWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentDestroyWatchers: List&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt; = run &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">      <span class="comment">//版本的适配</span></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">        AndroidOFragmentDestroyWatcher(reachabilityWatcher)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="comment">//对应androidx版本</span></span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="comment">//对应之前的老版本</span></span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line">    fragmentDestroyWatchers</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        activity: <span class="type">Activity</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span> &#123;</span><br><span class="line">          <span class="comment">//不同版本的fragmentDestroyWatcher进行监听注册</span></span><br><span class="line">        <span class="keyword">for</span> (watcher <span class="keyword">in</span> fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里给activity注册一个监听，然后遍历里面的fragmentwatcher调用incoke设置fragment的监听，其他版本的fragmentDestroyWatcher就不看了和ActivityWatcher差不多，我们看看AndroidXFragmentDestroyWatcher</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AndroidXFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">//监听viewmodel相关</span></span><br><span class="line">      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//对view泄漏的回调</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          view, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">          <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//和activitywatcher一样，不多说</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        fragment, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">val</span> supportFragmentManager = activity.supportFragmentManager</span><br><span class="line">        <span class="comment">//通过fragmentmanager监听fragment生命周期</span></span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">//初始化viewmodel</span></span><br><span class="line">      ViewModelClearedWatcher.install(activity, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实跟activity的差不多，不过是通过activity设置fragment的监听，这里可能有个高阶函数大家没见过，也是invoke的一种用法吧，可以了解一下。好，我们现在来看看对viewmodel的监听过程：</p><h6 id="ViewModelClearedWatcher"><a href="#ViewModelClearedWatcher" class="headerlink" title="ViewModelClearedWatcher"></a><strong>ViewModelClearedWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ViewModelClearedWatcher</span>(</span><br><span class="line">  storeOwner: ViewModelStoreOwner,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span></span><br><span class="line">  <span class="comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span></span><br><span class="line">  <span class="comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//通过反射获取viewmodelstore</span></span><br><span class="line">    <span class="keyword">val</span> mMapField = ViewModelStore::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">    mMapField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    mMapField[storeOwner.viewModelStore] <span class="keyword">as</span> Map&lt;String, ViewModel&gt;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Exception) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">//当此viewmodel销毁时，意味着viewmodelstore里其他的viewmodel也将被销毁</span></span><br><span class="line">    viewModelMap?.values?.forEach &#123; viewModel -&gt;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        viewModel, <span class="string">&quot;<span class="subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      storeOwner: <span class="type">ViewModelStoreOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      reachabilityWatcher: <span class="type">ReachabilityWatcher</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">//这就很巧妙，通过将自己插入viewmodelstore来监控通一宿主的viewmodel</span></span><br><span class="line">      <span class="keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="keyword">object</span> : Factory &#123;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T =</span><br><span class="line">          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="keyword">as</span> T</span><br><span class="line">      &#125;)</span><br><span class="line">      provider.<span class="keyword">get</span>(ViewModelClearedWatcher::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现它居然是个viewmodel，而且它还把它自己插入了宿主的viewmodelstore。把自己当作间谍插入敌军来达到监听的目的。具体viewmodestore是如何管理同一宿主的多个viewmodel的这里就不解释了，大家可以看看viewmodel的源码（其实是我不会）。</p><p>好，再来看看rootView</p><h6 id="RootViewWatcher"><a href="#RootViewWatcher" class="headerlink" title="RootViewWatcher"></a><strong>RootViewWatcher</strong></h6><p>有人可能会问rootview也会发生内存泄露吗？会的，只是不常见，比如，此时我自定义了一个Toast弹窗，弹的是xml的布局，然后Toast被我声明成了静态方法，这时候如果我一弹窗，消失，之后LeakCanary就提醒你了，内存泄漏。自定义的toast代码如下</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ToastUtil &#123;</span><br><span class="line">    <span class="keyword">var</span> mToast: Toast? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inflater = LayoutInflater.from(App.appContext)</span><br><span class="line">        <span class="keyword">val</span> toastView: View = inflater.inflate(R.layout.toast, <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">if</span> (mToast == <span class="literal">null</span>) &#123;</span><br><span class="line">            mToast = Toast(App.appContext)</span><br><span class="line">        &#125;</span><br><span class="line">        mToast!!.setGravity(Gravity.TOP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        mToast!!.duration = Toast.LENGTH_SHORT</span><br><span class="line">        mToast!!.view = toastView</span><br><span class="line">        mToast!!.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的自定义Toast工具是内存泄漏的，为什么捏，因为object单例内部的变量是静态的，所以mToast是静态的，而它又引用了toastView，而toastView是rootView绘制的xml布局（原理见view的绘制），因此一系列下来导致弹完吐司之后，rootView绘制完了而还在被mToastView引用导致内存泄漏。事实上，你会发现，mToast.view已经被废弃，谷歌官方也不建议我们自定义toast，因为这样确实容易造成内存泄漏，更推荐我们自定义snackBar。</p><p>我们再看RootViewWatcher</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RootViewWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (trackDetached) &#123;</span><br><span class="line">      rootView.addOnAttachStateChangeListener(<span class="keyword">object</span> : OnAttachStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> watchDetachedView = Runnable &#123;</span><br><span class="line">          reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">            rootView, <span class="string">&quot;<span class="subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewAttachedToWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.removeCallbacks(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">          mainHandler.post(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Curtains.onRootViewsChangedListeners += listener</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Curtains.onRootViewsChangedListeners -= listener</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也不过是对rootview注册监听，具体的原理不说了，跟Activity的方式差不多。</p><h6 id="ServiceWatcher"><a href="#ServiceWatcher" class="headerlink" title="ServiceWatcher"></a><strong>ServiceWatcher</strong></h6><p>我们再看看ServiceWatcher</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceWatcher</span>(<span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    checkMainThread()</span><br><span class="line">    check(uninstallActivityThreadHandlerCallback == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(uninstallActivityManager == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// hook ActivityThread 里面的 mH 的 mCallback</span></span><br><span class="line">      swapActivityThreadHandlerCallback &#123; mCallback -&gt;</span><br><span class="line">        uninstallActivityThreadHandlerCallback = &#123;</span><br><span class="line">          swapActivityThreadHandlerCallback &#123;</span><br><span class="line">            mCallback</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代理对象，替换原来的Callback</span></span><br><span class="line">        Handler.Callback &#123; msg -&gt;</span><br><span class="line">          <span class="comment">// https://github.com/square/leakcanary/issues/2114</span></span><br><span class="line">          <span class="comment">// On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord</span></span><br><span class="line">          <span class="comment">// instead of an IBinder. This crashes on a ClassCastException. Adding a type check</span></span><br><span class="line">          <span class="comment">// here to prevent the crash.</span></span><br><span class="line">          <span class="keyword">if</span> (msg.obj !<span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 拦截 STOP_SERVICE 消息，这里主要是预处理获取到即将要被 destroy 的 service 对象</span></span><br><span class="line">          <span class="keyword">if</span> (msg.what == STOP_SERVICE) &#123;</span><br><span class="line">            <span class="keyword">val</span> key = msg.obj <span class="keyword">as</span> IBinder</span><br><span class="line">            activityThreadServices[key]?.let &#123;</span><br><span class="line">              onServicePreDestroy(key, it)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行原有逻辑</span></span><br><span class="line">          mCallback?.handleMessage(msg) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// hook 替换原来的ActivityManageService 对象</span></span><br><span class="line">      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;</span><br><span class="line">        uninstallActivityManager = &#123;</span><br><span class="line">          swapActivityManager &#123; _, _ -&gt;</span><br><span class="line">            activityManagerInstance</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态代理对象</span></span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)</span><br><span class="line">        ) &#123; _, method, args -&gt;</span><br><span class="line">          <span class="comment">// hook 到 service 真正 destroy 的时机，这里没法获取到servcie对象，所以要前面的预操作：onServicePreDestroy</span></span><br><span class="line">          <span class="keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;</span><br><span class="line">            <span class="keyword">val</span> token = args!![<span class="number">0</span>] <span class="keyword">as</span> IBinder</span><br><span class="line">            <span class="keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">              <span class="comment">// 回调监测</span></span><br><span class="line">              onServiceDestroyed(token)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行原有逻辑</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">              method.invoke(activityManagerInstance)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              method.invoke(activityManagerInstance, *args)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (invocationException: InvocationTargetException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> invocationException.targetException</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      SharkLog.d(ignored) &#123; <span class="string">&quot;Could not watch destroyed services&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDestroyed</span><span class="params">(token: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 token 匹配到预处理时获取到的 service 对象</span></span><br><span class="line">    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;</span><br><span class="line">      serviceWeakReference.<span class="keyword">get</span>()?.let &#123; service -&gt;</span><br><span class="line">      <span class="comment">// 将 service 对象加入到 watchedObjects 里面，之后就和activity一样了</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          service, <span class="string">&quot;<span class="subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对Service的监控可能就比较奇怪了，因为Service没有对外公开Service生命周期的监听方式，所以只能hook ，所以这里面就涉及了Service的底层原理和hook技术，要真正理解的话得知道Service的底层原理的hook，这里简单说一下：启动Service的时候，在ActivityThread里面都会有记录，启动的Service都会存进mServices里面，onDestory的时候，AMS会用Handler发给ActivityThread告诉某某Service要销毁了，此时ActivityThread就会通过IActivityManger回调Service的onDestory方法，IActivityManger存储了四大组件的周期函数，所以通过它来调用Service的周期函数。因此原理也是这样，通过hook AMS发过来Service onDestory的信息记录Service，进而在IActivityManger回调Service onDestory的时候找到这个Service并监测。</p><h5 id="监听之后是怎么处理的呢？"><a href="#监听之后是怎么处理的呢？" class="headerlink" title="监听之后是怎么处理的呢？"></a>监听之后是怎么处理的呢？</h5><p>现在几个监测的类讲完了，那么第二个问题也解决了，接下来我们看看刚刚还没呢分析的核心组件</p><h6 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a><strong>InternalLeakCanary</strong></h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,<span class="comment">//对检测对象延迟5秒检测</span></span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="comment">//默认的一些观察器</span></span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()<span class="comment">//日志的初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对每一个检测器进行初始化</span></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Only install after we&#x27;re fully done with init.</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看LeakCanaryDelegate.loadLeakCanary(application)</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> LeakCanaryDelegate &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> loadLeakCanary <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过反射实例化InternalLeakCanary，并调用了invoke方法</span></span><br><span class="line">      <span class="keyword">val</span> leakCanaryListener = Class.forName(<span class="string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)</span><br><span class="line">      leakCanaryListener.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>)</span><br><span class="line">        .<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span> (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      NoLeakCanary</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">object</span> NoLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要通过反射实例化咧？因为InternalLeakCanary在另一个模块，而他又是internal，所以只能通过反射了。那我们看看InternalLeakCanary复写的invoke方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">  _application = application<span class="comment">//传入application</span></span><br><span class="line"></span><br><span class="line">  checkRunningInDebuggableBuild()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哦~原来是在这设置的OnObjectRetainedListener</span></span><br><span class="line">  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建gc触发器，这样的GC更容易触发垃圾回收</span></span><br><span class="line">  <span class="keyword">val</span> gcTrigger = GcTrigger.Default</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> configProvider = &#123; LeakCanary.config &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">  handlerThread.start()</span><br><span class="line">  <span class="keyword">val</span> backgroundHandler = Handler(handlerThread.looper)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分析heap dump的启动器,heap dump堆转储，上面提过</span></span><br><span class="line">  heapDumpTrigger = HeapDumpTrigger(</span><br><span class="line">    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,</span><br><span class="line">    configProvider</span><br><span class="line">  )</span><br><span class="line">    <span class="comment">// 应用前后台监听，前后台监听逻辑差异化处理</span></span><br><span class="line">  application.registerVisibilityListener &#123; applicationVisible -&gt;</span><br><span class="line">    <span class="keyword">this</span>.applicationVisible = applicationVisible</span><br><span class="line">    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)</span><br><span class="line">  &#125;</span><br><span class="line">  registerResumedActivityListener(application)</span><br><span class="line">    <span class="comment">//桌面添加图标</span></span><br><span class="line">  addDynamicShortcut(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We post so that the log happens after Application.onCreate()</span></span><br><span class="line">  mainHandler.post &#123;</span><br><span class="line">    <span class="comment">// https://github.com/square/leakcanary/issues/1981</span></span><br><span class="line">    <span class="comment">// We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref</span></span><br><span class="line">    <span class="comment">// which blocks until loaded and that creates a StrictMode violation.</span></span><br><span class="line">    backgroundHandler.post &#123;</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;</span><br><span class="line">          <span class="keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)</span><br><span class="line">          <span class="keyword">is</span> Nope -&gt; application.getString(</span><br><span class="line">            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来我们之前在moveToRetain里回调的方法在这注册的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">      <span class="comment">//责任链模式</span></span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们看看InternalLeakCanary对onObjectRetained()的实现，发现其调用的是scheduleRetainedObjectCheck()</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">    heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的是scheduleRetainedObjectCheck()</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">  <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;<span class="comment">//通过记录时间戳来避免重复检测</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<span class="comment">//记录时间</span></span><br><span class="line">  backgroundHandler.postDelayed(&#123;</span><br><span class="line">    checkScheduledAt = <span class="number">0</span></span><br><span class="line">    checkRetainedObjects()<span class="comment">//检测留存的对象</span></span><br><span class="line">  &#125;, delayMillis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过记录时间避免重复检测，然后向子线程post了一Runnable，瞅瞅checkRetainedObjects</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//是否能够heap dump</span></span><br><span class="line">  <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> Nope) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> NotifyingNope) &#123;<span class="comment">//发送一个通知，用户点击后通过</span></span><br><span class="line">      <span class="comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span></span><br><span class="line">        <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          gcTrigger.runGc()<span class="comment">//分析前再确保一次是否真的泄漏，调用一次GC</span></span><br><span class="line">          retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> nopeReason = iCanHasHeap.reason()</span><br><span class="line">        <span class="comment">//主要是判断是否达到阈值，前台的时候是&gt;=5个会触发，后台是&gt;=1个就会触发</span></span><br><span class="line">        <span class="keyword">val</span> wouldDump = !checkRetainedCount(</span><br><span class="line">          retainedReferenceCount, config.retainedVisibleThreshold, nopeReason</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wouldDump) &#123;</span><br><span class="line">          <span class="keyword">val</span> uppercaseReason = nopeReason[<span class="number">0</span>].toUpperCase() + nopeReason.substring(<span class="number">1</span>)</span><br><span class="line">          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))</span><br><span class="line">          showRetainedCountNotification(<span class="comment">//通知</span></span><br><span class="line">            objectCount = retainedReferenceCount,</span><br><span class="line">            contentText = uppercaseReason</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">        application.getString(</span><br><span class="line">          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果不能堆转储，进行了一些列操作，然后再尝试分析</span></span><br><span class="line">  <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    gcTrigger.runGc()</span><br><span class="line">    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">  <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">    onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">    )</span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dismissRetainedCountNotification()</span><br><span class="line">  <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">&quot;visible&quot;</span> <span class="keyword">else</span> <span class="string">&quot;not visible&quot;</span></span><br><span class="line">    <span class="comment">//分析hprof文件</span></span><br><span class="line">  dumpHeap(</span><br><span class="line">    retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">    retry = <span class="literal">true</span>,</span><br><span class="line">    reason = <span class="string">&quot;<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>&quot;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看能不能堆转储，如果可以，就发送通知，如果不能，做了一系列操作，再尝试分析，其实这跟MAT有点类似，MAT也是不能直接就解析hprof文件，最后你会发现，最终调用的都是dumpHeap()方法，我们看dumpHeap方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">HeapDumpTrigger.kt</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retry: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reason: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> directoryProvider =</span><br><span class="line">    InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)</span><br><span class="line">  <span class="keyword">val</span> heapDumpFile = directoryProvider.newHeapDumpFile()<span class="comment">//创建导出的文件夹</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> durationMillis: <span class="built_in">Long</span></span><br><span class="line">  <span class="keyword">if</span> (currentEventUniqueId == <span class="literal">null</span>) &#123;</span><br><span class="line">    currentEventUniqueId = UUID.randomUUID().toString()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(DumpingHeap(currentEventUniqueId!!))</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Could not create heap dump file&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    saveResourceIdNamesToMemory()</span><br><span class="line">    <span class="keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis</span><br><span class="line">    durationMillis = measureDurationMillis &#123;</span><br><span class="line">      configProvider().heapDumper.dumpHeap(heapDumpFile)<span class="comment">//主要方法，用系统导出堆转储文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile.length() == <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Dumped heap file is 0 byte length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">    lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">    currentEventUniqueId = UUID.randomUUID().toString()</span><br><span class="line">      <span class="comment">//将导出情况回调出去，根据失败和成功给用户弹通知（一般是成功）</span></span><br><span class="line">    InternalLeakCanary.sendEvent(HeapDump(currentEventUniqueId!!, heapDumpFile, durationMillis, reason))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(HeapDumpFailed(currentEventUniqueId!!, throwable, retry))</span><br><span class="line">    <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">        delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(</span><br><span class="line">        R.string.leak_canary_notification_retained_dump_failed</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了文件夹然后是保存时间，ID啊一些的操作，最主要的是configProvider().heapDumper.dumpHeap(heapDumpFile)，查找它的实现其实就是</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDebugHeapDumper : HeapDumper &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(heapDumpFile: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">    Debug.dumpHprofData(heapDumpFile.absolutePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用系统的Debug工具调出hprof文件。之后我们看导出成功回调做了什么事情</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> RemoteWorkManagerHeapAnalyzer : EventListener &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REMOTE_SERVICE_CLASS_NAME = <span class="string">&quot;leakcanary.internal.RemoteLeakCanaryWorkerService&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> remoteLeakCanaryServiceInClasspath <span class="keyword">by</span> lazy &#123;<span class="comment">//返回true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(REMOTE_SERVICE_CLASS_NAME)</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onEvent</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> HeapDump) &#123;</span><br><span class="line">      <span class="keyword">val</span> application = InternalLeakCanary.application</span><br><span class="line">      <span class="keyword">val</span> heapAnalysisRequest =<span class="comment">//构建一个workmanagerRequest，执行一次</span></span><br><span class="line">        OneTimeWorkRequest.Builder(RemoteHeapAnalyzerWorker::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">          <span class="keyword">val</span> dataBuilder = Data.Builder()</span><br><span class="line">            .putString(ARGUMENT_PACKAGE_NAME, application.packageName)</span><br><span class="line">            .putString(ARGUMENT_CLASS_NAME, REMOTE_SERVICE_CLASS_NAME)</span><br><span class="line">          setInputData(event.asWorkerInputData(dataBuilder))</span><br><span class="line">          with(WorkManagerHeapAnalyzer) &#123;<span class="comment">//任务内容在WorkManagerHeapAnalyzer里面</span></span><br><span class="line">            addExpeditedFlag()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;.build()</span><br><span class="line">      SharkLog.d &#123; <span class="string">&quot;Enqueuing heap analysis for <span class="subst">$&#123;event.file&#125;</span> on WorkManager remote worker&quot;</span> &#125;</span><br><span class="line">      <span class="keyword">val</span> workManager = WorkManager.getInstance(application)</span><br><span class="line">      workManager.enqueue(heapAnalysisRequest)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现根据回调的Event类型，回调到了这里，传进来的Event就是HeapDump，可以看到用WorkManager创建了一个异步任务WorkManagerHeapAnalyzer，然后执行</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">RemoteHeapAnalyzerWorker</span>(appContext: Context, workerParams: WorkerParameters) :</span><br><span class="line">  RemoteListenableWorker(appContext, workerParams) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startRemoteWork</span><span class="params">()</span></span>: ListenableFuture&lt;Result&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> heapDump = inputData.asEvent&lt;HeapDump&gt;()</span><br><span class="line">    <span class="keyword">val</span> result = SettableFuture.create&lt;Result&gt;()</span><br><span class="line">    heapAnalyzerThreadHandler.post &#123;<span class="comment">//开启子线程执行分析任务</span></span><br><span class="line">      <span class="keyword">val</span> doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(heapDump, isCanceled = &#123;</span><br><span class="line">        result.isCancelled</span><br><span class="line">      &#125;) &#123; progressEvent -&gt;</span><br><span class="line">        <span class="keyword">if</span> (!result.isCancelled) &#123;<span class="comment">//将分析进度发送出去</span></span><br><span class="line">          InternalLeakCanary.sendEvent(progressEvent)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result.isCancelled) &#123;</span><br><span class="line">        SharkLog.d &#123; <span class="string">&quot;Remote heap analysis for <span class="subst">$&#123;heapDump.file&#125;</span> was canceled&quot;</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InternalLeakCanary.sendEvent(doneEvent)<span class="comment">//结束</span></span><br><span class="line">        result.<span class="keyword">set</span>(Result.success())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getForegroundInfoAsync</span><span class="params">()</span></span>: ListenableFuture&lt;ForegroundInfo&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> applicationContext.heapAnalysisForegroundInfoAsync()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapAnalyzerThreadHandler实际上就是开启一个子线程然后执行runAnalysisBlocking，runAnalysisBlocking里面就是把文件交给了HeapAnalyzer去分析，HeapAnalyzer然后用Shark 分析hprof文件，具体Shark分析的原理就不说了，我也没怎么研究过，我觉得也没有用，会用就行了。Shark是LeakCanary的一个分析hprof文件的模块，因此我们也可以用shark开发一个用于线上的SDK，LeakCanary现在是不支持线上检测的。</p><p>用一张图总结一下它的原理其实就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppWatcher -&gt; objectWatcher:检测到泄漏</span><br><span class="line">objectWatcher -&gt; InternalLeakCanary:5秒后gc还是没回收</span><br><span class="line">InternalLeakCanary-&gt;HeapDumpTrigger:scheduleRetainedObjectCheck()</span><br><span class="line">HeapDumpTrigger-&gt;HeapAnalyzerThreadHandler:再强制GC一次，还是泄漏</span><br><span class="line">HeapAnalyzerThreadHandler-&gt;HeapAnalyzer:dumpHeap()</span><br><span class="line">HeapAnalyzer-&gt;Shark分析:</span><br><span class="line">Shark分析 -&gt; dataBase:发出通知，数据存进数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能还有人会疑另一个叫Leaks的app图标怎么生成的，其实它也不算是个app，它是你app的一部分，不信你把Leaks卸载了，你的app也会跟着卸载。实现这个很简单，用<activity-alias>标签就能实现。示例如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">.</span> <span class="attr">.</span> <span class="attr">.</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    . . .</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activity-alias</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.jason.demo.dynamicshortcut.ShortcutLauncherActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher_alias&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;ActivityAlias&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:targetActivity</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>android:targetActivity</code> 指定所必须的打开的目标 Activity，对应着一个在 <code>AndroidManifest.xml</code> 中申明的 <code>&lt;activity&gt;</code>。<code>android:name</code> 是别名的唯一名称，<strong>不引用实际类</strong>。<code>android:icon</code> 以及 <code>android:label</code> 指定一个新的图标和标签给用户。之后就能看见你的app生成了两个图标。</p><p>你如果不想LeakCanary自动初始化也是可以的。设置如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">&quot;leak_canary_watcher_auto_install&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在你想要初始化的地方AppWatcher.manualInstall即可</p><p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。下面是一些常见的内存泄漏</p><ol><li><p>单例模式引发的内存泄漏</p><p>原因：单例模式里的静态实例持有对象的引用，导致对象无法被回收，常见为持有Activity的引用</p><p>优化：改为持有Application的引用，或者不持有使用的时候传递。</p></li><li><p>集合操作不当引发的内存泄漏</p><p>原因：集合只增不减</p><p>优化：有对应的删除或卸载操作</p></li><li><p>线程的操作不当引发的内存泄漏</p><p>原因：线程持有对象的引用在后台执行，与对象的生命周期不一致</p><p>优化：静态实例+弱引用(WeakReference)方式，使其生命周期一致</p></li><li><p>匿名内部类&#x2F;非静态内部类操作不当引发的内存泄漏</p><p>原因：内部类持有对象引用，导致无法释放，比如各种回调</p><p>优化：保持生命周期一致，改为静态实例+对象的弱引用方式（WeakReference）</p></li><li><p>常用的资源未关闭回收引发的内存泄漏</p><p>原因：BroadcastReceiver，File，Cursor，IO流，Bitmap等资源使用未关闭</p><p>优化：使用后有对应的关闭和卸载机制</p></li><li><p>Handler使用不当造成的内存泄漏</p><p>原因：Handler持有Activity的引用，其发送的Message中持有Handler的引用，当队列处理Message的时间过长会导致Handler无法被回收</p><p>优化：静态实例+弱引用(WeakReference)方式</p></li></ol><p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅学Android性能优化</title>
      <link href="/rq/784dd132.html"/>
      <url>/rq/784dd132.html</url>
      
        <content type="html"><![CDATA[<h1 id="Android性能优化"><a href="#Android性能优化" class="headerlink" title="Android性能优化"></a>Android性能优化</h1><p>性能优化是一个app很重要的一部分，一个性能优良的app从被下载到启动到使用都能给用户到来很好的体验。自然我们做性能优化也是从被下载（安装包优化）、启动（启动优化）、使用（渲染优化、耗电优化、内存优化………）等入手。因为我也是个菜鸟，所有东西都是现学的，所以过程中有任何问题都可以提出来，大家一起长知识。</p><h2 id="安装包优化"><a href="#安装包优化" class="headerlink" title="安装包优化"></a>安装包优化</h2><p>当今手机的内存普遍是128G或者256G，当用户长时间使用，产生了大量数据后，留给app安装的空间可能只有几十个G，甚至更少。所以一个app的大小可能就决定了用户是否选择你。</p><h6 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h6><ol><li><p>清理无用资源</p><p>在app打包的时候一些废弃的代码和无用的资源可能也会被打包，这无疑会增加app的体积。好在Android Studio有这么一个检测无用资源和代码的功能。具体方法是【Refactor】-&gt;【Remove Unused Resources..】</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220707220022.png" style="zoom: 80%;" /><p>再点击【Preview】可查看和选择无用的资源和代码。</p></li><li><p>使用Lint工具检查代码</p><p>Android-Lint是as集成的一个代码检查工具，它可以检测图片是否重复，优化xml布局等等。</p><p>具体使用是Android Studio -&gt; 【Code】-&gt; 【Inspect Code】</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708002040.png"></p><p>Lint问题的种类：</p><ul><li>Correctness 不够完美的编码，比如硬编码、使用过时 API 等</li><li>Performance 对性能有影响的编码，比如：静态引用，循环引用等</li><li>Internationalization 国际化，直接使用汉字，没有使用资源引用等</li><li>Security 不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等</li><li>Usability 可用的，有更好的替换的 比如排版、图标格式建议.png格式 等</li><li>Accessibility 辅助选项，比如ImageView的contentDescription往往建议在属性中定义 等</li></ul><p>具体的一些问题种类的细分我这里就不多说了，可以看看这篇博客:</p><p><a href="https://www.freesion.com/article/250513772/">Android性能优化之 Android Lint - 灰信网（软件开发博客聚合） (freesion.com)</a></p></li><li><p>使用shrinkResources</p><p>我们知道缩小APK大小的方法除了开启混淆外</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">minifyEnabled <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>还有</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">shrinkResources <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里说一下，minifyEnabled 是用来删除无用的代码，shrinkResources是用来删除无用的文件（但其实不是真正的删除，只是保留文   件名但是没有内容）。还有要注意，shrinkResources需要与minifyEnabled 来配合使用，只有当minifyEnabled 为true的时候    shrinkResources才会起作用。但是有时候我们可能添加了一张图片只是作为验证，并未引用，这时候shrinkResources可能就会误删，怎么办呢？很简单，新增一个res&#x2F;raw&#x2F;keep.xml文件，并在文件如下编码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:keep</span>=<span class="string">&quot;@drawable/xxxx,@layout/xxxxx&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>keep里面就列举需要保留误删的资源。</p><p>注：string.xml中没有被引用的怎么设置都不会被删除，shrinkResources删除的只是drawable和layout</p></li><li><p>资源压缩</p><p>在Android中，使用的图片是比较多的，这些图片是很占用资源的，对图片进行压缩和择优选择也是app瘦身的一种方案。</p><p>（1）使用tinypng等图片压缩工具对图片进行压缩，然后替换之前的图片</p><p>（2）尽量将图片都用Webp格式的，其次是JPG格式，再是PNG格式</p><p>（3）使用SVG，矢量图能比位图节约30%~40%的空间</p><p>（4）尽量不要在项目中使用帧动画，一秒就十几张图片也是很耗内存的，使用Lottie等方案</p><p>（5）重用Bitmap，不使用了记得回收</p><p>（6）可以使用微信开源资源文件混淆工具——AndResGuard。一般可以压缩apk的1M左右大。</p></li><li><p>其他方法</p><ul><li><p>动态加载so库文件，插件化开发；</p></li><li><p>统一第三方库，在满足需求的前提下选择体积更小的库，仅引入需要的代码。比如图片加载库，按缓存的需要来我们可以对图片加载库做个排序：Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco，Fresco体积比较大，一般用于图片缓存量比较大的app，比如壁纸app，一般Glide可满足日常需求，Picasso体积最小，它与和Square的网络库一起能发挥最大作用，因为Picasso可以选择将网络请求的缓存部分交给了okhttp实现；</p></li><li><p>避免使用枚举，可能几十个枚举才相当于一张图片，但是积少成多嘛；</p></li><li><p>在多国语言需求不大的情况下可以删除其他国家的语言，只保留中文和英文。</p></li><li><p>再深入一点的还有字节码优化等等等</p></li></ul></li></ol><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>启动优化可以说是性能优化里很重要很重要的一个部分了，用户拿到你的app，第一印象自然是app启动的界面，app启动的流畅度和时间长短，可以说启动性能就是一个app的门面。（最讨厌app启动时候的广告了）</p><p>大家可能都听说过2-5-8原则：</p><ul><li>当用户在0-2秒之间得到响应时，会觉得系统响应得很快</li><li>当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以</li><li>当用户在5-8秒之间得到响应时，会感觉系统响应得速度很慢，但是还能接受</li><li>当用户在超过8秒还无法得到响应时，会感觉系统很垃圾，认为系统已经挂了</li></ul><p>所以不管你的app做的再怎么牛逼，用户点进你的app，反应速度让他很失望，用户也无继续使用的欲望。那么我们应该如何去规划整体的启动优化呢？具体方案如下：</p><h5 id="冷启动、热启动和温启动"><a href="#冷启动、热启动和温启动" class="headerlink" title="冷启动、热启动和温启动"></a>冷启动、热启动和温启动</h5><p>什么是冷启动、热启动、温启动？</p><ul><li>冷启动：系统不存在App进程（如APP首次启动或APP被完全杀死）时启动App称为冷启动。</li><li>热启动：按了Home键或其它情况app被切换到后台，再次启动App的过程。</li><li>温启动：温启动包含了冷启动的一些操作，不过App进程依然存在，这代表着它比热启动有更多的开销。</li></ul><p>由此可见启动最慢的是冷启动，最快的是热启动。着重优化的地方也是冷启动。</p><p>在冷启动下会进行如下的相关流程</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708125305.png"></p><p>与我们代码相关的只有创建Application之后到首帧绘制之前。</p><ol><li><h3 id="Application创建"><a href="#Application创建" class="headerlink" title="Application创建"></a>Application创建</h3><p>当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的黑屏(白屏)，但其实市面上很多app启动都是有一个logo的，再是页面。</p><p>如何解决？</p><p>在themes.xml定义一个主题</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;WelcomeTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--设置背景颜色或者图片--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/xxxx<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--设置没有ActionBar--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!--设置顶部状态栏颜色--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> &gt;</span>@color/xxxx<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708143206.jpg" alt="img" style="zoom:80%;" /><p>但是这样也改变了activity启动后的theme，所以还得在onCreate方法中将主题还原，即</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setTheme(R.style.Theme_Universe); <span class="comment">//恢复原有的样式</span></span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然也可另外用一个activity来用作启动的activity，在里面也可以做一些延时的操作或者加入开屏广告什么的一些操作。</p><p>我们很多时候并不是用系统默认的Application，更多的时候是自定义一个MyApplication，然后在里面做一些初始化的操作。但是如果需要初始化的东西太多了，比如友盟，Bugly，网络请求库，图片加载库，ARouter等，势必会拖慢app的启动速度。那怎么办呢？这些又都是必须要的。只能异步加载了，或者等应用内启动之后再初始化。这里给出一些比价简单的优化操作：</p><ol><li>可以在Application中封装两个方法一个onSyncLoad，一个onAsyncLoad。比如像友盟，Bugly这样的业务非必要的可以的异步加载。可以放在onAsyncLoad中初始化；对于图片，网络请求框架就放在onSyncLoad中初始化。可能有人会觉得onAsyncLoad中异步会额外开销一个Thread，但其实当一个app体量变大后，开销一个Thread带来的收益是远远大于原来同步初始化的</li><li>我们知道ContentProvider作为Android四大组件之一，它的onCreate方法是在Application.attachBaseContext() 和 Application.onCreate()之间执行的（原理后面说），所以我们也可以间接使用它来初始化操作以减轻Application的负担，这也是很多第三方库的做法，比如LeakCanary、Picasso。但是这样也有弊端，要知道ContentProvider属于四大组件之一也是比较重量级的，据测试，一个空ContentProvider启动就耗时2ms，如果数量再增加，那么可能性能优化就得不偿失了。所以JetPack新成员App Startup就诞生了。具体App Startup的使用非常简单，这里就不多说了，给出郭霖的文章：<a href="https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg">https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg</a></li><li>再比如地图，推送等，非第一时间需要的可以在主线程做延时启动。当程序已经启动起来之后，在进行初始化。</li></ol></li><li><h6 id="Activity创建"><a href="#Activity创建" class="headerlink" title="Activity创建"></a>Activity创建</h6></li></ol><p>Activity里面的优化和Application差不多，但是Activity.onCreate方法的开销是最大的，对整个app启动的影响也最大，所以绝对不能再里面执行太耗时的操作。其次是对布局优化也可以缩短onCreate的时间，具体见渲染优化。</p><p>这里再介绍几个用于检测app启动性能的工具：</p><ul><li><p>最简单的就是as自己的日志工具</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708180528.jpg" alt="D"></p><p>搜索词是Displayed，右边选No Files，然后就能看到各个Activity的启动时间了。</p></li><li><p>在Terminal中输入adb shell am start  -W 包名&#x2F;包名.首屏Activity  这一行命令就能看到页面的启动时间</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708181942.png" alt="T" style="zoom:200%;" /><p>控制台输出了以下信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.example.universe/.view.MainActivity &#125;</span><br><span class="line">Status: ok</span><br><span class="line">LaunchState: COLD</span><br><span class="line">Activity: com.example.universe/.view.MainActivity</span><br><span class="line">TotalTime: 3447</span><br><span class="line">WaitTime: 3450</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><p>简单说一下</p><ul><li><p>LaunchState：代表启动方式</p></li><li><p>TotalTime：代表启动时间，包含创建进程+Application 初始化+Activity 初始化到界面显示。</p></li><li><p>WaitTime： 一般比TotalTime 大点，包含系统影响的耗时</p></li></ul></li><li><p>借助优化检测工具</p><p><strong>TraceView</strong></p><p>TraceView是以图形的形式展示执行时间、调用栈等信息，信息比较全面，包含所有线程。<br>使用TraceView检测生成生成的结果会放在Andrid&#x2F;data&#x2F;packagename&#x2F;files路径下。因为Traceview收集的信息比较全面，所以会导致运行开销严重，整体APP的运行会变慢，因此我们无法区分是不是Traceview影响了我们的启动时间。AS已经为我们内置了TraceVeiw，直接用</p><p>具体使用是AS - &gt; 【ProFiler】-&gt; 右侧SESSIONS 旁边的+号 -&gt; 选择你的手机，在选择一个进程  就会出现这样的画面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" alt="F"></p><p>图中A是一些事件的响应，比如点击，屏幕翻转等等</p><p>B是CPU的一些使用情况，这里会说</p><p>C是内存的一些使用情况，等会讲内存优化的时候会说</p><p>D是电量的一些情况，讲耗电优化会说</p><p>E是时间轴</p><p>这里我们点击B区，就会出现下列界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708185117.png" alt="G"></p><p>同样，A是一些事件的响应，B是CPU的执行情况，C是线程列表和线程占用CPU的情况，D是时间轴，E是记录这些情况成文件进行更加细致的分析，这里就不说明了，可以百度其用法。</p><p>以此我们可以更加直观的看出CPU的使用情况，从而找出问题解决问题。</p><p><strong>SysTrace</strong></p><p>Systrace是结合Android内核数据，生成HTML报告，从报告中我们可以看到各个线程的执行时间以及方法耗时和CPU执行时间等。它比TraceView更轻量，但用法差不多，具体用法可参考：<a href="https://www.jianshu.com/p/f83d84dcd0b8">Android Systrace使用介绍 - 简书 (jianshu.com)</a></p></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>在Android的虚拟机中，每fork一个进程，它的内存是给定的，因为移动设备的内存相对PC比较小，资源紧张，因此一个app在运行过程中一定要管理好自己的那部分内存，以提高稳定性。在内存使用中经常出现的问题也是内存抖动和内存泄漏了。</p><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>内存抖动是由于短时间内有大量对象进出JVM的新生区导致的，内存忽高忽低，有短时间内上升和下落的趋势，分析图成锯齿状。</p><p>它伴随着频繁的GC（Garbage Collection垃圾回收），频繁GC会大量占用UI线程和CPU资源，会导致APP整体卡顿，甚至OOM。</p><h5 id="先说为什么频繁GC会导致APP整体卡顿？"><a href="#先说为什么频繁GC会导致APP整体卡顿？" class="headerlink" title="先说为什么频繁GC会导致APP整体卡顿？"></a>先说为什么频繁GC会导致APP整体卡顿？</h5><p>在JVM的GC机制中，垃圾回收有单线程收集和多线程收集，但不管是哪种回收方式，在回收的时候所有用户线程都会被暂停（STW），具体原理涉及JVM的知识了，就不再深入了。所以频繁地GC，用户线程就会被频繁地暂停，自然app就会卡顿。</p><h5 id="为什么频繁GC也有可能会OOM？"><a href="#为什么频繁GC也有可能会OOM？" class="headerlink" title="为什么频繁GC也有可能会OOM？"></a>为什么频繁GC也有可能会OOM？</h5><p>先看一张图</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_230442.jpg" alt="A"></p><p>这里简单说一下JVM的空间担保机制，简单理解就是Java堆划分为新生代 （Young Generation）和老年代（Old Generation）两个区域，新生代空间比较少，只有1&#x2F;3，而老年代有2&#x2F;3，新生代中不断有对象被创建然后回收，只有少部分仍然存在的对象会进入老年代。而当频繁GC时，会导致新生代中有大量对象被创建，然后新生代空间就会不够用，这时候老年代就会划分一部分空间用来给新生代创建大量的对象。这就是JVM的空间担保机制。但是当老年代被划出一部分空间后，假如这时候有一个比较大的对象，比如一张图片，从新生区转移到了老年区，但是这时候老年区被缩小了，剩下的空间不够了，这时候就触发了OOM。</p><h5 id="怎么监测内存抖动？"><a href="#怎么监测内存抖动？" class="headerlink" title="怎么监测内存抖动？"></a>怎么监测内存抖动？</h5><p>AS有自带的检测内存抖动的工具—–Memory Monitor</p><p>其实这个在启动优化工具里面也提到过。</p><p>打开方式：Profiler -&gt;SESSIONS右边的加号选择你的手机在选择你的app   就会出现这样的界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" alt="F"></p><p>这次我们不点B，选择C区Memory，这时候就会出现如下界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709010830.jpg" alt="B"></p><p>A依然是一些事件的反应，B是内存使用的图形化显示，C是鼠标放在图形上就会有各个语言占用内存情况，D是时间轴，但这是内存使用正常的情况，当出现频繁GC的情况时</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709013129.png"></p><p>是这样滴，底部还会有一排垃圾桶表示频繁回收。那么如何定位呢？我们看到左侧有三个选项：</p><ul><li>Capture heap dump：捕获堆转储，什么是堆转储？就是java的内存快照，简单来说就是把这些内存记录写入一个文件，文件类型是hprof，然后进行更细致的分析。更多的时候是结合MAT（Memory Analyzer tool）来分析内存泄漏，这也是比较老的方法，大家可查阅了解一下，但是这种方法比较低效（搞不好as会卡死），现在检测内存泄漏有更方便的工具—LeakCanary</li><li>Record native allocations：记录native相关对象的内存分配</li><li>Record java&#x2F;kotlin allocations：记录java&#x2F;kotlin相关对象的内存分配</li></ul><p>这里一般发生内存抖动都是由于频繁创建java&#x2F;kotlin对象引起的，所以我们选择第三个并点击Record，等待一会就会出现这样的界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709015258.png" alt="A"></p><p>上面一排排的垃圾桶就表示在频繁GC，下面的表格显示了各个对象内存分配情况，我们点击最多的char数组</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020245.jpg" alt="A"></p><p>跟踪可以发现是stringPlus相关操作引起的GC频繁，再看String</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020233.jpg" alt="A"></p><p>这里就追踪到了，原来是MainActivity里面的manyGCTest方法的问题。再看源码</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            Thread&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) manyGCTest()</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">manyGCTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">        repeat(<span class="number">10000</span>)&#123;</span><br><span class="line">            str += it</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给一个按钮设置监听，按下开启线程，在一个死循环里面进行10000次字符串拼接操作，实际上每次str+&#x3D;it都会创建一个对象然后进行字符串拼接，但如果我们换成这样，情况会有所好转</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            Thread&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) manyGCTest()</span><br><span class="line">            &#125;.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">manyGCTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">/*var str = &quot;&quot;</span></span><br><span class="line"><span class="comment">        repeat(10000)&#123;</span></span><br><span class="line"><span class="comment">            str += it</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">        repeat(<span class="number">10000</span>)&#123;</span><br><span class="line">            sb.append(it)</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存抖动减轻</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709021347.png"></p><p>这是因为StringBuilder做字符串拼接只会创建一次对象，所以我们在大量字符串拼接中能使用StringBuilder尽量使用StringBuilder。其实这样的情况也是比较常见的，比如在onDraw里面涉及了很多用Color.parseColor()来解析颜色，但是parseColor里面也涉及了很多字符串的操作，如果一个自定义View比较复杂这种操作很多的话这也会影响app的性能，再或者存储Cookie等等。具体的一些字符串拼接方式的区别这里也不多说了，给出一篇博客：[七种java字符串拼接详解 - &#96;&#96;&#96;…简单点 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/yysbolg/p/13532971.html">https://www.cnblogs.com/yysbolg/p/13532971.html</a>)</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>内存泄漏可以说是面试必问的，也是我们开发者所必须熟知的。那么什么是内存泄漏呢？就是程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。简单来说就是一个对象该被回收却没有被回收，造成了内存浪费。那我们怎么知道一个对象怎么才能被GC回收呢？看一张图</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_233143.jpg" alt="A"></p><p>在JVM中判断一个对象是否应该被回收一般根据可达性分析，如果一个对象的根可达，那它就不应该被回收，反之应该被回收。那么什么是根呢？就是GC roots，GC roots 一般有静态变量，线程栈变量，常量池，JNI（指针）等。举个例子，在我们还没学架构之前一直用的MVC，即所有的网络相关的操作都在Activity中进行，然后用Handler进行线程切换。但是在Handler作为非静态内部类的时候是有可能发生内存泄漏的，因为非静态内部类Handler会持有外部Activity的引用，而message会持有Handler的引用（具体见Handler源码），message会被messageQueue引用，messageQueue又被Looper引用，Looper又被Threadlocal引用，而Threadlocal属于Thread的变量即线程栈变量（GC roots即变量的根）。如果此时message是个延迟消息，而恰好在这延迟的时间段里面Activity被销毁了但是因为它还在被message引用造成它有根，不能被及时回收而一直占用内存。比教好的方案是把Handle写成静态内部类，因为静态内部类是不会持有外部的引用的，或者在onDestroy里面移除所有message。</p><p>这里说个题外话，java的内存泄漏和C&#x2F;C++有什么区别呢？</p><p>在java中，一个进程其实就是一个JVM的实例，进程中的操作都是靠JVM托管的。假如我开启了两个java进程A和B，A用来打游戏，B用来学高数。假如这时候我不想学习了，就是B发生了内存泄漏，B进程就挂掉了，但这并不影响A进程的进行，你挂你的，我运行我的。但在C&#x2F;C++中就不一样了，C&#x2F;C++中没有JVM，发生内存泄漏了影响的是整个操作系统，这个时候只有重启操作系统才会使被浪费的空间得到重用。这也就是为什么电脑用久了不重启一次就会变卡，而手机不会。</p><h5 id="怎么检测内存泄漏呢？"><a href="#怎么检测内存泄漏呢？" class="headerlink" title="怎么检测内存泄漏呢？"></a>怎么检测内存泄漏呢？</h5><p>上面提及了一种方案，就是使用AS自带的Android Profiler工具再结合MAT分析，但这个做法比较低效，难度也比较大，而且如果app比较庞大容易卡死AS，现今比较常用的工具是LeakCanary，它的使用比较高效，方法也比较简单。其实LeakCanary也是基于MAT进行检测Android应用程序的开源工具。</p><p>具体使用：在你的App中加入如下依赖：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:x.x.x&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在启动App的时候就额外出现一个金丝雀的图标</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/qq_pic_merged_1657355581046.jpg"></p><p>这是时候内存泄漏检测就开始了，在你操作App的时候，如果这时候发生了内存泄漏状态栏就会有通知，比如我的手机</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163546.jpg" style="zoom:25%;" /><p>点击通知它就会开始下载文件然后开始分析，分析完之后又会给你一个通知，此时再点进去就能看到LeakCanary为我们生成的发生内存泄漏对象的引用树</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163630.jpg" alt="A" style="zoom:25%;" /><p>可以很明显看到是SecondActivity被MyThread引用而发生内存泄漏，此时再看源码的确如此</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        MyThread().start()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="type">Thread</span>()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            sleep(<span class="number">6</span>*<span class="number">6</span>*<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在进入SecondActivity的时候开启了一个线程并让这个线程睡眠36秒，这时候我再推出当前Activity它不内存泄漏才怪呢。</p><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>在上一章我们说activity在onCreate的时候会绘制布局，这也是性能优化很重要的一个点。</p><p>通过学习view的绘制流程我们知道，对于屏幕刷新频率60hz的手机来说，如果在1000&#x2F;60&#x3D;16.67ms内没有把这一帧的任务执行完毕，就会发生丢帧的现象，丢帧是造成界面卡顿的直接原因，渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout等计算操作，GPU负责Rasterization（栅格化）操作。</p><p>所谓栅格化，就是将矢量图形转换为位图的过程，手机上显示是按照一个个像素来显示的，比如将一个Button、TextView等组件拆分成一个个像素显示到手机屏幕上。而UI渲染优化的目的就是减轻CPU、GPU的压力，除去不必要的操作，保证每帧16ms以内处理完所有的CPU与GPU的计算、绘制、渲染等等操作，使UI顺滑、流畅的显示出来。</p><h4 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h4><p>UI渲染优化的第一步就是找到Overdraw（过度绘制），即描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在重叠的UI布局中，如果不可见的UI也在做绘制的操作或者后一个控件将前一个控件遮挡，会导致某些像素区域被绘制了多次，从而增加了CPU、GPU的压力。</p><p>那么如何找出布局中Overdraw的地方呢？很简单，就是打开手机里开发者选项，然后将调试GPU过度绘制的开关打开即可，然后就可以看到应用的布局是否被Overdraw，比如我打开了调试过度绘制的开关，然后看QQ是这样的<br><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220712_174301.jpg" style="zoom: 25%;" /><br>蓝色、淡绿、淡红、深红代表了4种不同程度的Overdraw情况，1x、2x、3x和4x分别表示同一像素上同一帧的时间内被绘制了多次，1x就表示一次(最理想情况)，4x表示4次(最差的情况)，而我们做性能优化时，考虑消除的就是3x和4x。</p><p>其次是自定义view时的过度绘制，我们知道，自定义View的时候有时会重写onDraw方法，但是Android系统是无法检测onDraw里面具体会执行什么操作，从而系统无法为我们做一些优化。这样对编程人员要求就高了，如果View有大量重叠的地方就会造成CPU、GPU资源的浪费，此时我们可以使用canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视，还有clipPath()也是可以减少过度绘制的，只不过可能效果甚微。</p><h4 id="合理布局"><a href="#合理布局" class="headerlink" title="合理布局"></a>合理布局</h4><p>在Android种系统对View进行测量、布局和绘制时，都是通过对View树的遍历来进行操作的。如果一个View树的高度太高就会严重影响测量、布局和绘制的速度。Google设计嵌套View最多是10层否则会崩溃。现在版本种Google使用RelativeLayout替代LineraLayout作为默认根布局，目的就是降低LineraLayout嵌套产生布局树的高度，从而提高UI渲染的效率。一下是合理布局的一些建议</p><ol><li>布局重用，对于多次重用的布局使用<include>标签来达到重用的目的，对于根布局一样的，可使用<merge>标签取消冗余的viewgroup。比如我我们使用<include>标签的时候可能include里面的布局最外层是<LinearLayout>，而在外部的外层布局也是<LinearLayout>，这时候就可以用<merge>标签替换里面的<LinearLayout>，然后系统就会把include的布局放到外部的LinearLayout而忽视merge，从而减少一层嵌套。</li><li>对于一些复杂的布局我们有时候是不需要一来就全部加载的，这时候就可以用<ViewStub>标签来实现延迟加载，那有人可能会问，我直接设置控件的visible和invisible不行吗，是可以。但是设置visibility属性布局依然会被加载，只是不显示罢了，而VeiwStub只有被设置成visible时才会被加载。</li><li>减少布局层级当布局层级太多的时候可以考虑Constranlayout，这个布局性能很好，适配好还能减少布局间的嵌套，其次可以考虑RelaticeLayout。</li><li>减少不必要的背景设置，减少复杂shape等。能用父布局的背景，子布局就没必要再设置背景。</li></ol><p>那么怎样更直观地看自己App的布局层级呢？AS已经为我们集成了这么一个工具，具体打开的地方（需启动一个app）：</p><p>Tools -&gt; Layout Inspector</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712180704.png"></p><p>左边是你app的布局树，中间是布局预览，右边是布局属性。借此可以全局分析你的app布局，就没必要再去每一个xml布局去看了。</p><h3 id="WebVeiw优化"><a href="#WebVeiw优化" class="headerlink" title="WebVeiw优化"></a>WebVeiw优化</h3><p>WebView也是UI的一个部分，虽然html界面布局我们改变不了，但是我们可以通过WebView的用法去提高webview的性能。</p><h4 id="webview提前初始化"><a href="#webview提前初始化" class="headerlink" title="webview提前初始化"></a><strong>webview提前初始化</strong></h4><p>我们知道每个页面在打开时都会调用setContentView()方法 -&gt; inflate() -&gt; createViewFromTag()，也就是说都会调用view的构造函数，webview也不例外，但是不同的是webview的首次构造耗时比较长。我们可以测试一下</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            test()</span><br><span class="line">            test()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">        WebView(App.appContext)</span><br><span class="line">        <span class="keyword">val</span> stop = System.currentTimeMillis()</span><br><span class="line">        Log.d(<span class="string">&quot;RQ&quot;</span>, <span class="string">&quot;test: <span class="subst">$&#123;stop - start&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-07-12 20:15:07.432 29656-29656/com.example.improvetest D/RQ: test: 167</span><br><span class="line">2022-07-12 20:15:07.435 29656-29656/com.example.improvetest D/RQ: test: 3</span><br></pre></td></tr></table></figure><p>可以看到第二次初始化webview的时间远小于第一次，这是为什么捏？因为它要加载Webview内核，这是一个重量级的操作，内核是以apk的形式存在。而内核加载后在同一页面是共享的，因此后续的初始化时间就很少了。</p><p>那知道了这个我们可以提前初始化一个webview，减少后续webview初始化的时间。</p><h4 id="WebView硬件加速致使页面渲染闪烁"><a href="#WebView硬件加速致使页面渲染闪烁" class="headerlink" title="WebView硬件加速致使页面渲染闪烁"></a><strong>WebView硬件加速致使页面渲染闪烁</strong></h4><p>4.0以上的系统我们开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个反作用就是，但有的时候可能会出现页面闪烁的情况，解决这个问题的方法是在闪烁前将WebView的硬件加速临时关闭，之后再开启，代码以下：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line"><span class="comment">//关闭硬件加速</span></span><br><span class="line"><span class="comment">//webview.setLayerType(View.LAYER_TYPE_SOFTWARE, null)</span></span><br><span class="line"><span class="comment">//开启硬件加速</span></span><br><span class="line">    <span class="comment">//webview.setLayerType(View.LAYER_TYPE_HARDWARE, null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加进度条"><a href="#增加进度条" class="headerlink" title="增加进度条"></a><strong>增加进度条</strong></h4><p>在网络不是很好的情况下，加载页面会出现白屏的情况，虽然我们不能改变，但是我们可以增加一个进度条来让用户知道加载进度，这也算是提升了性能了吧。具体代码如下:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">webView.webChromeClient = <span class="keyword">object</span> :WebChromeClient()&#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressChanged</span><span class="params">(view: <span class="type">WebView</span>?, newProgress: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(newProgress==<span class="number">100</span>)&#123;</span><br><span class="line">                    pg1.setVisibility(View.GONE);<span class="comment">//加载完网页进度条消失</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pg1.setVisibility(View.VISIBLE);<span class="comment">//开始加载网页时显示进度条</span></span><br><span class="line">                    pg1.setProgress(newProgress);<span class="comment">//设置进度值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果webveiw在你的应用中占比很高，很重要，还可以将webview做成一个独立进程（如果有能力），然后用aidl，messager，content provider，广播等来跨进程通信，这样webview就不会影响原app的性能。比如QQ，微信，微信的第一次重构就将webview做成了独立的进程。</p><p>webview我用的也不是很多，把一些我们可能用得上一些问题的做法给大家分享了一些，如果还觉得不够细致，具体可看看<a href="https://juejin.cn/post/6857701249295810568">Android WebView 优化梳理 - 掘金 (juejin.cn)</a></p><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p>卡顿优化其实前面也分析过了，UI绘制卡顿呐，启动慢导致的卡顿呐等等，具体见启动优化和渲染优化。这里说说卡顿到极致—-ANR之后如何解决。</p><h4 id="ANR问题分析"><a href="#ANR问题分析" class="headerlink" title="ANR问题分析"></a>ANR问题分析</h4><p>ANR(Application Not responding)问题一般出现在Activtiy5秒之内无法响应屏幕触摸事件或者键盘输入事件，而BroadcastReceiver如果10秒之内还未执行完操作也会ANR。在实际开发中，ANR是很难从代码上发现的，那么我们应该怎么定位问题呢？其实，当一个进程发生ANR以后，系统会在&#x2F;data&#x2F;anr目录下创建记录ANR问题的文件，通过分析这些文件就能定位ANR的位置。</p><p>这里我们模拟一下ANR，主界面就一个按钮，然后给按钮注册监听：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> button = findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            testANR()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testANR</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后点击按钮两次你就会看到ANR或者直接崩溃。之后我们就假装不知道ANR的位置，开始分析问题。</p><p>在老版本系统（<code>Android8.1</code>以下）的手机上，可以直接利用<code>adb pull /data/anr/traces.txt</code> 命令进行日志导出。</p><p>在新系统中用这个命令是无法导出的，它会提示你权限不够。那么怎么办呢，我们可以通过<code>adb bugreport [导出目录]</code>进行导出，这个会导出一大堆东西（我们只挑选有用的）。比如在控制台执行<code>adb bugreport E:\test</code> ，他会从手机中导出一个<code>zip</code>包到电脑的<code>E:\test</code>目录，会有导出进度显示：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708215247.png" alt="D"></p><p>导出完成：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215035.png" alt="D"></p><p>随后找到导出的文件，解压缩，在<code>/FS/data/anr</code>目录下可以找到程序中的ANR日志。</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215416.png" alt="A"></p><p>打开日志文件大致浏览一下：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708220207.png"></p><p>可以很明显看到是MainActivtiy里面的onCreate里面的按钮的点击事件的testANR方法里面的Thread.sleep造成的ANR，于是我们就可以痛快地解决问题啦。</p><p>当然，实际问题可能比这个更复杂，这里只是告诉大家这么一个方法，到时候就具体问题具体分析。 这里列出一些常见的ANR原因</p><ul><li>主线程阻塞或主线程数据读取</li></ul><blockquote><p>解决办法：避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。尽量避免在主线程query provider、<a href="https://link.jianshu.com/?t=http://weishu.me/2016/10/13/sharedpreference-advices/">不要滥用SharePreferenceS</a></p></blockquote><ul><li>CPU满负荷，I&#x2F;O阻塞</li></ul><blockquote><p>解决办法：文件读写或数据库操作放在子线程异步操作。</p></blockquote><ul><li>内存不足</li></ul><blockquote><p>解决办法：<code>AndroidManifest.xml</code>文件<applicatiion>中可以设置 <code>android:largeHeap=&quot;true&quot;</code>，以此增大App使用内存。不过<strong>不建议使用此法</strong>，从根本上防止内存泄漏，优化内存使用才是正道。</p></blockquote><ul><li>各大组件ANR</li></ul><blockquote><p>各大组件生命周期中也应避免耗时操作，注意BroadcastReciever的onRecieve()、后台Service和ContentProvider也不要执行太长时间的任务。</p></blockquote><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>App的网络连接对于用户来说, 影响很多, 且多数情况下都很直观, 直接影响用户对这个App的使用体验. 其中较为重要的两点：</p><ul><li><strong>流量</strong> ：App的流量消耗对用户来说是比较敏感的，毕竟流量是花钱的嘛.。现在大部分人的手机上都有安装流量监控的工具App，用来监控App的流量使用。如果我们的App这方面没有控制好，会给用户不好的使用体验。</li><li><strong>用户等待</strong> ：也就是用户体验，良好的用户体验，才是我们留住用户的第一步。如果App请求等待时间长，会给用户网络卡，应用反应慢的感觉，如果有对比，有替代品，我们的App很可能就会被用户无情抛弃。</li></ul><h4 id="如何监测app的网络情况"><a href="#如何监测app的网络情况" class="headerlink" title="如何监测app的网络情况"></a>如何监测app的网络情况</h4><p>监测app网络的工具有很多，比如AS自带的，Fiddler代理工具等等。代理工具就不说了，有很多。这里介绍AS自带的工具如何使用。</p><p>启动地方 AS -&gt; App Inspection</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/AAA.png" alt="A"></p><p>然后就是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712233902.png"></p><p>中间的是网络监听状况，左边的是数据库监听状况，最右边的是后台服务的监听状况，看英文应该也好理解。数据库监听是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234246.jpg" alt="A"></p><p>什么表名啊，列都有，存的内容也有。网络监听是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234418.jpg" alt="A"></p><p>蓝色的是下载文件的速度，橙色的是上传文件的速度。后台服务的就不展示了，大家可以试试看。</p><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><h5 id="合理使用网络缓存"><a href="#合理使用网络缓存" class="headerlink" title="合理使用网络缓存"></a>合理使用网络缓存</h5><p>适当的使用缓存，不仅可以让我们的应用看起来更快，也能避免一些不必要的流量消耗，带来更好的用户体验，我们可以对设备的使用状态进行监听，在wifi下可以缓存一部分图片。比方说Splash闪屏广告图片，我们可以在连接到Wifi时下载缓存到本地；新闻类的App可以在Wifi状态下做离线缓存</p><h5 id="限制访问次数"><a href="#限制访问次数" class="headerlink" title="限制访问次数"></a>限制访问次数</h5><p>我们在开发app过程中有的时候会设置一个按钮，然后点击按钮发送请求，这样其实不是最优做法，如果我点击很多次按钮，就会在短时间内发送多次请求，那么就会浪费流量，也很消耗app的性能。所以我们需要限制访问次数，两种方案</p><ol><li>限制按钮的点击次数</li><li>封装网络请求框架，在框架里限制同一时间访问的次数</li></ol><h5 id="不同状态展现不同页面"><a href="#不同状态展现不同页面" class="headerlink" title="不同状态展现不同页面"></a>不同状态展现不同页面</h5><p>加载时显示好康的动画，留住用户，加载失败也要展现好康的动画给用户看（别直接崩溃了）。</p><p>其实说了这么多，一个好的网络请求框架就可以解决这些网络优化的问题，把这些解决方案封装在自己的网络请求框架里是最好的选择。</p><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><p>现今，我们可能对流量都不是很缺，而且基本每家都有wifi，相较与流量我觉得一个app的耗电对用户更加敏感，现在市面上的手机基本上都有监控每个app的耗电功能，比如我的</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220713_140120.jpg" style="zoom:25%;" /><p>可以看到QQ后台耗电多，抖音前台耗电多，但是这是QQ，没办法都得用，如果我们自己的app可能就被卸载了。那么我们先来分析一下为什么会耗电，盗用网上一张图就是</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d23d65e12d34ad396b8826de6bf2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>事实上就是软件调用硬件而产生了耗电，那有哪些硬件是可以控制的捏？</p><img src="https://img-blog.csdnimg.cn/img_convert/451499b3b9f8131b8396c7870d76670a.png" alt="img" style="zoom: 50%;" /><p>有这么这么多，我们就看几个常用的，CPU、GPU、Video、Audio、GPS、Network</p><h5 id="Video、Audio"><a href="#Video、Audio" class="headerlink" title="Video、Audio"></a>Video、Audio</h5><p>在使用这些功能的使用时候，他牵涉的不单单一个元器件的问题，而是更多，所以我们在使用这些功能的时候要做到离开即刻关闭释放。这两个组件用的最多的可能就是短视频和直播app了，如果出现这部分耗电严重，可以看看这些解决方案：</p><ol><li>线程数是否暴增。</li><li>弹幕是否做到复用了，是否存在内存泄露问题。</li><li>动画特效是否及时释放，执行效率是否很快。</li><li>承载功能的实例是否存在多份。</li><li>检查内存、cpu使用情况。</li></ol><h5 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h5><p>无线网络包括移动网络和wifi两种情况。移动网络是比wifi更加耗电的。</p><p><strong>移动网络</strong></p><p>移动网络数据传输有3种状态：</p><p>高功率状态：网络激活，允许设备以最大传输速率进行传输。</p><p>低功率状态：传输速率低于15kbps，耗电是高功率状态的一半，一般不能直接从程序中进入该状态，而是由高功率状态降级进入。</p><p>空闲状态：没有数据连接需要传输，耗电最少。可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态大概需要2s，从低功率状态转换到高功率状态需要1.5s。</p><p>应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。</p><p><strong>WIFI网络</strong></p><p>WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。</p><p>当从低(高)功率状态传输数据时，WIFI会暂时进入相应的低(高)传输状态，一旦数据传输完毕就回到初始状态。WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。通过上面了解了网络连接过程，应该心里有了大概的优化建议。</p><p><strong>网络耗电优化方案：</strong></p><ol><li>文本和文件压缩传输。 不管发送还是请求数据，在数据传输过程中使用gzip（Gzip是传输时将文件压缩传输的一种技术，okhttp默认是使用了gzip的）将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样使得无线所处的高功率状态时间更短，从而减少了耗电。</li><li>精简文本文件，去掉文本中空行、空格、注释等无意义内容。</li><li>请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回，采用使用webp图片。（节省传输时间）</li></ol><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h5><p>cpu作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。通过上面的两个概念我们大概知道，一个我们负责设备运算和控制的元器件，一个是程序运算调度的最小单位。</p><p>CPU被高频次使用大概有以下几个原因：</p><ol><li><p>程序运算复杂(高运算量)，例如高精度等，导致CPU满负荷运载，这里优化可能就设计数据结构、算法啥的。</p></li><li><p>程序线程短时间内无规则抢占CPU资源。</p></li><li><p>wakelock唤醒。wakelock是什么？</p><blockquote><p>为了延长电池的使用寿命，Android设备会在一段时间后使屏幕变暗，然后关闭屏幕显示，最后停止CPU。WakeLock是一个电源管理系统服务功能，应用程序可以使用它来控制设备的电源状态。</p><p>WakeLock可以用来保持CPU运行，避免屏幕变暗和关闭，以及避免键盘背光灯熄灭。</p></blockquote></li><li><p>定时器（AlarmManager）。</p></li></ol><h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h5><p>我们用的多是GPS定位、Sensor遥感，只有当我们需要的时候才去打开这些硬件资源，并且及时释放，就能做到电量使用最优了。</p><p>接下来介绍一下AS对手机电量监控的工具，具体打开方式：AS -&gt; Profiler -&gt; Energy</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220713002246.png"></p><p>其实跟之前看CPU和内存差不多，鼠标放上去能看到CPU、Network、Location的耗电程度，大致分为None、Light（轻）、Medium（中）、Heavy（严重）</p><p>当然，还有个更好的检测软件，叫Battery Historian，这里就不演示了，可自行上网查询。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对性能优化的学习，我发现他涉及的知识是方方面面的，像AMS、PMS、WMS、hook、启动流程等等等等，所以我觉得要真正做到性能优化，对这些一定要很了解的，不然完全不知道从哪下手。同时，这篇文章肯定还存在不足，可能也有错误，如果大家发现了都可以提出来。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
